{"./":{"url":"./","title":"Introduction","keywords":"","body":"Cocos Creator 3D v1.0.0 用户手册 欢迎使用 Cocos Creator 3D 用户手册！本手册包括详尽的使用说明、面向不同职能用户的工作流程和 step by step 的新手教程。能够帮您快速掌握使用 Cocos Creator 3D 开发跨平台游戏的方法。 注意：请在右上角根据您使用的 Cocos Creator 3D 版本选择相应的手册版本。 总导读 新手入门 安装和启动 快速上手：制作第一个游戏 引擎手册 场景 材质 声音 粒子 动画 物理 UI 事件机制 脚本指南 编辑器手册 快速入门 面板介绍 组件 项目预览调试 粒子编辑器 动画系统 构建发布 资源手册 关于资源 资源工作流 获取和加载资源 分包加载 场景资源 图像资源 预制资源 脚本资源 字体资源 声音资源 材质资源 模型资源 动画资源 演示和范例项目 范例集合：从基本组件的使用到渲染效果的展示，这个项目里包括了多个侧重功能不同的场景提供给用户参考。 一步两步：也就是 快速上手 文档里分步讲解制作的游戏。 UI 展示 Demo 注意，这些项目会不定期跟随版本进行更新。它们在 GitHub 上的默认分支是 master，对应的一般是最新的 Cocos Creator 3D 及 版本。如果仍在使用旧版本的 Cocos Creator 3D，这些项目有可能会打不开，可尝试切换到和旧版本相同命名的分支。 "},"helloworld.html":{"url":"helloworld.html","title":"Beginner Guide","keywords":"","body":"Hello World! "},"getting-started/":{"url":"getting-started/","title":"启动","keywords":"","body":"安装和启动 欢迎使用 Cocos Creator 3D，在学习使用之前，请先按照以下步骤安装好编辑器开发环境。 本章节包括以下内容： Dashboard Hello world! 继续前往 Dashboard 说明文档。 "},"getting-started/dashboard/":{"url":"getting-started/dashboard/","title":"Dashboard","keywords":"","body":"使用Dashboard Dashboard为起始页，您可以浏览、创建、导入项目。 界面总览 打开项目 选择标签栏的打开项目 新建项目 选择标签栏的新建项目，并选择一个项目模板及路径后，点击下方的新建项目按钮。 帮助 选择标签栏的帮助，帮助能使您对cocos creator有一个初步的了解。 "},"getting-started/helloworld/":{"url":"getting-started/helloworld/","title":"Hello world!","keywords":"","body":"Hello World项目 第一个cocos creator项目, 为您展示: 创建项目 了解工程目录 创建一个物体 修改相机属性 创建、修改、绑定脚本 运行及调试项目 新建项目 选择空的模板，设置项目路径，点击下方的新建项目按钮。 编辑器界面 工程目录 通常情况的我们只需要关心assets(资源目录) assets(资源目录) build(构建目录) library(导入的资源目录) local(日志文件目录) profiles(编辑器配置) temp(临时文件目录) package.json(项目配置) 新建场景 左下方资源管理器面板点击鼠标右键，选择新建->Scene。 创建物体 左上方层级管理器面板点击鼠标右键, 选择创建->3D对象->Cube 正方体。创建的正方体就会出现在场景编辑器里。 修改Camera 选择Camera对象 在层级管理器面板，选择Camera，场景编辑器会选中它，并显示Gizmo。 修改Camera位置 在场景编辑器里，拖动Gizmo, 使Camera能够看到创建的正方体。 修改Camera背景颜色 在属性检查器面板，点击Color属性，选择黑色为背景色。 添加脚本 新建脚本 在资源管理器面板点击鼠标右键，选择新建->JavaScript。 生命周期函数（按以下顺序调用） onLoad 脚本初始化时调用 onEnable 组件的 enabled 属性从 true 变为 false 时调用 start 组件第一次激活时调用 update 每一帧渲染前更新物体调用 lateUpdate 在所有组件的 update 都执行完之后调用 onDisable 组件的 enabled 属性从 false 变为 true 时调用 onDestroy 组件或者所在节点销毁时调用 添加代码 添加onLoad()函数，并输出Hello world import { _decorator, Component } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"normal\") export class normal extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. console.info('Hello world'); } // update (deltaTime) { // // Your update function goes here. // } } 为物体绑定脚本 选择创建的正方体，在属性检查器面板点击添加组件->自定义脚本->HelloWorld 运行项目 编辑器菜单栏点击->项目->运行预览, 或者点击中间的运行按钮。 调试项目 点击编辑器菜单栏点击->开发者->打开场景调试工具 日志信息 Console面板显示了所有日志输出 断点调试 选择标签栏的Source选项，按下CTRL+P，搜索HelloWorld.js，在onLoad函数里设置断点，再运行预览时就可以调试了。 "},"getting-started/first-game/":{"url":"getting-started/first-game/","title":"快速上手：制作第一个游戏","keywords":"","body":"快速上手：制作第一个游戏 Cocos Creator 3D编辑器的强大之处就是可以让开发者快速的制作游戏原型。 下面我们将跟随教程制作一款名叫 一步两步 的魔性小游戏。这款游戏考验玩家的反应能力，根据路况选择是要跳一步还是跳两步，“一步两步，一步两步，一步一步似爪牙似魔鬼的步伐”。 可以在 这里 体验一下游戏的完成形态。 新建项目 如果您还不了解如何获取和启动 Cocos Creator 3D，请阅读 安装和启动 一节。 首先启动 Cocos Creator 3D，然后新建一个名为 MindYourStep 的项目，如果不知道如果创建项目，请阅读 Hello World!。 新建项目后会看到如下的编辑器界面： 创建游戏场景 在 Cocos Creator 3D 中，游戏场景（Scene） 是开发时组织游戏内容的中心，也是呈现给玩家所有游戏内容的载体。游戏场景中一般会包括以下内容： 场景物体 角色 UI 以组件形式附加在场景节点上的游戏逻辑脚本 当玩家运行游戏时，就会载入游戏场景，游戏场景加载后就会自动运行所包含组件的游戏脚本，实现各种各样开发者设置的逻辑功能。所以除了资源以外，游戏场景是一切内容创作的基础。现在，让我们来新建一个场景。 在 资源管理器 中点击选中 assets 目录，点击 资源管理器 左上角的加号按钮，选择文件夹，命名为Scenes。 点击先中Scenes目录（下图把一些常用的文件夹都提前创建好了），点击鼠标右键，在弹出的菜单中选择 场景文件 我们创建了一个名叫 New Scene 的场景文件，创建完成后场景文件 New Scene 的名称会处于编辑状态，将它重命名为 Main。 双击 Main，就会在 场景编辑器 和 层级管理器 中打开这个场景。 添加跑道 我们的主角需要在一个由方块（Block）组成的跑道上从屏幕左边向右边移动。我们使用编辑器自带的立方体（Cube）来组成道路。 在 层级管理器 中创建一个立方体（Cube），并命名为Cube。 选中Cube，按Ctrl+D来复制出3个Cube。 将3个Cube按以下坐标排列：第一个节点位置（0，-1.5，0），第二个节点位置（1，-1.5，0），第三个节点位置（2，-1.5，0） 效果如下： 添加主角 创建主角节点 首先创建一个名字为Player的空节点，然后在这个空节点下创建名为Body的主角模型节点，为了方便，我们采用编辑器自带的胶囊体模型做为主角模型。 分为两个节点的好处是，我们可以使用脚本控制Player节点来使主角进行水平方向移动，而在Body节点上做一些垂直方向上的动画（比如原地跳起后下落），两者叠加形成一个跳越动画。 将Player节点设置在（0，0，0）位置，使得它能站在第一个方块上。 效果如下： 编写主角脚本 想要主角影响鼠标事件来进行移动，我们就需要编写自定义的脚本。如果您从没写过程序也不用担心，我们会在教程中提供所有需要的代码，只要复制粘贴到正确的位置就可以了，之后这部分工作可以找您的程序员小伙伴来解决。下面让我们开始创建驱动主角行动的脚本吧。 创建脚本 如果还没有创建Scripts文件夹，首先在 资源管理器 中右键点击 assets 文件夹，选择 新建 -> 文件夹，重命名为Scripts。 右键点击Scripts文件夹，选择 新建 -> TypeScript，创建一个 TypeScript 脚本，有关TypeScript资料可以查看 TypeScript 官方网站。 将新建脚本的名字改为PlayerController，双击这个脚本，打开代码编辑器（例如VSCode）。 注意： Cocos Creator 3D 中脚本名称就是组件的名称，这个命名是大小写敏感的！如果组件名称的大小写不正确，将无法正确通过名称使用组件！ 编写脚本代码 在打开的 PlayerController 脚本里已经有了预先设置好的一些代码块，如下所示： import { _decorator, Component } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. } // update (deltaTime: number) { // // Your update function goes here. // } } 这些代码就是编写一个组件（脚本）所需的结构。具有这样结构的脚本就是 Cocos Creator 3D 中的 组件（Component），他们能够挂载到场景中的节点上，提供控制节点的各种功能，更详细的脚本信息可以查看 脚本。 我们在脚本中添加对鼠标事件的监听，然后让Player动起来，将PlayerController中代码做如下修改。 @ccclass(\"PlayerController\") export class PlayerController extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; // for fake tween private _startJump: boolean = false; private _jumpStep: number = 0; private _curJumpTime: number = 0; private _jumpTime: number = 0.1; private _curJumpSpeed: number = 0; private _curPos: Vec3 = cc.v3(); private _deltaPos: Vec3 = cc.v3(0, 0, 0); private _targetPos: Vec3 = cc.v3(); private _isMoving = false; start () { // Your initialization goes here. systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } onMouseUp(event: EventMouse) { if (event.getButton() === 0) { this.jumpByStep(1); } else if (event.getButton() === 2) { this.jumpByStep(2); } } jumpByStep(step: number) { if (this._isMoving) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); vmath.vec3.add(this._targetPos, this._curPos, cc.v3(this._jumpStep, 0, 0)); this._isMoving = true; } onOnceJumpEnd() { this._isMoving = false; } update (deltaTime: number) { if (this._startJump) { this._curJumpTime += deltaTime; if (this._curJumpTime > this._jumpTime) { // end this.node.setPosition(this._targetPos); this._startJump = false; this.onOnceJumpEnd(); } else { // tween this.node.getPosition(this._curPos); this._deltaPos.x = this._curJumpSpeed * deltaTime; vmath.vec3.add(this._curPos, this._curPos, this._deltaPos); this.node.setPosition(this._curPos); } } } } 现在我们可以把 PlayerController 组件添加到主角节点上。在 层级管理器 中选中 Player 节点，然后在 属性检查器 中点击 添加组件 按钮，选择 添加用户脚本组件 -> PlayerController，为主角节点添加 PlayerController 组件。 为了能在运行时看到物体，我们需要将场景中的Camera进行一些参数调整，将位置放到（0，0，13），Color设置为（50，90，255，255）： 现在点击工具栏中心位置的Play按钮，在打开的网页中点击鼠标左键和右键，可以看到如下画面： 更多的预览功能，可以参考 项目预览调试 添加角色动画 从上面运行的结果可以看到单纯对Player进行水平方向的移动是十分呆板的，我们要让Player跳跃起来才比较有感觉，我们可以通过为角色添加垂直方向的动画来达到这个效果。有关 动画编辑器 的更多信息，请阅读 动画编辑器 选中场景中的Body节点，编辑器下方 控制台 边上的 动画编辑器，添加Animation组件并创建Clip，命名为oneStep。 进入动画编辑模式，添加position属性轨道，并添加三个关键帧，position值分别为（0，0，0）、（0，0.5，0）、（0，0，0）。 退出动画编辑模式前前记得要保存动画，否则做的动画就白费了。 我们还可以通过 资源管理器 来创建Clip，下面我们创建一个名为twoStep的Clip并将它添加到Body身上的 AnimationComponent 上，这里为了录制方便调整了一下面板布局。 进入动画编辑模式，选择并编辑twoStep的clip，类似第2步，添加三个position的关键帧，分别为（0，0，0）、（0，1，0）、（0，0，0）。 在 PlayerController组件 中引用 动画组件 ，我们需要在代码中根据跳的步数不同来播放不同的动画。 首先需要 在 PlayerController组件 中引用Body身上的 AnimationComponent。 @property({type: AnimationComponent}) public BodyAnim: AnimationComponent = null; 然后在 属性检查器 中将Body身上的 AnimationComponent 拖到这个变量上。 在跳跃的函数 jumpByStep 中加入动画播放的代码： if (step === 1) { this.BodyAnim.play('oneStep'); } else if (step === 2) { this.BodyAnim.play('twoStep'); } 点击Play按钮,点击鼠标左键、右键，可以看到新的跳跃效果： 跑道升级 为了让游戏有更久的生命力，我们需要一个很长的跑道来让Player在上面一直往右边跑，在场景中复制一堆Cube并编辑位置来组成跑道显然不是一个明智的做法，我们通过脚本完成跑道的自动创建。 游戏管理器（GameManager） 一般游戏都会有一个管理器，主要负责整个游戏生命周期的管理，可以将跑道的动态创建代码放到这里。在场景中创建一个名为GameManager的节点，然后在 assets/Scripts 中创建一个名为GameManager的ts脚本文件，并将它添加到GameManager节点上。 制作Prefab 对于需要重复生成的节点，我们可以将他保存成 Prefab（预制） 资源，作为我们动态生成节点时使用的模板。关于 Prefab 的更多信息，请阅读 预制资源（Prefab）。 我们将生成跑道的基本元素正方体（Cube）制作成Prefab，之后可以把场景中的三个Cube都删除了。 添加自动创建跑道代码 我们需要一个很长的跑道，理想的方法是能动态增加跑道的长度，这样可以永无止境的跑下去，这里为了方便我们先生成一个固定长度的跑道，跑道长度可以自己定义。跑道上会生成一些坑，跳到坑上就GameOver了。 将GameManager脚本中代码替换成以下代码： import { _decorator, Component, Prefab, instantiate, Node, CCInteger} from \"cc\"; const { ccclass, property } = _decorator; enum BlockType{ BT_NONE, BT_STONE, }; @ccclass(\"GameManager\") export class GameManager extends Component { @property({type: Prefab}) public cubePrfb: Prefab = null; @property({type: CCInteger}) public roadLength: Number = 50; private _road: number[] = []; start () { this.generateRoad(); } generateRoad() { this.node.removeAllChildren(true); this._road = []; // startPos this._road.push(BlockType.BT_STONE); for (let i = 1; i 在GameManager的inspector面板中可以通过修改roadLength的值来改变跑道的长度。 预览可以看到现在自动生成了跑道，不过因为Camera没有跟随Player移动，所以看不到后面的跑道，我们可以将场景中的Camera设置为Player的子节点。 这样Camera就会跟随Player的移动而移动，现在预览可以从头跑到尾的观察生成的跑道了。 增加开始菜单 开始菜单是游戏不可或缺的一部分，我们可以在这里加入游戏名称、游戏简介、制作人员等信息。 添加一个名为Play的按钮 这个操作生成了一个Canvas节点，一个PlayButton节点和一个Label节点。因为UI组件需要在带有 CanvasComponent 的父节点下才能显示，所以编辑器在发现目前场景中没有带这个组件的节点时会自动添加一个。 创建按钮后，将Label节点上的 cc.LabelComponent 的String属性从Button改为Play。 在Canvas底下创建一个名字为StartMenu的空节点，将PlayButton拖到它底下。我们可以通过点击工具栏上的2D/3D按钮来切换到2D编辑视图下进行UI编辑操作，详细的描述请查阅 场景编辑。 增加一个背景框，在StartMenu下新建一个名字为BG的Sprite节点，调节它的位置到PlayButton的上方，设置它的宽高为（200，200）,并将它的SpriteFrame设置为 internal/default_ui/default_sprite_splash 。 添加一个名为Title的 Label 用于开始菜单的标题，。 修改Title的文字，并调整Title的位置、文字大小、颜色。 增加操作的Tips，然后调整PlayButton的位置，一个简单的开始菜单就完成了 增加游戏状态逻辑，一般我们可以将游戏分为三个状态： 初始化（Init）：显示游戏菜单，初始化一些资源。 游戏进行中（Playing）：隐藏游戏菜单，玩家可以操作角度进行游戏。 结束（End）：游戏结束，显示结束菜单。 使用一个枚举（enum）类型来表示这几个状态。 enum BlockType{ BT_NONE, BT_STONE, }; enum GameState{ GS_INIT, GS_PLAYING, GS_END, }; GameManager脚本中加入表示当前状态的私有变量 private _curState: GameState = GameState.GS_INIT; 为了在开始时不让用户操作角色，而在游戏进行时让用户操作角色，我们需要动态的开启和关闭角色对鼠标消息的监听。 所以对PlayerController做如下的修改： start () { // Your initialization goes here. //systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } setInputActive(active: boolean) { if (active) { systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } else { systemEvent.off(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } } 然后需要在GameManager脚本中引用PlayerController，需要在Inspector中将场景的Player拖入到这个变量中。 @property({type: PlayerController}) public playerCtrl: PlayerController = null; 为了动态的开启\\关闭开启菜单，我们需要在GameManager中引用StartMenu节点，需要在Inspector中将场景的StartMenu拖入到这个变量中。 @property({type: Node}) public startMenu: Node = null; 增加状态切换代码，并修改GameManger的初始化方法： start () { this.curState = GameState.GS_INIT; } init() { this.startMenu.active = true; this.generateRoad(); this.playerCtrl.setInputActive(false); this.playerCtrl.node.setPosition(cc.v3()); } set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: this.startMenu.active = false; setTimeout(() => { //直接设置active会直接开始监听鼠标事件，做了一下延迟处理 this.playerCtrl.setInputActive(true); }, 0.1); break; case GameState.GS_END: break; } this._curState = value; } 添加对Play按钮的事件监听。 为了能在点击Play按钮后开始游戏，我们需要对按钮的点击事件做出响应。 在GameManager脚本中加入响应按钮点击的代码，在点击后进入游戏的Playing状态： onStartButtonClicked() { this.curState = GameState.GS_PLAYING; } 然后在Play按钮的Inspector上添加ClickEvents的响应函数。 现在预览场景就可以点击Play按钮开始游戏了。 添加游戏结束逻辑 目前游戏角色只是呆呆的往前跑，我们需要添加游戏规则，来让他跑的更有挑战性。 角色每一次跳跃结束需要发出消息，并将自己当前所在位置做为参数发出消息 在PlayerController中记录自己跳了多少步 private _curMoveIndex = 0; // ... jumpByStep(step: number) { // ... this._curMoveIndex += step; } 在每次跳跃结束发出消息： onOnceJumpEnd() { this._isMoving = false; this.node.emit('JumpEnd', this._curMoveIndex); } 在GameManager中监听角色跳跃结束事件，并根据规则判断输赢 增加失败和结束判断，如果跳到空方块或是超过了最大长度值都结束： checkResult(moveIndex: number) { if (moveIndex 监听角色跳跃消息，并调用判断函数： start () { this.curState = GameState.GS_INIT; this.playerCtrl.node.on('JumpEnd', this.onPlayerJumpEnd, this); } // ... onPlayerJumpEnd(moveIndex: number) { this.checkResult(moveIndex); } 此时预览，会发现重新开始游戏时会有判断出错，是因为我们重新开始时没有重置PlayerController中的_curMoveIndex属性值。所以我们在PlayerController中增加一个reset函数： reset() { this._curMoveIndex = 0; } 在GameManager的init函数调用reset来重置PlayerController的属性。 init() { \\\\ ... this.playerCtrl.reset(); } 步数显示 我们可以将当前跳的步数显示到界面上，这样在跳跃过程中看着步数的不断增长会十分有成就感。 在Canvas下新建一个名为Steps的Label，调整位置、字体大小等属性。 在GameManager中引用这个Label @property({type: LabelComponent}) public stepsLabel: LabelComponent = null; 将当前步数数据更新到这个Label中 因为我们现在没有结束界面，游戏结束就跳回开始界面，所以在开始界面要看到上一次跳的步数，因此我们在进入Playing状态时，将步数重置为0。 set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: this.startMenu.active = false; this.stepsLabel.string = '0'; // 将步数重置为0 setTimeout(() => { //直接设置active会直接开始监听鼠标事件，做了一下延迟处理 this.playerCtrl.setInputActive(true); }, 0.1); break; case GameState.GS_END: break; } this._curState = value; } 在响应角色跳跃的函数中，将步数更新到Label控件上 onPlayerJumpEnd(moveIndex: number) { this.stepsLabel.string = '' + moveIndex; this.checkResult(moveIndex); } 最终代码 PlayerController.ts ```ts import { _decorator, Component, Vec3, vmath, systemEvent, SystemEvent, EventMouse, AnimationComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"PlayerController\") export class PlayerController extends Component { @property({type: AnimationComponent}) public BodyAnim: AnimationComponent = null; // for fake tween private _startJump: boolean = false; private _jumpStep: number = 0; private _curJumpTime: number = 0; private _jumpTime: number = 0.1; private _curJumpSpeed: number = 0; private _curPos: Vec3 = cc.v3(); private _deltaPos: Vec3 = cc.v3(0, 0, 0); private _targetPos: Vec3 = cc.v3(); private _isMoving = false; private _curMoveIndex = 0; start () { } reset() { this._curMoveIndex = 0; } setInputActive(active: boolean) { if (active) { systemEvent.on(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } else { systemEvent.off(SystemEvent.EventType.MOUSE_UP, this.onMouseUp, this); } } onMouseUp(event: EventMouse) { if (event.getButton() === 0) { this.jumpByStep(1); } else if (event.getButton() === 2) { this.jumpByStep(2); } } jumpByStep(step: number) { if (this._isMoving) { return; } this._startJump = true; this._jumpStep = step; this._curJumpTime = 0; this._curJumpSpeed = this._jumpStep / this._jumpTime; this.node.getPosition(this._curPos); vmath.vec3.add(this._targetPos, this._curPos, cc.v3(this._jumpStep, 0, 0)); this._isMoving = true; if (step === 1) { this.BodyAnim.play('oneStep'); } else if (step === 2) { this.BodyAnim.play('twoStep'); } this._curMoveIndex += step; } onOnceJumpEnd() { this._isMoving = false; this.node.emit('JumpEnd', this._curMoveIndex); } update (deltaTime: number) { if (this._startJump) { this._curJumpTime += deltaTime; if (this._curJumpTime > this._jumpTime) { // end this.node.setPosition(this._targetPos); this._startJump = false; this.onOnceJumpEnd(); } else { // tween this.node.getPosition(this._curPos); this._deltaPos.x = this._curJumpSpeed * deltaTime; vmath.vec3.add(this._curPos, this._curPos, this._deltaPos); this.node.setPosition(this._curPos); } } } } GameManager.ts ```ts import { _decorator, Component, Prefab, instantiate, Node, LabelComponent, CCInteger} from \"cc\"; import { PlayerController } from \"./PlayerController\"; const { ccclass, property } = _decorator; enum BlockType{ BT_NONE, BT_STONE, }; enum GameState{ GS_INIT, GS_PLAYING, GS_END, }; @ccclass(\"GameManager\") export class GameManager extends Component { @property({type: Prefab}) public cubePrfb: Prefab = null; @property({type: CCInteger}) public roadLength: Number = 50; private _road: number[] = []; @property({type: Node}) public startMenu: Node = null; @property({type: PlayerController}) public playerCtrl: PlayerController = null; private _curState: GameState = GameState.GS_INIT; @property({type: LabelComponent}) public stepsLabel: LabelComponent = null; start () { this.curState = GameState.GS_INIT; this.playerCtrl.node.on('JumpEnd', this.onPlayerJumpEnd, this); } init() { this.startMenu.active = true; this.generateRoad(); this.playerCtrl.setInputActive(false); this.playerCtrl.node.setPosition(cc.v3()); this.playerCtrl.reset(); } set curState (value: GameState) { switch(value) { case GameState.GS_INIT: this.init(); break; case GameState.GS_PLAYING: this.startMenu.active = false; this.stepsLabel.string = '0'; // 将步数重置为0 setTimeout(() => { //直接设置active会直接开始监听鼠标事件，做了一下延迟处理 this.playerCtrl.setInputActive(true); }, 0.1); break; case GameState.GS_END: break; } this._curState = value; } generateRoad() { this.node.removeAllChildren(true); this._road = []; // startPos this._road.push(BlockType.BT_STONE); for (let i = 1; i 光照和阴影 有光的地方就会有影子，光和影使得3D世界更加的立体。接下来我们为角色加上简单的影子。 开启阴影 在 层级管理器 中点击最顶部的 Scene 节点，将planarShadows选项中的Enabled打钩，并修改Distance和Normal参数 点击Player节点下的Body节点，将 cc.ModelComponent 下的ShadowCastingMode设置为ON。 此时在场景编辑器中会看到一个阴影面片，预览会发现看不到这个阴影，因为它在模型的正后方，被胶囊体盖住了。 调整光照 新建场景时默认会添加一个 DirctionalLight ，由这个平行光计算阴影，所以为了让阴影换个位置显示，我们可以调整这个平行光的方向。 在 层级管理器 中点击选中 Main Light 节点，调整Rotation参数为（-10，17，0）。 预览可以看到影子效果： 总结 恭喜您完成了用 Cocos Creator 3D 制作的第一个游戏！在 这里 可以下载完整的工程，希望这篇快速入门教程能帮助您了解 Cocos Creator 3D 游戏开发流程中的基本概念和工作流程。如果您对编写和学习脚本编程不感兴趣，也可以直接从完成版的项目工程中把写好的脚本复制过来使用。 接下来您还可以继续完善游戏的各方各面，以下是一些推荐的改进方向： 为游戏增加难度，当角色在原地停留1秒就算失败 改为无限跑道，动态的删除已经跑过的跑道，延长后面的跑道。 增加游戏音效 为游戏增加结束菜单界面，统计玩家跳跃步数和所花的时间 用更漂亮的资源替换角色和跑道 可以增加一些可拾取物品来引导玩家“犯错” 添加一些粒子特效，例如角色运动时的拖尾、落地时的灰尘 为触屏设备加入两个操作按钮来代替鼠标左右键操作 此外如果希望将完成的游戏发布到服务器上分享给好友玩耍，可以阅读 发布工作流 一节的内容。 "},"getting-started/attention/":{"url":"getting-started/attention/","title":"注意事项","keywords":"","body":"注意事项 语法格式 Cocos Creator 3D 不同于 Cocos Creator 的语法格式，Cocos Creator 3D 已全面支持 ES6 和 TS，因此在 Cocos Creator 3D 上只支持 ES6 和 TS 的 class，此外，我们还支持了 TS 的语法提示。针对 Cocos Creator 支持 ES5 语法的 cc.Class 形式已不再作出支持，请各位开发者悉知。 "},"concepts/scene/":{"url":"concepts/scene/","title":"场景","keywords":"","body":"场景 场景是游戏中的环境因素的抽象集合，是创建游戏环境的局部单位，我们可以理解为游戏开发设计人员通过在编辑器中制作一个场景，来表现游戏中的一部分世界内容。 本章节包括以下内容： 坐标系 场景结构 节点 相机 光源 继续前往 坐标系 说明文档。 "},"concepts/scene/coord.html":{"url":"concepts/scene/coord.html","title":"坐标系","keywords":"","body":"坐标系 世界坐标系 Cocos Creator 3D 的世界坐标系，采用笛卡尔右手坐标系，原点在左下角，x 向右，y 向上，z 向外。 屏幕坐标系 Cocos Creator 3D 的屏幕坐标系原点为屏幕左下角，x 向右，y 向上。 继续前往 场景结构 说明文档。 "},"concepts/scene/scene.html":{"url":"concepts/scene/scene.html","title":"场景结构","keywords":"","body":"场景结构 Cocos Creator 3D 在 Creator 的 ECS 实体组件系统框架上增加了3D场景结构，3D 场景通过 RenderScene 表示，ECS 结构中相应的 Component 引用了 RenderScene 中维护的模型（Model）、相机（Camera）、灯光（Light）等元素，它们通过 Node 关联在一起，RenderScene 中更新元素的各种 Transform，也是通过 Node 来操作。 注意区别 ECS 结构中的 Scene 与 3D 场景结构中的 RenderScene，ECS 中的 Scene 作为 Node 的逻辑组织结构，而 RenderScene 是作为场景渲染元素的组织结构，ECS Scene 中包含了 RenderScene 成员变量，两者一一对应。 ECS 与 3D 场景结构的关系，如下图所示： 整个 3D 场景结构是被封装在 Component 之下的，通过 Node 建立起组织关系，这样对于 ECS 的上层用户来说，是完全透明的，用户层面对于 3D 场景结构对象是无感知的。 继续前往 节点 说明文档。 "},"concepts/scene/node.html":{"url":"concepts/scene/node.html","title":"节点","keywords":"","body":"节点 节点是场景的基础组成单位。节点之间是树状的组织关系，每个节点可以有多个子节点，同时对应一个父节点。 节点具有以下特性： 节点包含一组基础信息（位移、旋转、缩放），节点之间通过一组相对变换关系组织在一起 节点间的更新顺序是逐级更新的，子节点的更新依赖于父节点，子节点更随父节点变换 节点上可以添加组件，将多个组件与节点关联在一起 简而言之，节点是我们组织工程结构的基本手段，我们可以通过节点将多个元素归类，并且可以对节点进行层级操作，或对一组节点进行批量操作，如：变换、删除，或是按需要隐藏和显示他们，等。 继续前往 相机 说明文档。 "},"concepts/scene/camera.html":{"url":"concepts/scene/camera.html","title":"相机","keywords":"","body":"相机 游戏中的相机是用来捕捉场景画面的主要工具。我们通过调节相机相关参数来控制可视范围的大小，在 Cocos Creator 3D 编辑器中相机呈如下表示： 相机的可视范围是通过6的平面组成一个 视锥体（Frustum） 构成， 近裁剪面（Near Plane） 和 远裁剪面（Far Plane） 用于控制近处和远处的可视距离与范围，同时它们也构成了视口的大小。 继续前往 光源 说明文档。 "},"concepts/scene/light.html":{"url":"concepts/scene/light.html","title":"光源","keywords":"","body":"光源 光源在游戏中表示具备发光能力的物体，并且能够照亮周围的环境 基于物理的光照（Physically Based Lighting） Cocos Creator 3D 中采用光学度量单位来描述光源参数。基于光学度量单位，我们可以将光源的相关参数全部转化为真实世界中的物理值。这样，设计人员可根据相关灯光的工业参数以及真实环境的实际物理参数来调节光照强度、颜色、范围等信息，使整体光照效果更加符合真实的自然环境。 详细介绍可参考下面链接： 基于物理的光照（Physically Based Lighting） Cocos Creator 3D 中支持三种类型的光源： 主方向光（Main Directional Light） 球面光（Sphere Light） 聚光灯（Spot Light） 继续前往 基于物理的光照 说明文档。 "},"concepts/scene/light/pbr-lighting.html":{"url":"concepts/scene/light/pbr-lighting.html","title":"基于物理的光照","keywords":"","body":"基于物理的光照（Physically Based Lighting） 真实世界中的光源 基于物理的光照符合真实世界中的光源描述，在真实环境中，我们所见到的光源产品都具有自身的工业参数，我们先来看一个宜家的灯泡💡 从产品包装上，我们可以了解到这个灯泡的几个重要工业参数： 功率 色温 尺寸 这三个重要参数影响真实世界中的光源表现效果，下面我们来重点讲解一下这三个参数的物理意义。 发光功率 发光功率就是我们通常所说的光源强度。Cocos Creator 3D 中使用 光学度量单位（Photometric Unit） 来计量光源强度： 发光功率（Luminous Power） ：单位 流明（lm） 描述光源从各个方向发出的光的总量。改变光源大小不会影响场景照明效果 亮度（Luminance） ：单位 坎德拉每平方米（cd/m2） 描述光线从光源表面上的点入射到接收表面上点，所具有的光源强度。改变光源大小会影响场景照明效果 照度（Illuminance） ：单位 勒克斯（lx） 描述光线从光源入射到接收表面处的光的总量。该值受光的传播距离影响。 在真实世界中，由于描述光源的重要物理参数不一样，我们通常用 发光功率（Luminous Power） 和 亮度（Luminance） 来描述生活中常见的带有照明面积的光源，用 照度（Illuminance） 来描述太阳光。 色温（ColorTemperature） 色温：是指绝对黑体从绝对零度(-273℃)开始加温后所呈现的颜色。 色温是影响光源颜色的重要属性，是个可选属性，当启用色温时，色温也参与了光源颜色的组成部分。 真实世界环境中，一天不同时段的环境色温也会动态发生变化： 可参考下表所示： 光源大小 真实世界中的光源都具有真实的物理尺寸，同时，光源大小也影响了光源强度。 继续前往 主方向光 说明文档。 "},"concepts/scene/light/dir-light.html":{"url":"concepts/scene/light/dir-light.html","title":"主方向光","keywords":"","body":"主方向光（Main Directional Light） Cocos Creator 3D 中只有一个主方向光，主方向光可以理解为场景中的主导性光源，通常是室外场景的太阳光。主方向光还会影响阴影的投影。 参数名称 说明 Color 光源颜色 UseColorTemperature 是否启用色温 ColorTemperature 色温 Illumiance 照度，单位勒克斯（lx） 继续前往 球面光 说明文档。 "},"concepts/scene/light/sphere-light.html":{"url":"concepts/scene/light/sphere-light.html","title":"球面光","keywords":"","body":"球面光（Sphere Light） Cocos Creator 3D 中使用球面光替代 点光源（Point Light），因为真实世界中的物理光源都具有光源大小属性。 参数名称 说明 Color 光源颜色 UseColorTemperature 是否启用色温 ColorTemperature 色温 Size 光源大小 Range 光照影响范围 Term 选用的光照强度单位术语球面光支持两种单位制系统：发光功率（LUMINOUS_POWER） 和 亮度（LUMINANCE） LuminousPower 发光功率，单位流明（lm）当 Term 指定为 LUMINOUS_POWER 时，选用流明来表示光照强度 Luminance 亮度，单位坎德拉每平方米（cd/m2）当 Term 指定为 LUMININANCE 时，选用亮度来表示光照强度 继续前往 聚光灯 说明文档。 "},"concepts/scene/light/spot-light.html":{"url":"concepts/scene/light/spot-light.html","title":"聚光灯","keywords":"","body":"聚光灯（Spot Light） 聚光灯 用于表现光束的聚焦，可以通过调节聚光角度可以控制光斑的大小。 参数名称 说明 Color 光源颜色 UseColorTemperature 是否启用色温 ColorTemperature 色温 Size 光源大小 Range 光照影响范围 SpotAngle 聚光角度 Term 选用的光照强度单位术语聚光灯支持两种单位制系统：发光功率（LUMINOUS_POWER） 和 亮度（LUMINANCE） LuminousPower 发光功率，单位流明（lm）。当 Term 指定为 LUMINOUS_POWER 时，选用流明来表示光照强度 Luminance 亮度，单位坎德拉每平方米（cd/m2）。当 Term 指定为 LUMININANCE 时，选用亮度来表示光照强度 继续前往 阴影 说明文档。 "},"concepts/scene/shadow.html":{"url":"concepts/scene/shadow.html","title":"阴影","keywords":"","body":"阴影 在 3D 世界中，光与影一直都是极其重要的组成部分，它们能够丰富整个环境，质量好的阴影可以达到以假乱真的效果，并且使得整个世界具有立体感。 以下为 Cocos Creator 3D 的阴影示例： 开启阴影 Cococs Creator 3D 目前支持高性价比的 Planar Shadow ，后面会提供更多 Shadow 类型，请留意更新公告。 在 Cococs Creator 3D 中开启 Planar Shadow 只需要两步： 在层级管理器上选择 Scene 节点，可以看到以下面板，将 planarShadows 的 Enabled 属性勾选上。 将需要显示阴影的模型组件中的 ShadowCastingMode 设置为 ON 。 注：Planar Shadow 只会投射在阴影面上，调节方向光角度可以调节阴影的投射。 PlanarShadows 面板 以下介绍了面板的所有属性： 属性 解释 enabled 是否开启 planar shadows normal 垂直与阴影平面的法线 distance 阴影平面在 normal 法线的方向上与坐标原点的距离 shadowColor 产生的阴影的颜色值 继续前往 环境光 说明文档。 "},"concepts/scene/ambient.html":{"url":"concepts/scene/ambient.html","title":"环境光","keywords":"","body":"环境光 在生活中，错综复杂的光线与凹凸不平的物体表面相互反射，使得整个环境都被照亮，仿佛整个场景被一层环境光所笼罩。通过调节环境光，是调节环境整体光照最为直接的方式，也是一种有效表达环境气氛的方式。 Cocos Creator 3D 中的环境光，如下图所示： 环境光面板 以下介绍了面板的所有属性： 属性 解释 groundAlbedo 地面反射光 skyColor 天空颜色 skyIllum 天空亮度 继续前往 天空盒 说明文档。 "},"concepts/scene/skybox.html":{"url":"concepts/scene/skybox.html","title":"天空盒","keywords":"","body":"天空盒 游戏中的天空盒是一个包裹整个场景的立方体，天空盒可以很好的渲染整个环境的气氛，并表达整个场景的环境，在基于 PBR 的工作流中天空盒也是非常重要的部分。 Cocos Creator 3D 中的天空盒，如下图所示： 开启天空盒 在 Cocos Creator 3D 中开启天空盒的效果，只需要以下一步： Skybox 的面板处于 Scene 节点的属性面板上，将 Enabled 属性勾选上便开启了天空盒 注： Skybox 的 Envmap 属性为空时，使用和显示的将是像素贴图。 修改天空盒的环境贴图 在 Cocos Creator 3D 中修改天空盒的环境贴图，是通过设置 TextureCube 类型的资源。 而从资源导入到设置为 TextureCube ，并且设置到 Skybox 中，可以分为以下几步： 导入图片资源。（注：此处以全景图为示例，下面有制作 CubeMap 的介绍方法。） 选中导入的全景图，在右侧的属性面板上，将其设置为 TextureCube 类型，如下图所示。 将以上 TextureCube 资源拖入到 Skybox 面板上的 Envmap 属性上。 完成以上步骤后，就可以在场景中看到最新替换的环境图。 Skybox 面板 以下介绍了面板的所有属性： 属性 解释 enabled 是否开启 Skybox envmap 环境贴图，类型为 TextureCube isRGBE 环境贴图的像素格式是否为 RGBE useIBL 是否使用环境光照 CubeMap CubeMap （立方体贴图）是天空盒的一种环境贴图资源，它由立方体上六个面的贴图资源组合而成，它可以当作 TextureCube 资源来使用。 制作与应用 CubeMap 在 Cocos Creator 3D 中制作一张 CubeMap 并且设置到 Skybox 中，只需要以下步骤： 新建 CubeMap 资源，并且导入预先准备好的六张贴图资源，并将这些贴图资源设置为 Texture 类型。 将导入的贴图资源拖入到相应的输入框中，完成后点击绿色勾选按钮，这样就完成了一张 CubeMap。 最后，将完成的 CubeMap 资源拖入到 Skybox 的 Envmap 属性框中，这样就完成了 CubeMap 的应用。 注： CubeMap 中未设置贴图的面将用默认的资源进行填充。 "},"material-system/overview.html":{"url":"material-system/overview.html","title":"材质","keywords":"","body":"材质系统总览 材质系统控制着每个模型最终的着色流程与顺序, 在引擎内相关类间结构如下: EffectAsset EffectAsset 是由用户书写的着色流程描述文件, 详细结构及书写指南可以参考这里. 这里主要介绍引擎读取 EffectAsset 资源的流程: 在编辑器导入 EffectAsset 时, 会对用户书写的内容做一次预处理, 替换 GL 字符串为管线内常量, 提取 shader 信息, 转换 shader 版本等. 还以 builtin-skybox.effect 为例, 预处理输出的 EffectAsset 结构大致是这样的: { \"name\": \"builtin-skybox\", \"techniques\": [ {\"passes\":[{\"rasterizerState\":{\"cullMode\":0}, \"program\":\"builtin-skybox|sky-vs:vert|sky-fs:frag\", \"priority\":245, \"depthStencilState\":{\"depthTest\":true, \"depthWrite\":false}, \"properties\":{\"cubeMap\":{\"value\":\"default-cube\", \"type\":31}}}]} ], \"shaders\": [ { \"name\": \"builtin-skybox|sky-vs:vert|sky-fs:frag\", \"hash\": 4212366729, \"glsl3\": { \"vert\": \"// glsl 300 es vert source, omitted here for brevity\", \"frag\": \"// glsl 300 es frag source, omitted here for brevity\" }, \"glsl1\": { \"vert\": \"// glsl 100 vert source, omitted here for brevity\", \"frag\": \"// glsl 100 frag source, omitted here for brevity\" }, \"builtins\": {\"globals\":{\"blocks\":[\"CCGlobal\"], \"samplers\":[]}, \"locals\":{\"blocks\":[], \"samplers\":[]}}, \"defines\": [ {\"name\":\"CC_USE_HDR\", \"type\":\"boolean\", \"defines\":[]}, {\"name\":\"USE_RGBE_CUBEMAP\", \"type\":\"boolean\", \"defines\":[]} ], \"blocks\": [], \"samplers\": [ {\"name\":\"cubeMap\", \"type\":31, \"count\":1, \"defines\":[], \"binding\":0} ], \"dependencies\": {} } ] }, 接着这个生成的 EffectAsset 正常参与标准(反)序列化流程. 另外在反序列化时, 其中包含的 shaders 会被直接注册到 ProgramLib, 供运行时使用. Material Material 资源可以看成是 EffectAsset 在场景中的资源实例, 它本身的可配置参数有: effectAsset 或 effectName: effect 资源引用, 使用哪个 EffectAsset 所描述的流程进行渲染? (必备) technique: 使用 EffectAsset 中的第几个 technique? (默认为 0 号) defines: 宏定义列表, 需要开启哪些宏定义? (默认全部关闭) states: 管线状态重载列表, 对渲染管线状态 (深度模板透明混合等) 有哪些重载? (默认与 effect 声明一致) const mat = new cc.Material(); mat.initialize({ effectName: 'builtin-skybox', defines: { USE_RGBE_CUBEMAP: true } }); 有了这些信息后, Material 就可以被正确初始化(标志是生成渲染使用的 Pass 对象数组), 用于具体模型的渲染了. 根据所使用 EffectAsset 的信息, 可以进一步设置每个 Pass 的 uniform 参数等. mat.setProperty('cubeMap', someCubeMap); console.log(mat.getProperty('cubeMap') === someCubeMap); // true 这些属性都是在材质资源对象本身内部生效, 还并不涉及场景. Material 通过挂载到 RenderableComponent 上与场景连接, 所有需要设定材质的 Component (ModelComponent, SkinningModelComponent等) 都继承自它. const comp = someNode.getComponent(cc.ModelComponent); comp.material = mat; comp.setMaterial(mat, 0); // 与上一行作用相同 根据子模型的数量, RenderableComponent 也可以引用多个 Material 资源: comp.setMaterial(mat, 1); // 赋给第二个 submodel 同一个 Material 也可挂载到任意多个 RenderableComponent 上, 一般在编辑器中通过拖拽的方式即可自动赋值. 而当场景中的某个模型的 Material 需要特化的设置, 会在从 RenderableComponent 获取 Material 时自动做拷贝实例化, 从而实现独立的定制. const comp2 = someNode2.getComponent(cc.ModelComponent); const mat2 = comp2.material; // 拷贝实例化, 接下来对 `mat2` 的修改只会影响 `comp2` 的模型 对于一个已初始化的材质, 如果希望修改最初的基本信息, 可以直接再次调用 initialize 函数, 重新创建渲染资源. mat2.initialize({ effectName: 'builtin-standard', technique: 1 }); 特别地, 如果只是希望修改 defines 或 states, 我们提供更高效的直接设置接口, 只需提供相对当前值的重载即可: mat.recompileShaders({ USE_RGBE_CUBEMAP: false }); mat.overridePipelineStates({ rasterizerState: { cullMode: cc.GFXCullMode.NONE } }); 每帧动态更新 uniform 值是非常常见的需求, 在类似这种需要更高效接口的情景下, 可以手动调用对应 pass 的接口: // 初始化时保存以下变量 const pass = mat2.passes[0]; const hColor = pass.getHandle('albedo'); const color = cc.color('#dadada'); // 每帧更新时： color.a = Math.sin(cc.director.getTotalFrames() * 0.01) * 127 + 127; pass.setUniform(hColor, color); Builtins 编辑器内置了几种常见类型的材质，无光照的 unlit、基于物理光照的 standard、skybox、粒子、sprite 等； 这里列一下最常用的 standard 各项参数的意义和用法： Property Info tilingOffset 模型 UV 的平铺和偏移量，xy 对应平铺，zw 对应偏移 albedo 漫反射颜色，指定模型的主要基色 albedoMap 漫反射贴图，如果有指定，这项会和漫反射颜色相乘 albedoScale xyz 对应模型的漫反射权重，用于控制漫反射颜色对于最终颜色的影响权重；w 通道为 alpha test 的测试阈值 normalMap 法线贴图，用于增加表面细节 pbrParams PBR 材质参数常量：粗糙度、金属度和 AO；每种属性具体对应的通道由 XX_CHANNEL 宏定义决定 pbrMap PBR 材质参数贴图：粗糙度、金属度和 AO；如果有指定，这项会替代材质参数常量；每种属性具体对应的通道由 XX_CHANNEL 宏定义决定 pbrScale PBR 材质参数的权重：粗糙度、金属度和 AO；每个分量具体对应的通道由 XX_CHANNEL 宏定义决定；但 w 通道固定为 normal map 的强度 emissive 自发光颜色，不参与光照计算模型直接发散出的颜色 emissiveMap 自发光贴图，如果有指定，这项会和自发光颜色相乘，因此需要把自发光颜色（默认是黑色）调高才会有效果 emissiveScale 自发光权重，用于控制自发光颜色的强度 相对应的，还有控制这些参数的宏定义： Macro Info ROUGHNESS_CHANNEL 指定粗糙度的数据来源通道，默认为 r 通道 METALLIC_CHANNEL 指定金属度的数据来源通道，默认为 g 通道 AO_CHANNEL 指定 AO 的数据来源通道，默认为 b 通道 USE_ALPHA_TEST 是否开启透明测试（镂空效果）？将通过比较漫反射颜色与漫反射权重的 a 通道，决定模型的哪部分将不会被绘制 USE_ALBEDO_MAP 是否使用漫反射贴图？ USE_NORMAL_MAP 是否使用法线贴图？ USE_PBR_MAP 是否使用 PBR 材质参数贴图？ USE_EMISSIVE_MAP 是否使用自发光贴图？ "},"material-system/yaml-101.html":{"url":"material-system/yaml-101.html","title":"YAML 101","keywords":"","body":"YAML 101 我们使用的是符合 YAML 1.2 标准的解析器，这意味着首先它是与 JSON 完全兼容的，直接书写 JSON 完全不会有问题： \"techniques\": [{ \"passes\": [{ \"vert\": \"skybox-vs\", \"frag\": \"skybox-fs\", \"rasterizerState\": { \"cullMode\": \"none\" } # ... }] }] 当然这也意味着繁琐的语法，所以 YAML 提供了一些更简洁的数据表示方式： （如有疑问可复制代码示例到任何 在线 YAML JSON 转换器 观察生成的数据） 所有的引号和逗号都可以省略 key1: 1 key2: unquoted string 行首的空格缩进数量代表数据的层级1 object1: key1: false object2: key2: 3.14 key3: 0xdeadbeef nestedObject: key4: 'quoted string' 以 连字符+空格 开头，表示数组元素 - 42 - \"double-quoted string\" - arrayElement3: key1: punctuations? sure. key2: you can even have {}s as long as they are not the first character key3: { nested1: 'but no unquoted string allowed inside brackets', nested2: 'also notice the comma is back too' } 综合这几点，上面的 effect 内容就可以很简洁地写成这样： techniques: - passes: - vert: skybox-vs frag: skybox-fs rasterizerState: cullMode: none # ... 另一个对我们的情况非常有用的 YAML 特性是数据间的引用与继承，先来看引用： object1: &o1 key1: value1 object2: key2: value2 key3: *o1 这个数据解析出来是这样的： { \"object1\": { \"key1\": \"value1\" }, \"object2\": { \"key2\": \"value2\", \"key3\": { \"key1\": \"value1\" } } } 再来看继承： object1: &o1 key1: value1 key2: value2 object2: 这个数据解析出来是这样的： { \"object1\": { \"key1\": \"value1\", \"key2\": \"value2\" }, \"object2\": { \"key1\": \"value1\", \"key2\": \"value2\", \"key3\": \"value3\" } } 对应到我们的 effect 中，比如多个 pass 拥有相同的 property 内容，或很多其他情景下，都可以很方便地复用数据： techniques: - passes: - # pass 1 specifications... properties: &props # declare once... p1: { value: [ 1, 1, 1, 1 ] } p2: { sampler: { mipFilter: linear } } p3: { inspector: { type: color } } - # pass 2 specifications... properties: *props # reference anywhere 最后，在实际 effect 文件中任何流程声明都需要包在 CCEffect 语法块内： CCEffect %{ # YAML starts here }% 更多参考资料 https://en.wikipedia.org/wiki/YAML https://yaml.org/spec/1.2/spec.html [1] 标准 YAML 并不支持制表符，但在解析 effect 数据时，我们会先尝试把其中所有的制表符替换为 2 个空格，以避免偶然插入制表符带来的琐碎的麻烦。但整体上，请一定尽量避免插入制表符来确保编译无误。↩ "},"material-system/effect-syntax.html":{"url":"material-system/effect-syntax.html","title":"Effect","keywords":"","body":"Effect 语法 如果希望在引擎中实现自定义的着色效果, 需要书写自定义 Effect. 一个 Effect 文件大体可以分为两部分的内容, 一份 YAML 格式的流程控制清单, 和相关的 (类)GLSL 语法的 shader 片段. 这两部分内容上相互补充, 共同构成了一个完整的渲染流程描述. 语法框架 以 builtin-skybox.effect 为例, 这个 Effect 文件的内容大致是这样: 关于 YAML YAML 是一门面向数据序列化的，对人类书写十分友好的语言，但它引入了一些独特的语法来表示不同类型的数据， 对于不熟悉这门语言的开发者可能会有一点门槛，我们在 这里 快速总结了一下最常用的一些语法和语言特性，有需要可以参考。 Pass 中可配置的参数 vert 和 frag 声明了当前 pass 使用的 shader, 格式为 片段名:入口函数名 这个名字可以是本文件中声明的 shader 片段名, 也可以是引擎提供的标准头文件. 片段中不应出现 main 函数入口, 资源导入阶段会将指定入口函数的返回值赋值给当前 shader 的输出 (gl_Position 或最终的输出颜色). 其他可配置 GL 参数及默认值见 完整列表. Shader 片段 Shader 片段在语法上是标准 GLSL 300 es 语法的一个超集, 在资源加载时有相应的编译流程. 这一节会介绍所有的扩展语法, 更多实际使用示例, 可参考编辑器内提供的 builtin effect. 在标准 GLSL 语法上, 我们引入了一些非常自然的 C 风格语法扩展: Include 机制 类似 C 的头文件 include 机制, 可供引用的内置头文件都在 chunks 目录下, 主要包括一些常用的工具函数, 和标准光照模型等. 另外所有在当前 effect 文件中声明的 shader 片段都可相互引用. 预处理宏定义 Effect 系统的设计倾向于在游戏项目运行时可以方便地利用 shader 中的各类预处理宏, 而减少 runtime branching. 编辑器会在加载资源时收集所有在 shader 中出现的 defines, 然后引擎在运行时动态地将需要的声明加入 shader 内容. 所以要使用这些预处理宏, 只需要如上面的例子中一样, 在 shader 中直接进行逻辑判断即可. 所有的 define 都会被序列化到 inspector 上, 供用户调整. 注意相关写法的一些限制: 如果在 shader 中声明了 extension, 这个 extension 必须有且只有一个 define 来控制启用与否. 目前运行时会显式定义所有 shader 中出现的宏，所以请不要使用 #ifdef 或 #if defined() 这样的形式做判断. Macro Tags 虽然我们会尝试自动识别所有出现在预处理分支逻辑中 (#if) 的宏定义，但有时实际使用方式要比简单的布尔开关更复杂一些，如： // macro defined within certain numerical 'range' #if LAYERS == 4 // ... #elif LAYERS == 5 // ... #endif // multiple discrete 'options' float metallic = texture(pbrMap, uv).METALLIC_SOURCE; 针对这类有固定取值范围，或固定选项的宏定义，需要选择一个合适的 tag 显式声明： Tag Tag 参数 默认值 说明 range 一个长度为 2 的数组，首元素为最小值，末元素为最大值 [0, 3] 针对连续数字类型的宏定义，显式指定它的取值范围，范围应当控制到最小，有利于运行时的 shader 管理 options 一个任意长度的数组，每个元素都是一个可能的取值 如未显示声明则不会定义任何宏 针对有清晰选项的宏定义，显式指定它的可用选项 比如下面这样的声明： #pragma define LAYERS range([4, 5]) #pragma define METALLIC_SOURCE options([r, g, b, a]) 一个是名为 LAYERS 的宏定义，它在运行时可能的取值范围为 [4, 5]； 另一个是名为 METALLIC_SOURCE 的宏定义，它在运行时可能的取值为 'r', 'g', 'b', 'a' 四种。 注意语法中每个 tag 只有一个参数，这个参数可以直接用 YAML 语法去指定。 Functional Macros 由于 WebGL1 不原生支持，我们将函数式预处理宏提供为资源导入期的功能： #define DECL_CURVE_STRUCT(name) \\ uniform int u_##name##_curveMode; #define DECL_CURVE_STRUCT_INT(name) \\ DECL_CURVE_STRUCT(name) \\ uniform float u_##name##_minIntegral[MAX_KEY_NUM - 1]; DECL_CURVE_STRUCT_INT(velocity_pos_x) 对这样的声明，最后一行会在资源导入期就被展开变成: uniform int u_velocity_pos_x_curveMode; uniform float u_velocity_pos_x_minIntegral[MAX_KEY_NUM - 1]; Vertex Input1 为对接骨骼动画与数据解压流程，我们提供了 CCVertInput 工具函数，对所有 3D 模型使用的 shader，可直接在 vs 开始时类似这样写： #include vec4 vert () { vec3 position; CCVertInput(position); // ... do your thing with `position` (models space, after skinning) } 如果还需需要法线等信息，可直接使用 standard 版本： #include vec4 vert () { StandardVertInput In; CCVertInput(In); // ... now use `In.position`, etc. } 这会返回模型空间的顶点位置（position）、法线（normal）和切空间（tangent）信息，并对骨骼动画模型做完蒙皮计算。 注意引用头文件后，不要在 shader 内重复声明这些 attributes（a_position 等）。 对于其他顶点数据（如 uv 等）还是正常声明 attributes 直接使用。 Fragment Ouput1 为对接引擎渲染管线，我们提供了 CCFragOutput 工具函数，对所有无光照 shader，可直接在 fs 返回时类似这样写： #include vec4 frag () { vec4 o = vec4(0.0); // ... do the computation return CCFragOutput(o); } 这样中间的颜色计算就不必区分当前渲染管线是否为 HDR 流程等。 如需要包含光照计算，可结合标准着色函数 CCStandardShading 一起构成 surface shader 流程： #include #include void surf (out StandardSurface s) { // fill in your data here } vec4 frag () { StandardSurface s; surf(s); vec4 color = CCStandardShading(s); return CCFragOutput(color); } 在此框架下可方便地实现自己的 surface 输入，或其他 shading 算法； 注意 CCFragOutput 函数一般还是不需要自己实现，它只起与渲染管线对接的作用，且对于这种含有光照计算的输出，因计算结果已经在线性空间，应包含 output-standard 而非 output 头文件。 WebGL 1 fallback 支持 由于 WebGL 1 仅支持 GLSL 100 标准语法, 在资源导入阶段会提供 300 es 转 100 的 fallback shader, 用户基本不需关心这层变化。 但注意目前的 fallback 只支持一些基本的格式转换，如果使用了 300 es 独有的 shader 函数（texelFetch、textureGrad 等）或 extension，我们推荐根据 __VERSION__ 宏定义判断 shader 版本，自行实现更稳定的 fallback。 关于 UBO 内存布局 首先结论是，我们规定在 shader 中所有非 sampler 的 uniform 都应以 block 形式声明，且对于所有 UBO： 不应出现 vec3 成员； 对数组类型成员，每个元素 size 不能小于 vec4； 不允许任何会引入 padding 的成员声明顺序。 这些规则都会在资源导入期做对应检查，以导入错误（implicit padding 相关）的形式提醒修改。 这可能听起来有些过分严格，但背后有非常务实的考量： 首先，UBO 是渲染管线内要做到高效数据复用的唯一基本单位，离散声明已不是一个选项； 其次，WebGL2 的 UBO 只支持 std140 布局，它遵守一套比较原始的 padding 规则： 所有 vec3 成员都会补齐至 vec4：uniform ControversialType { vec3 v3_1; // offset 0, length 16 [IMPLICIT PADDING!] }; // total of 16 bytes 任意长度小于 vec4 类型的数组和结构体，都会逐元素补齐至 vec4：uniform ProblematicArrays { float f4_1[4]; // offset 0, stride 16, length 64 [IMPLICIT PADDING!] }; // total of 64 bytes 所有成员在 UBO 内的实际偏移都会按自身所占字节数对齐（更详细的规则可以直接参考2）：uniform IncorrectUBOOrder { float f1_1; // offset 0, length 4 (aligned to 4 bytes) vec2 v2; // offset 8, length 8 (aligned to 8 bytes) [IMPLICIT PADDING!] float f1_2; // offset 16, length 4 (aligned to 4 bytes) }; // total of 20 bytes uniform CorrectUBOOrder { float f1_1; // offset 0, length 4 (aligned to 4 bytes) float f1_2; // offset 4, length 4 (aligned to 4 bytes) vec2 v2; // offset 8, length 8 (aligned to 8 bytes) }; // total of 16 bytes 这意味着大量的空间浪费，且某些设备的驱动实现也并不完全符合此标准3，因此我们目前选择限制这部分功能的使用，以帮助排除一部分非常隐晦的运行时问题。 [1] 不包含粒子、sprite、管线内后处理等不基于 mesh 执行渲染的 shader ↩ [2] OpenGL 4.5, Section 7.6.2.2, page 137 ↩ [3] Interface Block - OpenGL Wiki#Memory_layout) ↩ "},"material-system/pass-parameter-list.html":{"url":"material-system/pass-parameter-list.html","title":"Pass","keywords":"","body":"Pass 可配置参数 默认值为加粗项，并可在Effect文件中直接省略。 所有参数不区分大小写。 Name Options switch *undefined, could be any valid macro name that's not defined in the shader priority default(128), could be any number between max(255) and min(0) stage default, could be the name of any registered stage in your runtime pipeline customization [], could be the name of any registered runtime customization property *see the following section primitive point_list, line_list, line_strip, line_loop,triangle_list, triangle_strip, triangle_fan,line_list_adjacency, line_strip_adjacency,triangle_list_adjacency, triangle_strip_adjacency,triangle_patch_adjacency, quad_patch_list, iso_line_list dynamics [], an array containing any of the following:viewport, scissor, line_width, depth_bias, blend_constants,depth_bounds, stencil_write_mask, stencil_compare_mask rasterizerState.cullMode front, back, none depthStencilState.depthTest true, false depthStencilState.depthWrite true, false depthStencilState.depthFunc never, less, equal, less_equal, greater, not_equal, greater_equal, always blendState.targets[i].blend true, false blendState.targets[i].blendEq add, sub, rev_sub blendState.targets[i].blendSrc one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendDst one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendSrcAlpha one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendDstAlpha one, zero, src_alpha_saturate,src_alpha, one_minus_src_alpha,dst_alpha, one_minus_dst_alpha,src_color, one_minus_src_color,dst_color, one_minus_dst_color,constant_color, one_minus_constant_color,constant_alpha, one_minus_constant_alpha blendState.targets[i].blendAlphaEq add, sub, rev_sub blendState.targets[i].blendColorMask all, none, r, g, b, a, rg, rb, ra, gb, ga, ba, rgb, rga, rba, gba blendState.blendColor 0 or [0, 0, 0, 0] depthStencilState.stencilTestFront true, false depthStencilState.stencilFuncFront never, less, equal, less_equal, greater, not_equal, greater_equal, always depthStencilState.stencilReadMaskFront 0xffffffff or [1, 1, 1, 1] depthStencilState.stencilWriteMaskFront 0xffffffff or [1, 1, 1, 1] depthStencilState.stencilFailOpFront keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilZFailOpFront keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilPassOpFront keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilRefFront 1 or [0, 0, 0, 1] depthStencilState.stencilTestBack true, false depthStencilState.stencilFuncBack never, less, equal, less_equal, greater, not_equal, greater_equal, always depthStencilState.stencilReadMaskBack 0xffffffff or [1, 1, 1, 1] depthStencilState.stencilWriteMaskBack 0xffffffff or [1, 1, 1, 1] depthStencilState.stencilFailOpBack keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilZFailOpBack keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilPassOpBack keep, zero, replace, incr, incr_wrap, decr, decr_wrap, invert depthStencilState.stencilRefBack 1 or [0, 0, 0, 1] depthStencilState.stencilReadMask *convenient setter for both front/back stencil read mask,always use this for web platforms depthStencilState.stencilWriteMask *convenient setter for both front/back stencil write mask,always use this for web platforms depthStencilState.stencilRef *convenient setter for both front/back stencil ref,always use this for web platforms Switch 指定这个 pass 的执行依赖于哪个 define，它不应与使用到的 shader 中定义的任何 define 重名。 这个字段默认是不存在的，意味着这个 pass 是无条件执行的。 Priority 指定这个 pass 的渲染优先级，数值越小越优先渲染；default 代表默认优先级 (128)，min 代表最小（0），max 代表最大（255），可结合四则运算符指定相对值。 Stage 指定这个 pass 归属于管线的哪个 stage，对 forward 管线，只有 default 一个 stage。 Customization 指定当这个 pass 被应用到场景模型上后执行的自定义回调函数，用于实现显示相关的特殊逻辑需求，可在脚本中通过 cc.customizationManager.register 注册。 Property properties 存储着这个 Pass 哪些 uniform 需要在 Inspector 上显示, 未指定的 uniform 将由引擎在运行时根据自动分析出的数据类型给予默认初值。 同样地，任何字段如为默认值也都可以省掉。 effect 资源导入器会自动从 shader 中读取 uniform 的类型等相关信息。 另外，各 uniform 会根据 inspector 属性调整在编辑器内的显示，如使用 color picker，或设置 tooltip 等，具体见 可配置列表。 为方便声明各 property 子属性，可以直接在 properties 内声明 __metadata__ 项，所有 property 都会继承它声明的内容，如： properties: __metadata__: { inspector: { visible: false } } a: { value: [1, 1, 0, 0] } b: { inspector: { type: color } } c: { inspector: { visible: true } } 这样 uniform a 和 b 已声明的各项参数都不受影响，但全部不会显示在 inspector 上（visible 为 false），而 uniform c 还会正常显示。 Property Param List Param Options type float, vec2, vec3, vec4, sampler2D, samplerCube, *extracted from shader value *see the following section sampler.minFilter none, point, linear, anisotropic sampler.magFilter none, point, linear, anisotropic sampler.mipFilter none, point, linear, anisotropic sampler.addressU wrap, mirror, clamp, border sampler.addressV wrap, mirror, clamp, border sampler.addressW wrap, mirror, clamp, border sampler.maxAnisotropy 16 sampler.cmpFunc never, less, equal, less_equal, greater, not_equal, greater_equal, always sampler.borderColor [0, 0, 0, 0] sampler.minLOD 0 sampler.maxLOD 0, *remember to override this when enabling mip filter sampler.mipLODBias 0 inspector.displayName (any string), *property name inspector.type vector, color inspector.visible true, false inspector.tooltip (any string), *property name Default Values Type Default Value / Options int 0 ivec2 [0, 0] ivec3 [0, 0, 0] ivec4 [0, 0, 0, 0] float 0 vec2 [0, 0] vec3 [0, 0, 0] vec4 [0, 0, 0, 0] sampler2D black, grey, white, normal, default samplerCube black-cube, white-cube, default-cube 对于 defines： boolean 类型默认值为 false。 number 类型默认值为 0，默认取值范围 [0, 3]。 string 类型默认值为 options 数组第一个元素。 "},"audio-system/overview.html":{"url":"audio-system/overview.html","title":"声音","keywords":"","body":"声音系统总览 声音系统的接口主要面向两类需求，一类是长度较长，循环持续播放的 “音乐”，一类是长度较短，一次性播放的 “音效”。 所有音频资源都会在编辑器内导入成 AudioClip 资源，要播放声音，首先需要在场景里创建 AudioSourceComponent。 对于音乐，可以直接将 AudioClip 赋给 AudioSourceComponent 上的 clip 属性，勾选 playOnAwake 属性或脚本调用组件的 play 方法来控制播放； 对于音效，可以在脚本里调用 AudioSourceComponent 的 playOneShot 方法，在调用时传入要播放的音效片段和音量。 注意虽然 AudioClip 资源本身也直接有 play 等接口实现，但 AudioSourceComponent 才是常规的播放入口，请尽量使用组件完成工作流。 音频相关事件 所有的 AudioClip 资源对象都是一个 EventTarget： 在音频开始实际播放时，会发出 started 事件； 在音频播放自然结束时，会发出 ended 事件； 平台差异性 目前支持 Web Audio API、DOM 音频、微信小游戏音频三种接口，虽然运行时各个平台的音频接口实现并不完全统一， 我们已经尽力在引擎中最小化这部分差异，但还是会存在一部分不可协调的不一致性： iOS 平台 DOM 音频模式不支持调整音量大小，所有 volume 相关属性将不会有效； 只有 Web Audio 模式支持同一音频的多重播放，其他模式下为避免重复创建，多次调用 playOneShot 的默认行为是从头开始重新播放； 目前大部分平台都已遵守最新的 auto play police，即使设置了 playOnAwake 也会在第一次接收到用户输入时才开始播放； "},"particle-system/overview.html":{"url":"particle-system/overview.html","title":"粒子","keywords":"","body":"Particle System Overview 粒子系统是游戏引擎特效表现的基础，它可以用于模拟的火、烟、水、云、雪、落叶等自然现象，也可用于模拟发光轨迹、速度线等抽象视觉效果。 基本结构 粒子系统的基本单元是粒子，一个粒子一般具有位置、大小、颜色、速度、加速度、生命周期等属性。在每一帧中，粒子系统一般会执行如下步骤： 产生新的粒子，并初始化 删除超过生命周期的粒子 更新粒子的动态属性 渲染所有有效的粒子 一般粒子系统会有如下几个部分组成： 发射器，用于创建粒子，并初始化粒子的属性 影响器，用于更新粒子的属性 渲染器，渲染粒子 粒子类，存储粒子的属性 粒子系统类，管理上面的模块 Cocos Creator 3D粒子系统以模块来组织功能，包含了以下模块： 模块 描述 ParticleSystemComponent 用于存储在Inspector中显示的所有数据，管理粒子生成、更新、销毁相关模块，控制粒子播放 ShapeModule 用于控制粒子发射，包括发射方向与速度，支持预定义的发射方向包括方块、圆、锥体、球、半球 AnimatorModule 用于控制粒子发射后状态更新。已支持的功能有：大小、颜色、旋转、速度、加速度、限速、贴图动画 ParticleSystemRenderer 用于生成粒子渲染所需要的数据。包括vb、ib、渲染状态相关的控制 添加一个粒子系统模块有两种方式： 像其他组件一样为节点添加粒子系统组件（不推荐） 使用编辑器添加粒子系统组件（推荐） 开发者可以通过右侧 Inspector 面板上点击“添加组件”添加粒子，如下图： 也可以通过左侧的层级管理器“右键->创建->特效->粒子系统”来添加一个粒子系统组件，如下图： "},"particle-system/module.html":{"url":"particle-system/module.html","title":"粒子系统模块","keywords":"","body":"粒子系统模块 ParticleSystemComponent存储了粒子发射的初始状态以及粒子发射后状态更新子模块。 主模块(ParticleSystemComponent)发射器模块(ShapeModule)颜色模块(ColorOvertimeModule)大小模块(SizeOvertimeModule)旋转模块(RotationOvertimeModule)速度模块(VelocityOvertimeModule)限速模块(LimitVelocityOvertimeModule)加速模块(ForceOvertimeModule)贴图动画模块(TextureAnimationModule)渲染模块(Renderer)拖尾模块(TrailModule) "},"particle-system/main-module.html":{"url":"particle-system/main-module.html","title":"主模块(ParticleSystemComponent)","keywords":"","body":"主模块(ParticleSystemComponent) 属性 功能 duration 粒子系统运行总时间 capacity 粒子系统能生成的最大粒子数量 loop 粒子系统是否循环播放 playOnAwake 粒子系统加载后是否自动开始播放 prewarm 选中之后，粒子系统会以已播放完一轮之后的状态开始播放（仅当循环播放启用时有效） simulationSpace 控制粒子坐标计算所在的坐标系 startDelay 粒子延迟发射的时间 startLifetime 粒子生命周期 startColor 粒子初始颜色 scaleSpace 粒子缩放的坐标空间，local基于本地空间的缩放，world基于世界空间的缩放 startSize 粒子初始大小 startSpeed 粒子初始速度 startRotation 粒子初始旋转角度 gravityModifier 重力系数 rateOverTime 每秒发射的粒子数 rateOverDistance 每移动单位距离发射的粒子数 bursts 在某个时间点发射给定数量的粒子 - time 粒子播放多长时候后开始发射burst - count 发射的粒子数量 - repeatCount burst触发次数 - repeatInterval 每次触发的时间间隔 "},"particle-system/emitter.html":{"url":"particle-system/emitter.html","title":"发射器模块(ShapeModule)","keywords":"","body":"发射器模块(ShapeModule) 公有属性： 属性 作用 position 相对于挂载节点的位置 rotation 相对于挂载节点的旋转 scale 相对于挂载节点的缩放 sphericalDirectionAmount 表示当前发射方向与当前位置到结点中心连线方向的插值 randomPositionAmount 表示与当前发射位置的偏移 方块(Box) 属性 作用 shapeType Box emitFrom 粒子从方块的哪个部位发射，edge:边框；shell:表面；volume:内部 球、半球(Shpere\\Hemisphere) 属性 作用 shapeType Shpere\\Hemisphere radius 球体半径 radiusThickness 0表示从球表面发射，1表示从球体内部发射，0~1之间表示从表面到球心之间发射 圆(Circle) 属性 作用 shapeType Circle radius 圆的半径 radiusThickness 0表示从圆周发射，1表示从圆内部发射，0~1之间表示从圆周到圆心之间发射 arc 表示在圆的一个扇形区域发射 mode 表示粒子在扇形区域的发射方式，random:随机位置，loop:沿某一方向循环发射，每次循环方向相同，pingPong:循环发射，每次循环方向相反 spread:表示粒子在某个间断发射，比如，0表示可以在任意位置发射，0.1表示每隔圆周的十分之一位置发射 speed 表示粒子沿圆周发射的速度 圆锥(Cone) 属性 作用 shapeType Cone angle 圆锥的轴与母线的夹角 radius 圆锥顶部截面半径 length 圆锥顶部截面距离底部的轴长 radiusThickness 0表示从圆周发射，1表示从圆内部发射，0~1之间表示从圆周到圆心之间发射 arc 表示在圆的一个扇形区域发射 mode 表示粒子在扇形区域的发射方式，random:随机位置，loop:沿某一方向循环发射，每次循环方向相同，pingPong:循环发射，每次循环方向相反 spread:表示粒子在某个间断发射，比如，0表示可以在任意位置发射，0.1表示每隔圆周的十分之一位置发射 speed 表示粒子沿圆周发射的速度 "},"particle-system/color-module.html":{"url":"particle-system/color-module.html","title":"颜色模块(ColorOvertimeModule)","keywords":"","body":"颜色模块(ColorOvertimeModule) 属性 作用 color 颜色随时间变化的参数，可采用不同的颜色变化模式 "},"particle-system/size-module.html":{"url":"particle-system/size-module.html","title":"大小模块(SizeOvertimeModule)","keywords":"","body":"大小模块(SizeOvertimeModule) 属性 作用 size 大小随时间变化的曲线，可采用不同计算模式，目前只支持三个方向共用缩放值。 "},"particle-system/rotation-module.html":{"url":"particle-system/rotation-module.html","title":"旋转模块(RotationOvertimeModule)","keywords":"","body":"旋转模块(RotationOvertimeModule) 属性 作用 Rotation 旋转随时间变化曲线，支持不同的计算模式，目前只z轴的旋转。 "},"particle-system/velocity-module.html":{"url":"particle-system/velocity-module.html","title":"速度模块(VelocityOvertimeModule)","keywords":"","body":"速度模块(VelocityOvertimeModule) 属性 作用 space 速度在哪个坐标系中计算。 x,y,z 三个方向上的速度分量，可使用不同的计算模式。 speedModifier 速度修正系数。 "},"particle-system/limit-velocity-module.html":{"url":"particle-system/limit-velocity-module.html","title":"限速模块(LimitVelocityOvertimeModule)","keywords":"","body":"限速模块(LimitVelocityOvertimeModule) 属性 作用 space 速度在哪个坐标系中计算。 limit 速度下限，当速度超出该值时，将当前速度与该速度做线性插值。 dampen 当前速度与速度下限的插值。 separateAxes 是否三个轴分开限制。 limit X,Y,Z 三个轴的速度下限。 "},"particle-system/force-module.html":{"url":"particle-system/force-module.html","title":"加速度模块(ForceOvertimeModule)","keywords":"","body":"加速度模块(ForceOvertimeModule) 属性 作用 space 加速度在哪个坐标系中计算。 x,y,z 三个方向上的加速度分量，可采用不同的计算模式。 "},"particle-system/texture-animation-module.html":{"url":"particle-system/texture-animation-module.html","title":"贴图动画模块(TextureAnimationModule)","keywords":"","body":"贴图动画模块(TextureAnimationModule) 属性 作用 mode grid一张贴图包含一个粒子播放的动画帧。 numTilesX x方向动画帧数。 numTilesY y方向动画帧数。 animation wholeSheet播放贴图中的所有帧，singleRow只播放其中一行。 frameOverTime 一个周期内动画播放的帧与时间变化曲线。 startFrame 从第几帧开始播放，时间为整个粒子系统的生命周期。 cycleCount 一个生命周期内播放几次循环。 "},"particle-system/renderer.html":{"url":"particle-system/renderer.html","title":"渲染模块(Renderer)","keywords":"","body":"Particle Renderer 粒子渲染部分由ParticleSystemRenderer控制，ParticleSystemRenderer通过一个对象池来维护所有粒子，根据粒子当前状态来生成对应的vb、ib数据，持有粒子需要渲染的材质，并且保存相关渲染状态。 属性 作用 renderMode 设置一个粒子面片的生成方式，billboard粒子始终面向摄像机，stretchedBillboard粒子始终面向摄像机,但会根据相关参数进行拉伸，horizontalBillboard粒子面片始终与xz平面平行,verticalBillboard粒子面片始终与Y轴平行，但会朝向摄像机，mesh粒子为一个模型。 velocityScale 在stretchedBillboard模式下,对粒子在运动方向上按速度大小进行拉伸。 lengthScale 在stretchedBillboard模式下,对粒子在运动方向上按粒子大小进行拉伸。 mesh 在renderMode为mesh时，指定要渲染的粒子的模型。 ParticleMaterial 用于粒子渲染的材质，材质使用的effect只能是builtin-particle，不支持其它的effect。 TrailMaterial 用于拖尾渲染的材质，材质的effect只支持builtin-particle-trail，不支持其它的effect。 "},"particle-system/trail-module.html":{"url":"particle-system/trail-module.html","title":"拖尾模块(TrailModule)","keywords":"","body":"拖尾模块（TrailModule） 属性 作用 mode Particle在每个粒子的运动轨迹上形成拖尾效果。 LifeTime 拖尾的生命周期。 MinParticleDistance 粒子每生成一个拖尾节点所运行的最短距离。 Space 拖尾所在的坐标系，World在世界坐标系中运行，Local在本地坐标系中运行。 ExistWithParticles 拖尾是否跟随粒子一起消失。 TextureMode 贴图在拖尾上的展开形式，Stretch贴图覆盖在整条拖尾上，Repeat贴图覆盖在一段拖尾上。 WidthFromParticle 拖尾宽度继承自粒子大小 WidthRatio 拖尾宽度，如果继承自粒子则是粒子大小的比例 ColorFromParticle 拖尾颜色是否继承自粒子 ColorOverTrail 拖尾颜色随拖尾自身长度的颜色渐变 ColorOvertime 拖尾颜色随时间的颜色渐变 "},"engine/animation/":{"url":"engine/animation/","title":"动画","keywords":"","body":"Cocos Creator 3D 内置了通用的动画系统用以实现基于关键帧的动画。 动画剪辑是包含了动画信息的资源。 动画剪辑是可以复用的，其状态保存在称为动画状态的对象中， 通过动画状态的接口我们可以对动画进行播放、暂停、停止、变速等控制。 动画组件统一管理动画剪辑和其状态， 允许用户在组件层面上实现动画功能。 在编辑器中我们可以很方便地产出动画剪辑资源， 例如通过动画编辑器，又或者某些外部资源中已经包含了动画剪辑资源。 在这种情况下，我们仅需要对这些动画剪辑进行组织，按我们的意愿进行播放控制。 动画组件章节介绍了如何使用动画组件和动画剪辑控制动画的播放： 动画组件 若需要深入了解动画剪辑的构成或程序化地创建动画剪辑时，可以参考： 动画剪辑 骨骼动画是一种常见但类型特殊的动画，相关详细说明参考： 骨骼动画 "},"engine/animation/animation-component.html":{"url":"engine/animation/animation-component.html","title":"动画组件","keywords":"","body":"动画组件 动画组件控制动画的播放。 像其他组件一样为结点添加动画组件： import { AnimationComponent, Node } from \"cc\"; function (node: Node) { const animationComponent = node.addComponent(AnimationComponent); } 动画组件管理了一组动画剪辑。 动画组件开始运作前，它为每一个动画剪辑都创建了相应的 动画状态 对象。 动画状态控制某个动画剪辑在结点的播放过程，一个动画剪辑可以同时为多个动画状态所用。 在动画组件中，动画状态是通过名称来标识的。 每个动画状态的默认名称就是其动画剪辑的名称。 动画的播放与切换 play() 使得动画组件开始播放指定的动画： animationComponent.play('idle'); // 播放动画状态 'idle' 在播放时，旧的动画将立即被停止，这种切换是非常突兀的。 在某些情况下，我们希望这种切换是“淡入淡出”的， 此时应当使用 crossFade() 方法。 crossFade() 会在指定的周期内平滑地完成切换： animationComponent.play('walk'); /* ... */ // 当需要切换到跑的动画时 animationComponent.crossFade('run', 0.3); // 在 0.3 秒内平滑地从走的动画切换为跑的动画 crossFade() 的这种淡入淡出机制使得同一时刻可能有不止一个动画状态在播放。 因此，动画组件没有当前动画的概念。 即便如此，动画组件仍提供了 pause()、resume()、stop() 方法， 它们暂停、继续以及停止正在播放的所有动画状态的同时， 也暂停、继续以及停止动画的切换。 动画状态 有时候你可能需要对动画状态进行其他操作，例如，设置其速度。 可以通过 getState() 获取动画状态： const animationComponent = node.getComponent(AnimationComponent); animationComponent.clips = [ idleClip, runClip ]; // 获取 `idleClip` 的状态 const idleState = animationComponent.getState(idleClip.name); 你可以设置动画播放的速度： animationComponent.getState('idle').speed = 2.0; // 以两倍速播放待机动画 动画状态也提供了 play()、pause()、resume()、stop() 这些播放控制功能。 当动画组件本身的播放控制功能不能满足你的要求时， 你也可以按照自己的方式操纵动画状态的播放。 默认动画 当动画组件的 playOnLoad 为 true 时， 动画组件将在第一次运行时自动播放默认动画剪辑 defaultClip。 帧事件 你可以为动画的每一时间点添加事件。 AnimationClip 的 events 包含了此动画所有的事件描述，每个事件描述都具有以下属性： { frame: number; func: string; params: any[]; } 其中 frame 表示事件触发的时间点，单位为秒， 例如 0.618 就表示当动画到达第 0.618 秒时将触发事件。 func 表示事件触发时回调的方法名称，事件触发时， 会在当前结点的所有组件上搜索名为 func 的方法，一旦找到，将 params 传递给它并调用。 以下代码演示了这一过程。 import { AnimationComponent, Component } from \"cc\"; class MyScript extends Component { constructor() { } public start() { const animationComponent = this.node.getComponent(AnimationComponent); if (animationComponent && animationComponent.defaultClip) { const { defaultClip } = animationComponent; defaultClip.events.push({ frame: 0.5, // 第 0.5 秒时触发事件 func: 'onTriggered', // 事件触发时调用的函数名称 params: [ 0 ], // 向 `func` 传递的参数 }); defaultClip.updateEventDatas(); } } public onTriggered(arg: number) { console.log(`I'm triggered!`); } } 以上代码表示，MyScript 组件所在结点的动画组件的默认动画剪辑 在进行到第 0.5 秒将调用 MyScript 组件的 test() 方法并传递参数 0。 "},"engine/animation/animation-clip.html":{"url":"engine/animation/animation-clip.html","title":"动画剪辑","keywords":"","body":"动画剪辑 动画剪辑是一组动画曲线，包含了所有动画数据。 动画曲线 动画曲线描述了某一对象上某一属性值随着时间的变化。 在内部，动画曲线存储了一系列时间点，每个时间点都对应着一个（曲线）值，称为一帧，或关键帧。 当动画系统运作时，动画组件根据当前动画状态计算出指定时间点应有的（结果）值并赋值给对象，完成属性变化；这一计算过程称为采样。 下图是一条示例曲线，它包含 6 个关键帧： drawCurve(document.getElementById(\"curve-example-canvas\"), 6, {xAxisText: \"帧时间（秒）\", yAxisText: \"曲线值\"}); 以下代码片段演示了如何程序化地创建动画剪辑。 import { AnimationClip, color, v3 } from \"cc\"; const animationClip = new AnimationClip(); animationClip.duration = 1.0; // 整个动画剪辑的周期。任何帧时间都不应该大于此属性。 const headCurveKeys = [ 0.3, 0.6, 0.9 ]; const headCurveValues = [ v3(0.0), v3(0.5), v3(0.0) ]; const bodyCurveKeys = [ 0.0, 0.2, 0.4, 0.6, 0.8, 1.0 ]; const bodyCurveValues = [ color(0), color(51), color(102), color(153), color(204), color(255) ]; animationClip.keys = [ headCurveKeys, bodyCurveKeys ]; // 该动画剪辑所有曲线共享的帧时间 animationClip.curveDatas = { \"/Head\": { \"position\": { // `Head` 子结点的 `position` 属性的曲线 keys: 0, // 引用的帧时间，它是 `Animation.keys` 的索引，对于此处来说，即引用 `headCurveKeys` values: headCurveValues, }, }, \"/Body\": { comps: { \"cc.Sprite\": { // `Body` 子结点上，`SpriteComponent` 组件的 `color` 属性的曲线 keys: 1, // 即 `bodyCruveKeys` values: bodyCurveValues, }, }, }, }; 以上创建的动画剪辑包含两条曲线： 一条曲线控制子结点 Head 的位置变化，包含 3 帧，使得 Head 的 x 坐标由 0 变化为 0.5 再变化为 0。 另一条曲线控制子结点 Body 上 SpriteComponent 组件的颜色变化，包含 6 帧， 使得 Body 上的 SpriteComponent 组件的颜色从黑逐渐变化为白。 注意，曲线的帧时间是以引用方式索引到 AnimationClip.keys 数组中的。 如此一来，多条曲线可以共享帧时间。这将带来额外的性能优化。 目标对象 动画曲线的目标可以是任意 Cocos Creator 3D 结点以及其上附加的组件。 曲线记录了目标结点的相对路径， 运行时，由动画组件根据此路径动态确定目标对象。 例如，若曲线的路径为 /Spline/Leg ，而动画剪辑的所在结点1为 Human， 则在运行时，曲线的目标结点为 Human 结点的 Spline 子结点的 Leg 子结点； 而当曲线的路径为 / 或空字符串时，曲线的目标结点即为 Human 结点本身。 动画曲线的这种动态绑定特性使得动画剪辑可以复用到多个对象上。 采样 若采样时间点恰好就等于某一关键帧的时间点，则使用该关键帧上的动画数据。 否则——当采样时间点居于两帧之间时，结果值应同时受两帧数据的影响， 采样时间点在两处关键帧的时刻区间上的比例（[0,1]）反应了影响的程度。 Cocos Creator 3D 允许将该比例映射为另一个比例，以实现不同的“渐变”效果。 这些映射方式，在 Cocos Creator 3D中称为渐变方式。 在比例确定之后，根据指定的插值方式计算出最终的结果值。 渐变方式和插值方式都影响着动画的平滑度。 渐变方式 可以为每一帧指定渐变方式，也可以为所有帧指定统一的渐变方式。 渐变方式可以是内置渐变方式的名称或贝塞尔控制点。 以下列出了几种常用的渐变方式。 linear 保持原有比例，即线性渐变；当未指定渐变方式时默认使用这种方式； constant 始终使用比例 0，即不进行渐变；与插值方式 Step 类似； quadIn 渐变由慢到快。 quadOut 渐变由快到慢。 quadInOut 渐变由慢到快再到慢。 quadOutIn 渐变由快到慢再到快。 IBezierControlPoints 展开对比 曲线值与插值方式 有些插值算法需要每一帧的曲线值中存储额外的数据，因此， 曲线值与目标属性的值类型不一定相同。 对于数值类型或值类型，Cocos Creator 3D 提供了几种通用的插值方式； 同时，也可以定义自己的插值方式。 当曲线数据的 interpolate 属性为 true 时，曲线将尝试使用插值函数： 若曲线值的类型为 number、Number，将应用线性插值； 否则，若曲线值继承自 ValueType，将调用 ValueType 的 lerp 函数完成插值， Cocos Creator 3D 内置的大多数值类型都将其 lerp 实现为线性插值； 否则，若曲线值是可插值的，将调用曲线值的 lerp 函数完成插值2。 若曲线值不满足上述任何条件，或当曲线数据的 interpolate 属性为 false时， 将不会进行插值操作 --- 永远使用前一帧的曲线值作为结果。 import { AnimationClip, color, IPropertyCurveData, SpriteFrame, v3 } from \"cc\"; const animationClip = new AnimationClip(); const keys = [ 0, 0.5, 1.0, 2.0 ]; animationClip.duration = keys.length === 0 ? 0 : keys[keys.length - 1]; animationClip.keys = [ keys ]; // 所有曲线共享一列帧时间 // 使用数值的线性插值 const numberCurve: IPropertyCurveData = { keys: 0, values: [ 0, 1, 2, 3 ], /* interpolate: true, */ // interpolate 属性默认打开 }; // 使用值类型 Vec3 的 lerp() const vec3Curve: IPropertyCurveData = { keys: 0, values: [ v3(0), v3(2), v3(4), v4(6) ], interpolate: true, }; // 不插值（因为显式禁用了插值） const colorCuve: IPropertyCurveData = { keys: 0, values: [ color(255), color(128), color(61), color(0) ], interpolate: false, // 不进行插值 }; // 不插值（因为 SpriteFrame 无法进行插值） const spriteCurve: IPropertyCurveData = { keys: 0, values: [ new SpriteFrame(), new SpriteFrame(), new SpriteFrame(), new SpriteFrame() ], }; 下列代码展示了如何自定义插值算法： import { ILerpable, IPropertyCurveData, Quat, quat, Vec3, v3, vmath } from \"cc\"; class MyCurveValue implements ILerpable { public position: Vec3; public rotation: Quat; constructor(position: Vec3, rotation: Quat) { this.position = position; this.rotation = rotation; } /** 将调用此方法进行插值。 * @param this 起始曲线值 * @param to 目标曲线值 * @param t 插值比率，取值范围为 [0, 1] * @param dt 起始曲线值和目标曲线值之间的帧时间间隔 */ lerp (to: MyCurveValue, t: number, dt: number) { return new MyCurveValue( // 位置属性不插值 this.position.clone(), // 旋转属性使用 Quat 的 lerp() 方法 this.rotation.lerp(to.rotation, t), // ); } /** 此方法在不插值时调用。 * 它是可选的，若未定义此方法，则使用曲线值本身（即 `this`）作为结果值。 */ getNoLerp () { return this; } } /** * 创建了一条曲线，它实现了在整个周期内平滑地旋转但是骤然地变换位置。 */ function createMyCurve (): IPropertyCurveData { const rotation1 = quat(); const rotation2 = quat(); const rotation3 = quat(); vmath.quat.rotateY(rotation1, rotation1, 0); vmath.quat.rotateY(rotation2, rotation2, Math.PI); vmath.quat.rotateY(rotation3, rotation3, 0); return { keys: 0 /* 帧时间 */, values: [ new MyCurveValue(v3(0), rotation1), new MyCurveValue(v3(10), rotation2), new MyCurveValue(v3(0), rotation3), ], }; } 渐变方式和插值方式都影响着动画的平滑度。 循环模式 可以通过设置 AnimationClip.wrapMode 为动画剪辑设置不同的循环模式。 以下列出出了几种常用的循环模式： AnimationClip.wrapMode 效果 WrapMode.Normal 播放到结尾后停止。 WrapMode.Loop 循环播放。 WrapMode.PingPng 从动画开头播放到结尾后，从结尾开始反向播放到开头，如此循环 对于更多的循环模式，见 WrapMode。 1 动画剪辑的所在结点是指引用该动画剪辑的动画状态对象所在动画组件所附加的结点。 ↩ 2 对于数值、四元数以及各种向量，Cocos 提供了相应的可插值类以实现三次样条插值。 ↩ "},"engine/animation/skeletal-animation.html":{"url":"engine/animation/skeletal-animation.html","title":"骨骼动画","keywords":"","body":"骨骼动画 目前我们的骨骼动画运行时处理流程如下： 动画组件驱动场景的骨骼节点树，每个骨骼节点的 Local Transform (TRS) 信息就是当前帧 骨骼空间 (bone space) 的动作； 对当前所有对相机可见的骨骼模型，计算每根骨骼 模型空间 (model space) 下的 Transform 信息，并与骨骼 bindpose 相乘； 将当前帧的骨骼信息按指定蒙皮方式统一上传 GPU，在 GPU 完成蒙皮。 蒙皮算法 我们内置提供两种常见标准蒙皮算法，它们性能相近，只对最终表现有影响： LBS（线性混合蒙皮）：骨骼信息以 3x4 矩阵形式存储，直接对矩阵线性插值实现蒙皮，有体积损失等典型已知问题； DQS（双四元数蒙皮）：（推荐）骨骼信息以双四元数和缩放向量的形式进行线性插值，能正确处理绝大多数情况。 引擎默认使用 DQS，可以通过修改引擎 skinning-model.ts 的 updateJointData 函数引用与 cc-skinning.inc 中的头文件引用来切换蒙皮算法（该文件在资源管理器的 internal 文件夹的同级目录 chunks 文件夹下）。 骨骼信息上传 GPU 的模式 目前我们内置提供以下几种上传模式，不同上传模式之间不应有任何明显最终表现的差异： 上传模式 说明 uniform 模式 直接作为 Uniform Float 数组上传，限 30 根骨骼以内的模型1 RGBA32 浮点纹理模式 每个像素保存 4 个浮点数 RGBA8 普通纹理模式 每个像素保存 1 个浮点数，CPU 无任何编码过程，直接在 GPU 解码浮点数 引擎默认的模式选择原则是： 对所有 30 根骨骼以下的模型，直接使用 Uniform 模式； 否则对所有支持浮点纹理的平台，使用 RGBA32 浮点纹理模式； 对所有其他平台，使用 RGBA8 普通纹理模式。 可以通过修改 skinning-model.ts 的 selectJointsMediumType 函数修改此默认行为。 不同平台的驱动支持效率不同，我们鼓励开发者在不同平台多做测试，并欢迎反馈测试结果。 [1] 根据 GLSL 1.00 标准对 Uniform 最大数量的规定，各平台顶点着色器实现最低可以限制到 128 个 uniform vector（这个数量也是很多移动设备，如 iPhone 系列的实际限制），考虑到需要预留一定空间给用户自定义 uniform，目前我们规定 30 根骨骼为临界值（实际占用 90 个 vector），超出此骨骼数量将不再支持使用 uniform 模式。 ↩ "},"physics/physics.html":{"url":"physics/physics.html","title":"物理","keywords":"","body":"物理简介 Cocos Creator 3D 目前支持轻量的碰撞检测系统 Builtin 和具有物理模拟的物理引擎 Cannon.js （后续还会接入更为强大的 Ammo.js），并为用户提供了高效的组件化工作流程和便捷的使用方法。 物理世界和元素 物理世界中的元素可以分为一个个的刚体，在 Cocos Creator 3D 中加入物理元素可以通过为游戏对象添加碰撞器（Collider）或者刚体（RigidBody）组件，物理系统将为这些元素进行物理计算，使其表现出真实世界下的行为。 注：此处的“刚体”不是指刚体组件，刚体组件可控制刚体的物理行为相关的一部分属性。 添加物理元素 在世界中添加一个物理元素可以分为以下步骤： 新建一个形状 Cube； 在右侧 Inspector 面板上点击“添加组件”； 在 Component 目录下选择 BoxColliderComponent, 并调整参数； 为了使 Cube 具有物理行为，接着为 Cube 添加一个 RigidBodyComponent 组件，并调整参数。 这样，便有了一个既有碰撞器又有物理行为的一个物理元素。 完善物理世界 接着，完善物理世界，可以为世界添加一个地面，仿照 1，2，3 步骤，可以再添加一个只有碰撞器的 Plane； 然后，再调整摄像机的角度（选中摄像机，执行 Ctrl + Shift + F 可以对齐到屏幕）； 最后，点击运行按钮，便可以看到物理元素在场景世界上的变化， 最后的场景如下图所示： 注：通过调整组件的属性值，直接点击刷新按钮，即可在刚刚运行的浏览器上看到新的预览。 物理元素的组成 在 Cocos Creator 3D 中，一个元素可以由以下几种方式组成： 一个刚体组件 一个或多个碰撞器组件 一个刚体加一个或多个碰撞器组件 丰富多彩的物理元素，如图: 更详细的模块 Cocos Creator 3D 的物理系统的更多内容将通过以下模块来进行更详细的介绍： 模块 描述 物理选项 介绍了 Cocos Creator 3D 中可选的底层物理引擎选项 物理系统 介绍了物理系统，以及物理系统的一系列属性和接口 物理组件 介绍了一些列物理组件以及面板上的一系列属性 物理使用 进一步介绍了物理相关的使用，事件、分组掩码等 继续前往 物理选项 说明文档。 "},"physics/physics-item.html":{"url":"physics/physics-item.html","title":"物理选项","keywords":"","body":"选择适合你项目的物理系统 在编辑器中选择 \"项目->项目设置->引擎设置\" 中，您可以选择适合您项目需求的物理引擎进行开发(新项目默认为 Cannon.js 物理引擎)。如下图所示： 注：开发过程中物理引擎可随意切换。 碰撞检测 : Builtin Builtin 是仅有碰撞检测系统的物理模块，相对于其它的物理引擎，它没有复杂的物理模拟计算，所以如果您的项目不需要这一部分的物理模拟，那么可以考虑使用 Builtin ，这将使得游戏的包体更小并且性能更佳。 若使用 Builtin 进行开发，请注意以下几点： Builtin 只有 trigger 类型的事件。 ColliderComponent 中的 isTrigger 无论值真假，碰撞器都为触发器。 ColliderComponent 中的 attachedRigidbody 为 null。 RigidbodyComponent 无效。 物理引擎 : Cannon Cannon.js 是一个开源的物理引擎，它使用 js 语言开发并实现了比较全面的物理功能，如果您的项目需要更多复杂的物理功能，哪么您可以考虑使用 Cannon.js ，再通过使用 Cocos Creator 3D 提供的 RigidBodyComponent 便可以快速上手。 继续前往 物理系统 说明文档。 "},"physics/physics-component.html":{"url":"physics/physics-component.html","title":"物理组件","keywords":"","body":"物理组件 Cocos Creator 3D 目前为用户提供了碰撞器和刚体组件。 红色框内的为碰撞器组件，绿色框内为刚体组件。 碰撞器组件 碰撞器组件用于指明游戏对象的形状，比如是球还是盒，不同的形状具有不同的属性，并且碰撞后的物理行为也截然不同，可以根据自己的需要选择相应的形状。目前 Cocos Creator 3D 已经为用户提供了球和盒形状的碰撞器组件。 注：下面所列组件的属性名称的首字母在代码中实际都为小写。 盒碰撞器组件（BoxColliderComponent） 属性 解释 isTrigger 是否与其它碰撞器产生碰撞，并产生物理行为 center 形状的中心点（与所在 Node 中心点的相对位置） size 盒的大小，即长、宽、高 球碰撞器组件（SphereColliderComponent） 属性 解释（其它参考盒碰撞器） radius 球的半径 刚体组件 为了更便捷的模拟物理行为，Cocos Creator 3D为用户提供了刚体组件，预览图如下： 属性 解释（上图的属性值都是默认值） mass 物体的质量 linearDamping 线性阻尼，用于减小物体的线性速率 angularDamping 角阻尼，用于减小物体的旋转速率 isKinematic 是否由用户来控制该刚体，而不受物理引擎的影响 useGravity 是否受重力影响 fixedRotation 碰撞时是否需要固定物体，而不产生旋转 linerFactor 线性因数，可影响每个轴向的线性速度的变化 angularFactor 旋转因数，可影响每个轴向的旋转速度的变化 注： Builtin 中此组件暂时无效。 继续前往 物理使用 说明文档。 "},"physics/physics-use.html":{"url":"physics/physics-use.html","title":"物理使用","keywords":"","body":"使用物理 为了更好的介绍如何使用物理，将通过以下模块进行介绍： 模块 描述 Collider 组件 介绍了 Collider 组件的设计，以及与 RigidBody 组件的关系 RigidBody 组件 介绍了 RigidBody 组件的一些代码使用示例 物理事件 介绍了 Cocos Creator 3D 中的物理事件 分组和掩码 介绍了物理中分组和掩码的使用 继续前往 Collider 组件 说明文档。 或者回到 物理简介。 "},"ui-system/components/engine/":{"url":"ui-system/components/engine/","title":"UI","keywords":"","body":"UI 结构说明 UI 采用的是基于树状的渲染结构，整个 UI 的渲染都是基于 Canvas 节点（带有 CanvasComponent 的节点）作为根节点来进行，也就是 UI 节点的最终根节点必须是 Canvas 节点才可以被该 Canvas 渲染。每一个 UI 节点必须带有 UITransformComponent 组件以作为点击或者对齐策略等生效的必要条件。 在整体渲染方面，UI 采用了一套独立的渲染管线且优先级是最高的，整个渲染管线会先渲染完 3D 部分再渲染 UI。同时，UI 又通过 Canvas 节点的 CanvasComponent 组件上的 priority 来决定渲染的先后。 UI 还支持对模型进行渲染，唯一的条件是必须对带有模型组件（例如：ModelComponent / SkinningModelComponent）的节点添加 UI/Model 组件才可以和 UI 在相同的管线上进行渲染。 渲染数据组织以及流程如下： UI 规则介绍 渲染排序规则 多分辨率适配方案 对齐策略 文字排版 自动布局容器 制作动态生成内容的列表 制作可任意拉伸的 UI 图像 "},"ui-system/components/engine/priority.html":{"url":"ui-system/components/engine/priority.html","title":"渲染排序规则","keywords":"","body":"渲染排序说明 UI 的渲染排序采用的是一个广度优先的排序方式，每一个渲染组件（例如：SpriteComponent）身上都有一个 priority 属性。排序从根节点下的子节点开始，根据子节点的优先级来确定整体的渲染结构，也就是根节点下的子节点的渲染排序已经决定了最终的渲染顺序。每一个子节点下的所有子节点的 priority 则来确定在当前子节点下的渲染顺序。 举个例子： 从图中可以看出有一些节点是没有渲染组件的，但是它的子节点是有权利继续排序，因此，也是需要参与到排序的规则。整体的渲染顺序则是：B -> b1 -> C -> A -> a1 -> a2，在屏幕上的呈现状态为：a2 -> a1 -> A -> C -> b1 -> B -> 多分辨率适配方案 UI 结构介绍 "},"ui-system/components/engine/multi-resolution.html":{"url":"ui-system/components/engine/multi-resolution.html","title":"多分辨率适配方案","keywords":"","body":"多分辨率适配方案 Cocos Creator 3D 在整体设计上依然沿用了 Cocos Creator 实现一套资源适配多种分辨率屏幕的问题。简单概括来说，我们通过以下几个部分完成多分辨率适配解决方案： Canvas（画布） 组件随时获得设备屏幕的实际分辨率并对场景中所有渲染元素进行适当的缩放。 Widget（对齐挂件） 放置在渲染元素上，能够根据需要将元素对齐父节点的不同参考位置。 Label（文字） 组件内置了提供各种动态文字排版模式的功能，当文字的约束框由于 Widget 对齐要求发生变化时，文字会根据需要呈现完美的排版效果。 Sliced Sprite（九宫格精灵图）则提供了可任意指定尺寸的图像，同样可以满足各式各样的对齐要求，在任何屏幕分辨率上都显示高精度的图像。 接下来我们首先了解设计分辨率、屏幕分辨率的概念，才能理解Canvas（画布）组件的缩放作用。 设计分辨率和屏幕分辨率 设计分辨率 是内容生产者在制作场景时使用的分辨率蓝本，而 屏幕分辨率 是游戏在设备上运行时的实际屏幕显示分辨率。 通常设计分辨率会采用市场目标群体中使用率最高的设备的屏幕分辨率，比如目前安卓设备中 800 x 480 和 1280 x 720 两种屏幕分辨率，或 iOS 设备中 1136 x 640 和 960 x 640 两种屏幕分辨率。这样当美术或策划使用设计分辨率设置好场景后，就可以自动适配最主要的目标人群设备。 那么当设计分辨率和屏幕分辨率出现差异时，会如何进行适配呢？ 假设我们的设计分辨率为 800 x 480， 美术制作了一个同样分辨率大小的背景图像。 设计分辨率和屏幕分辨率宽高比相同 在屏幕分辨率的宽高比和设计分辨率相同时，假如屏幕分辨率是 1600 x 960，正好将背景图像放大 1600/800 = 2 倍 就可以完美适配屏幕。这是最简单的情况，这里不再赘述。 设计分辨率宽高比大于屏幕分辨率，适配高度避免黑边 假设屏幕分辨率是 1024 x 768，在下图中以红色方框表示设备屏幕可见区域。我们使用 Canvas 组件提供的的 适配高度（Fit Height）模式，将设计分辨率的高度自动撑满屏幕高度，也就是将场景图像放大到 768/480 = 1.6 倍。 这是设计分辨率宽高比大于屏幕分辨率时比较理想的适配模式，如上图所示，虽然屏幕两边会裁剪掉一部分背景图，但能够保证屏幕可见区域内不出现任何穿帮或黑边。之后可以通过 Widget（对齐挂件）调整 UI 元素的位置，来保证 UI 元素出现在屏幕可见区域里，我们在下一节 对齐策略 中将会详细介绍。 设计分辨率宽高比小于屏幕分辨率，适配宽度避免黑边 假设屏幕分辨率是 1920 x 960，同样在下图中以红色方框表示设备屏幕可见区域。我们使用 Canvas 组件提供的 适配宽度（Fit Width）模式，将设计分辨率的宽度自动撑满屏幕宽度，也就是将场景放大 1920/800 = 2.4 倍。 在设计分辨率宽高比较小时，使用这种模式会裁剪掉屏幕上下一部分背景图。 不管屏幕宽高比如何，完整显示设计分辨率中的所有内容，允许出现黑边 最后一个例子，我们屏幕分辨率假设为 640 x 960 的竖屏，如果要确保背景图像完整的在屏幕中显示，需要同时开启 Canvas 组件中的 适配高度 和 适配宽度，这时场景图像的缩放比例是按照屏幕分辨率中较小的一维来计算的，在下图的例子中，由于屏幕宽高比小于 1，就会以宽度为准计算缩放倍率，即 640/800 = 0.8 倍。 在这种显示模式下，屏幕上可能会出现黑边，或超出设计分辨率的场景图像（穿帮）。尽管一般情况下开发者会尽量避免黑边，但如果需要确保设计分辨率范围的所有内容都显示在屏幕上，也可以采用这种模式。 根据屏幕宽高比，自动选择适配宽度或适配高度 如果对于屏幕周围可能被剪裁的内容没有严格要求，也可以不开启 Canvas 组件中任何适配模式，这时会根据屏幕宽高比自动选择 适配高度 或 适配宽度 来避免黑边。也就是说，设计分辨率宽高比大于屏幕分辨率时，会自动适配高度（上面第一张图）；设计分辨率宽高比小于屏幕分辨率时，会自动适配宽度（上面第二张图）。 Canvas 组件不提供分别缩放 x 和 y 轴缩放率，会使图像变形拉伸的适配模式 在 Cocos 引擎中，也存在称为 ExactFit 的适配模式，这种模式没有黑边，也不会裁剪设计分辨率范围内的图像。但是代价是场景图像的 x 和 y 方向的缩放倍率不同，图像会产生形变拉伸。 设计分辨率只能通过项目设置里统一配置 当前的设计模式并没有加入多分辨率适配方式，所以在同一个项目里的多个 Canvas 的设计分辨率仍然采用同一套设计分辨率以及适配方案，用户可以通过 项目/项目设置/通用设置 的选项来配置。 在场景中使用 Canvas 组件 在默认场景中，UI 不是 3D 项目中的必要功能，所以用户可以通过添加 Canvas 节点，或者在场景里添加 UI 节点，编辑器会自动添加 Canvas 节点作为其父节点的方式创建 UI。编辑器展示情况如下所示： 同时，Canvas 节点本身具备以下特性： 尺寸（Size） 在编辑场景时，Canvas 节点的尺寸会保持和设计分辨率一致，不能手动更改。 在游戏运行时，在无黑边的模式中，节点的尺寸会和屏幕分辨率保持一致。在有黑边的模式中，节点的尺寸会保持设计分辨率不变。 也就是说，Canvas 的尺寸就等于屏幕可见区域，我们可以设置子 UI 元素自动对齐到 Canvas 的边框，保证 UI 元素都能在屏幕可见区域正确分布。 位置（Position）：位置会保持在 (Width / 2, Height / 2)，也就是和设计分辨率相同大小的屏幕中心。 锚点（Anchor）：锚点默认为(0.5, 0.5)，由于 Canvas 会保持在屏幕中心位置，因此 Canvas 的子节点会以屏幕中心作为坐标系原点。 -> 对齐策略 UI 结构介绍 "},"ui-system/components/engine/widget-align.html":{"url":"ui-system/components/engine/widget-align.html","title":"对齐策略","keywords":"","body":"对齐策略 要实现完美的多分辨率适配效果，UI 元素按照设计分辨率中规定的位置呈现是不够的，当屏幕宽度和高度发生变化时，UI 元素要能够智能感知屏幕边界的位置，才能保证出现在屏幕可见范围内，并且分布在合适的位置。我们通过 Widget（对齐挂件） 来实现这种效果。 下面我们根据要对齐元素的类别来划分不同的对齐工作流： 需要贴边对齐的按钮和小元素 对于暂停菜单、游戏金币这一类面积较小的元素，通常只需要贴着屏幕边对齐就可以了。这时只要几个简单的步骤： 把这些元素在 层级管理器 中设为 Canvas 节点的子节点 在元素节点上添加 Widget 组件 以对齐左下角为例，开启 Left 和 Bottom 的对齐。 然后设置好节点和屏幕边缘的距离，下图中左边距设为 40px，下边距设为 30px。 这样设置好 Widget 组件后，不管实际屏幕分辨率是多少，这个节点元素都会保持在屏幕左下角，而且节点约束框左边和屏幕左边距离保持 40px，节点约束框下边和屏幕下边距离保持 30px。 注意 Widget 组件提供的对齐距离是参照子节点和父节点相同方向的约束框边界的。比如上面例子里勾选了 Left 对齐左边，那么子节点约束框左边和父节点（也就是 Canvas 节点，约束框永远等于屏幕大小）约束框左边的距离就是我们设置的 40px。 嵌套对齐元素 上面介绍了对齐屏幕边缘的做法，由于 Widget 默认的对齐参照物是父节点，所以我们也可以添加不同的节点层级，并且让每一级节点都使用自动对齐的功能。 我们下面用一个简单的例子来说明，假设我们有这样的节点层级关系： 其中 parent 是一个面板，button 是一个按钮。我们可以分别为这两个节点添加 Widget 组件，并且分别设置对齐距离。 对于 parent 节点来说，对齐 Canvas 节点的左上角，距离都是 80px： 对于 button 节点来说，对齐 parent 节点的左上角，距离都是 50px： 依照这样的工作流程，就可以将 UI 元素按照显示区域或功能进行分组，并且不同级别的元素都可以按照设计进行对齐。 根据对齐需要自动缩放节点尺寸 以上我们展示的例子里，并没有同时对齐在同一轴向相反方向的两个边，如果我们要做一个占满整个屏幕宽度的面板，就可以同时勾选 Left 和 Right 对齐开关： 当同时勾选相反的两个方向的对齐开关时，Widget 就获得了根据对齐需要修改节点尺寸（Size） 的能力，上图中我们勾选了左右两个方向并设置了边距，Widget 就会根据父节点的宽度来动态设置节点的 Width 属性，表现出来就是不管在多宽的屏幕上，我们的面板距离屏幕左右两边的距离永远保持 100px。 制作和屏幕大小保持一致的节点 利用自动缩放节点的特性，我们可以通过设置节点的 Widget 组件，使节点的尺寸和屏幕大小保持一致，这样我们就不需要把所有需要对齐屏幕边缘的 UI 元素都放在 Canvas 节点下，而是可以根据功能和逻辑的需要结组。 要制作这样的节点，首先要保证该节点的父节点尺寸能够保持和屏幕大小一致，Canvas 节点就是一个最好的选择。接下来按照下图的方式设置该节点的 Widget 组件： 就可以在运行时时刻保持该节点和 Canvas 节点的尺寸完全一致，也就是和屏幕大小一致。经过这样设置的节点，其子节点也可以使用同样的设置来传递屏幕实际尺寸。 注意，由于 Canvas 节点本身就有保持和屏幕大小一致的功能，因此不需要在 Canvas 上添加 Widget 组件。 设置百分比对齐距离 Widget 组件上开启某个方向的对齐之后，除了指定以像素为单位的边距以外，我们还可以输入百分比数值（例如：通过单击 方框内圈出的符号），这样 Widget 会以父节点相应轴向的宽度或高度乘以输入的百分比，计算出实际的边距值。 还是看看实际的例子，我们还是以一个直接放在 Canvas 下的子节点为例，我们希望这个节点面板保持在屏幕右侧，并且总是占据 60% 的屏幕总高度。那么按照下图所示设置 Widget 组件就可以实现这个效果： Widget 在对齐方向开启时输入边距值时，可以按照需要混合像素单位和百分比单位的使用。比如在需要对齐屏幕中心线的 Left 方向输入 50%，在需要对齐屏幕边缘的 Right 方向输入 20px，最后计算子节点位置和尺寸时，所有的边距都会先根据父节点的尺寸换算成像素距离，然后再进行摆放。 利用百分比对齐距离，我们可以制作出根据屏幕大小无限缩放的 UI 元素，发挥你的想象力，一套资源适配数千种安卓机型不是问题！ 运行时每帧更新对齐和优化策略 Widget 组件一般用于场景在目标设备上初始化时定位每个元素的位置，但一旦场景初始化完毕，很多时候我们就不需要 Widget 组件再进行对齐了。这里有个重要的属性 alignOnce 用于确保 Widget 组件只在初始化时执行对齐定位的逻辑，在运行时不再消耗时间来进行对齐。 alignOnce 如果被选中，在组件初始化时执行过一次对齐定位后，就会通过将 Widget 组件的 enabled 属性设为 false 来关闭之后每帧自动更新来避免重复定位。如果需要在运行时实时定位，你需要手动将 alignOnce 属性关闭（置为 false），或者在运行时需要进行每帧更新对齐时手动遍历需要对齐的 Widget 并将他们的 enabled 属性设为 true。 对于有很多 UI 元素的场景，确保 Widget 组件的 alignOnce 选项打开，可以大幅提高场景运行性能。 对齐组件对节点位置、尺寸的限制 通过 Widget 组件开启一个或多个对齐参考后，节点的位置（position）和尺寸（width，height）属性可能会被限制，不能通过 API 或动画系统自由修改。如果需要在运行时修改对齐节点的位置或尺寸，请参考Widget 组件参考：对节点位置、尺寸的限制相关内容。 -> 文字排版 UI 结构介绍 "},"ui-system/components/engine/label-layout.html":{"url":"ui-system/components/engine/label-layout.html","title":"文字排版","keywords":"","body":"文字排版 文字组件（Label） 是核心渲染组件之一，您需要了解如何设置文字的排版，才能在 UI 系统进行多分辨率适配和对齐设置时显示完美的效果。 文字在约束框中对齐 和其他渲染组件一样，Label 组件的排版也是基于节点尺寸（Size），也就是约束框（Bounding Box）所规定的范围。约束框可参考 场景编辑器。 上图所示就是 Label 渲染的文字在蓝色约束框内显示的效果。Label 中以下的属性决定了文字在约束框中显示的位置： Horizontal Align（水平对齐）：文字在约束框中水平方向的对齐准线，可以从 Left、Right、Center 三种位置中选择。 Vertical Align（垂直对齐）：文字在约束框中垂直方向的对齐准线，可以从 Top、Bottom、Center 三种位置中选择。 上图中水平方向对齐位置设置为 Right，垂直方向的对齐位置设为了 Bottom，可以看到文字出现在约束框的底部且靠右对齐。开发者可以将以上两个属性修改为其他组合，文字会根据设置出现在蓝色约束框内相应的位置。 排版模式（Overflow） Overflow（排版模式） 属性，决定了文字内容增加时，如何在约束框的范围内排布。共有 NONE、CLAMP、SHRINK、RESIZE_HEIGHT 四种模式，而只有在后面三种模式下才能通过编辑器左上角的 矩形变换工具 或者修改 属性检查器 中的 Size 大小或者添加 Widget 组件 来调整约束框的大小。 截断（Clamp） 截断模式下，文字首先按照对齐模式和尺寸的要求进行渲染，而超出约束框的部分会被隐藏（截断）。 自动缩小（Shrink） 自动缩小模式下，如果文字按照原定尺寸渲染会超出约束框时，会自动缩小文字尺寸以显示全部文字。 注意： 自动缩小模式不会放大文字来适应约束框。 自动适应高度（Resize Height） 自动适应高度模式会保证文字的约束框贴合文字的高度，不管文字有多少行。这个模式非常适合显示内容量不固定的大段文字，配合 ScrollView 组件可以在任意 UI 区域中显示无限量的文字内容。 自动换行（Enable Wrap Text） Label 组件中的 Enable Wrap Text（自动换行）属性，可以切换文字的自动换行开关。在自动换行开启的状态下，不需要在输入文字时手动输入回车或换行符，文字也会根据约束框的宽度自动换行。 注意： 自动换行属性只有在文字排版模式的 截断（Clamp） 和 自动缩小（Shrink） 这两种模式下才有。自动适应高度（Resize Height）模式下，自动换行属性是强制开启的。 截断（Clamp）模式自动换行 截断模式开启自动换行后，会优先在约束框允许的范围内换行排列文字，如果换行之后仍无法显示全部文字时才发生截断。 以下两幅图都是在 Clamp + Enable Wrap Text 开启情况下的，区别在于文字约束框的宽度不同： 在约束框宽度从左图变化到右图的过程中，文字将不断调整换行，最后由于约束框高度不足而产生了截断显示。 自动缩小（Shrink）模式自动换行 和截断模式类似，自动缩小模式下文字超出约束框宽度时也会优先试图换行，在约束框宽度和长度都已经完全排满的情况下才会自动缩小文字以适应约束框。 中文自动换行 中文自动换行的行为和英文不同，英文是以单词为单位进行换行的，必须有空格才能作为换行调整的最小单位。中文是以字为单位进行换行，每个字都可以单独调整换行。 文字节点的锚点 文字节点的锚点和文字在约束框中的对齐模式是需要区分的两个概念。在需要靠文字内容将约束框撑大的排版模式中（如 Resize Height），要正确设置锚点位置，才能让约束框向我们期望的方向调整。 例如，如果希望文字约束框向下扩展，需要将锚点（Anchor）的 y 属性设为 1。如下图所示： 文字配合对齐挂件（Widget） 在 Label 组件所在节点上添加一个 Widget（对齐挂件） 组件，就可以让文字节点相对于父节点进行各式各样的排版。 上图中我们在背景节点上添加了两个 Label 子节点，分别为他们添加 Widget 组件后，设置左边文字 Widget 的 Right 属性为 50%，右边文字 Widget 的 Left 属性为 60%，就可以实现图中所示的多列布局式文字。 而且通过 Widget 上设置边距，加上文字本身的排版模式，可以让我们在不需要具体微调文字约束框大小的情况下轻松实现灵活美观的文字排版。 查看组件参考 关于 Label 组件的属性，也可以查阅 Label 组件参考文档。 -> 自动布局容器 UI 结构介绍 "},"ui-system/components/engine/auto-layout.html":{"url":"ui-system/components/engine/auto-layout.html","title":"自动布局容器","keywords":"","body":"自动布局容器 Layout（自动布局）组件可以挂载在任何节点上，将节点变成一个有自动布局功能的容器。所谓自动布局容器，就是能够自动将子节点按照一定规律排列，并可以根据节点内容的约束框总和调整自身尺寸的容器型节点。 布局模式（Layout Type） 自动布局组件有几种基本的布局模式，可以通过 Layout Type 属性进行设置，包括以下几种。 水平布局（Horizontal) Layout Type 设为 Horizontal 时，所有子节点都会自动横向排列，并根据子节点的宽度（Width）总和设置 Layout 节点的宽度。上图中 Layout 包括的两个 Label 节点就自动被横向排列。 水平布局模式下，Layout 组件不会干涉节点在 y 轴上的位置或高度属性，子节点甚至可以放置在 Layout 节点的约束框高度范围之外。如果需要子节点在 y 轴向上对齐，可以在子节点上添加 Widget 组件，并开启 Top 或 Bottom 的对齐模式。 垂直布局（Vertical） Layout Type 设为 Vertical 时，所有子节点都会自动纵向排列，并根据子节点的高度（Height）总和设置 Layout 节点的高度。 垂直布局模式下，Layout 组件也不会修改节点在 x 轴的位置或宽度属性，子节点需要添加 Widget 并开启 Left 或 Right 对齐模式才能规整的排列。 节点排列方向 Layout 排列子节点时，是以子节点在 层级管理器 中显示顺序为基准，加上 Vertical Direction 或 Horizontal Direction 属性设置的排列方向来排列的。 水平排列方向（Horizontal Direction） 可以设置 Left to Right 或 Right to Left 两种方向，前者会按照节点在 层级管理器 中显示顺序从左到右排列；后者会按照节点显示从右到左排列。 垂直排列方向（Vertical Direction） 可以设置 Top to Bottom 或 Bottom to Top 两种方向。前者会按照节点在 层级管理器 中显示顺序从上到下排列；后者会按照节点显示从下到上排列。 其他布局模式还在持续拓展中 我们会在之后版本的文档中更新这部分内容。 其他 Layout 组件的属性请查阅Layout 组件参考文档。 -> 制作动态生成内容的列表 UI 结构介绍 "},"ui-system/components/engine/list-with-data.html":{"url":"ui-system/components/engine/list-with-data.html","title":"制作动态生成内容的列表","keywords":"","body":"制作动态生成内容的列表 UI 界面只有静态页面内容是不够的，我们会遇到很多需要由一组数据动态生成多个元素组成的 UI 面板，比如选人界面、物品栏、选择关卡等等。 准备数据 以物品栏为例，我们要动态生成一个物品，大概需要这样的一组数据： 物品 id 图标 id，我们可以在另一张资源表中建立图标 id 到对应 spriteFrame 的索引 物品名称 出售价格 ... 下面我们将会结合脚本介绍如何定义和使用数据，如果您对 Cocos Creator 3D 的脚本系统还不熟悉，可以先从 脚本开发指南一章开始学习。 自定义数据类 对于大多数游戏来说，这些数据通常都来自于服务器或本地的数据库，现在我们为了展示流程，暂时把数据存在列表组件里就可以了。您可以新建一个脚本 ItemList.js，并添加如下的属性： @ccclass('Item') export class Item { @property id = 0; @property itemName = ''; @property itemPrice = 0; @property(SpriteFrame) iconSF: SpriteFrame | null = null; } @ccclass export class ItemList extends Component { @property([Item]) items: Item[] = []; @property(Prefab) itemPrefab: Prefab | null = null; onLoad() { for (var i = 0; i 上面脚本的前半部分我们声明了一个叫做 Item 的数据类，用来存放我们展示物品需要的各种数据。注意这个类并没有继承 cc.Component，因此他不是一个组件，但可以被组件使用。关于声明自定义类的更多内容，请查阅自定义 Class文档。 下半部分是正常的组件声明方式，这个组件中只有一个 items 属性，上面的声明方式将会给我们一个由 Item 类组成的数组，我们可以在 属性检查器 中为每个 Item 元素设置数据。 新建一个节点并将 ItemList.js 添加上去，我们可以在 属性检查器 里找到 Items 属性，要开始创建数据，需要先将数组的容量设为大于 0 的值。让我们将容量设为 3，并将每个元素的数据如下图设置。 这样我们最基本的数据就准备好了，如果您在制作有很多内容的游戏，请务必使用 excel、数据库等更专业的系统来管理您的数据，将外部数据格式转化为 Cocos Creator 可以使用的 JavaScript 和 JSON 格式都非常容易。 制作表现：Prefab 模板 接下来我们还需要一个可以在运行时用来实例化每个物品的模板资源 —— Prefab 预制。这个 Prefab 的结构如下图所示 icon, name, price 节点之后就会用来展示图标、物品名称和价格的数据。 模板组件绑定 您在拼装 Prefab 时可以根据自己的需要自由发挥，上图中展示的仅仅是一个结构的例子。有了物品的模板结构，接下来我们需要一个组件脚本来完成节点结构的绑定。新建一个 ItemTemplate.js 的脚本，并将其添加到刚才制作的模板节点上。该脚本内容如下： @ccclass export class ItemTemplate extends Component { @property public id = 0; @property(SpriteComponent) public icon: SpriteComponent | null = null; @property(LabelComponent) public itemName: LabelComponent | null = null; @property(LabelComponent) public itemPrice: LabelComponent | null = null; } 接下来将对应的节点拖拽到该组件的各个属性上： 注意 id 这个属性我们会直接通过数据赋值，不需要绑定节点。 通过数据更新模板表现 接下来我们需要继续修改 ItemTemplate.js，为其添加接受数据后进行处理的逻辑。在上述脚本后面加入以下内容： // data: { id, iconSF, itemName, itemPrice } init(data: Item) { this.id = data.id; this.icon.spriteFrame = data.iconSF; this.itemName.string = data.itemName; this.itemPrice.string = data.itemPrice; } init 方法接受一个数据对象，并使用这个对象里的数据更新各个负责表现组件的相应属性。现在我们可以将Item 节点保存成一个 Prefab 了，这就是我们物品的模板。 根据数据生成列表内容 现在让我们回到 ItemList.js 脚本，接下来要添加的是物品模板 Prefab 的引用，以及动态生成列表的逻辑。 //... @property(Prefab) itemPrefab: Prefab | null = null; onLoad () { for (var i = 0; i 在 onLoad 回调方法里，我们依次遍历 items 里存储的每个数据，以 itemPrefab 为模板生成新节点并添加到 ItemList.js 所在节点上。之后调用 ItemTemplate.js 里的 init 方法，更新每个节点的表现。 现在我们可以为 ItemList.js 所在的节点添加一个 Layout 组件，通过 属性检查器 下方的 添加组件/添加 UI 组件/Layout，然后设置 Layout 组件的以下属性： Type: HORIZONTAL Resize Mode: CONTAINER 别忘了把 item Prefab 拖拽到 ItemList 组件的 itemPrefab 属性里。您还可以为这个节点添加一个 Sprite 组件，作为列表的背景。 完成后的 itemList 节点属性如下： 预览效果 最后运行预览，可以看到类似这样的效果（具体效果和您制作的物品模板，以及输入的数据有关）： 注意前面步骤中添加 Layout 组件并不是必须的，Layout 能够帮助您自动排列列表中的节点元素，但您也可以用脚本程序来控制节点的排列。我们通常还会配合 ScrollView 滚动视图组件一起使用，以便在有限的空间内展示大量内容。可以配合自动布局和滚动视图一起学习。 -> 制作可任意拉伸的 UI 图像 UI 结构介绍 "},"ui-system/components/engine/sliced-sprite.html":{"url":"ui-system/components/engine/sliced-sprite.html","title":"制作可任意拉伸的 UI 图像","keywords":"","body":"制作可任意拉伸的 UI 图像 UI 系统核心的设计原则就是能够自动适应各种不同的设备屏幕尺寸，因此我们在制作 UI 时需要正确设置每个控件元素的尺寸（size），并且让每个控件元素的尺寸能够根据设备屏幕的尺寸进行自动的拉伸适配。为了实现这一点，就需要使用九宫格格式的图像来渲染这些元素。这样即使使用很小的原始图片也能生成覆盖整个屏幕的背景图像，一方面节约游戏包体空间，另一方面能够灵活适配不同的排版需要。 上图右边为原始贴图大小的显示，左边是选择 Sliced 模式并放大 size 属性后的显示效果。 编辑图像资源的九宫格切分 要使用可以无限放大的九宫格图像效果，我们需要先对图像资源进行九宫格切分。有两种方式可以打开 Sprite 编辑器来编辑图像资源： 在 资源管理器 中选中图像资源，然后点击 属性检查器 最下面的编辑按钮。如果您的窗口高度不够，可能需要向下滚动 属性检查器 才能看到下面的按钮。 在 场景编辑器 中选中想要九宫格化的图像节点，然后在 属性检查器 的 Sprite 组件里，找到并按下Sprite Frame属性右侧的编辑按钮。 打开 Sprite 编辑器 以后，可以看到图像周围有一圈绿色的线条，表示当前九宫格分割线的位置。将鼠标移动到分割线上，可以看到光标形状改变了，这时候就可以按下并拖拽鼠标来更改分割线的位置。 我们分别拖动上下左右四条分割线，将图像切分成九宫格，九个区域在 Sprite 尺寸（size）变化时会应用不同的缩放策略，见下图： 而下图中描述了不同区域缩放时的示意（图片来自Yannick Loriot的博客）： 完成切分后别忘记点击 Sprite 编辑器 右上角的绿色对勾来保存对资源的修改。 设置 Sprite 组件使用 Sliced 模式 准备好九宫格切分的资源后，就可以修改 Sprite 的显示模式并通过修改size来制作可任意指定尺寸的 UI 元素了。 首先选中场景中的 Sprite 节点，将 Sprite 的 Type 属性设为 Sliced。 然后通过矩形变换工具拖拽控制点使节点的 size 属性变大。您也可以直接在 属性检查器 中输入数值来修改 size 属性。如果图像资源是用九宫格的形式生产的，那么不管 Sprite 如何放大，都不会产生模糊或变形。 注意事项 在使用矩形变换工具或直接修改 Sliced Sprite 的size属性时，注意size属性值不能为负数，否则不能以 Sliced 模式正常显示。 UI 结构介绍 "},"engine/event/":{"url":"engine/event/","title":"事件机制","keywords":"","body":"事件 事件是用于引擎内对象交互的消息传递机制。 事件监听 // 该事件监听每次都会触发，需要手动取消注册 xxx.on(type, func, target); // 该事件监听只执行一次，无需取消注册 xxx.once(type, func, target); 的方式来监听，其中 type 为事件注册字符串，func 为执行事件监听的回调，target 为事件接收对象。 事件取消 // 取消对象身上所有注册的该类型的事件 xxx.off(type); // 取消对象身上该类型指定回调的事件 xxx.off(type, func); // 取消对象身上该类型指定回调指定目标的事件 xxx.off(type, func, target); 事件派发 // 事件派发的时候可以指定派发参数 xxx.emit(type, ...arg); 需要说明的是，出于底层事件派发的性能考虑，这里最多只支持传递 5 个事件参数。所以在传参时需要注意控制参数的传递个数。 事件说明 系统事件 系统事件指的是全局事件，直接从浏览器进行事件监听和派发。 cc.systemEvent.on(type, func, target); 当前支持的系统事件有：触摸事件，鼠标事件，重力事件，按键事件。可以通过 cc.SystemEventType 获取全局事件类型。 事件名 事件类型说明 TOUCH_START 手指开始触摸事件。 TOUCH_MOVE 当手指在屏幕上移动时。 TOUCH_END 手指结束触摸事件。 TOUCH_CANCEL 当手指在目标节点区域外离开屏幕时。 MOUSE_DOWN 当鼠标按下时触发一次。 MOUSE_MOVE 当鼠标在目标节点在目标节点区域中移动时，不论是否按下。 MOUSE_UP 当鼠标从按下状态松开时触发一次。 MOUSE_WHEEL 鼠标滚动事件。 MOUSE_ENTER 当鼠标移入目标节点区域时，不论是否按下。 MOUSE_LEAVE 当鼠标移出目标节点区域时，不论是否按下。 KEY_DOWN 当按下按键时触发的事件。 KEY_UP 当松开按键时触发的事件。 DEVICEMOTION 重力感应。 TRANSFORM_CHANGED 节点改变位置、旋转或缩放事件.。 POSITION_PART 节点位置改变事件。统一由 TRANSFORM_CHANGED 监听，派发后判断类型。 ROTATION_PART 节点旋转事件。统一由 TRANSFORM_CHANGED 监听，派发后判断类型。 SCALE_PART 节点缩放事件。统一由 TRANSFORM_CHANGED 监听，派发后判断类型。 SIZE_CHANGED 当节点尺寸改变时触发的事件。 ANCHOR_CHANGED 当节点锚点改变时触发的事件。 CHILD_ADDED 节点子类添加。 CHILD_REMOVED 节点子类移除。 KEY 事件获取的键值列表具体可参照 API 的 Macro 来使用。 UI 事件 事件处理是在节点（cc.Node）中完成的。对于组件，可以通过访问节点 this.node 来注册和监听事件。监听事件可以 通过 this.node.on() 函数来注册，方法如下： import { _decorator, Component, Node } from \"Cocos3D\"; const { ccclass } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { this.node.on(Node.EventType.TOUCH_CANCEL, this.callback, this); } callback(){ } onDestroy(){ // 一般为了数据回收把控，我们会指定 func，并且在组件 destroy 的时候注销事件 this.node.off(Node.EventType.TOUCH_CANCEL); } 节点的事件派发还支持 dispatchEvent，与 emit 的差别在于 dispatchEvent 可以做事件传递。通过该方法发射的事件，会进入事件派送阶段。在 Cocos Creator 的事件派送系统中，我们采用冒泡派送的方式。冒泡派送会将事件从事件发起节点，不断地向上传递给他的父级节点，直到到达根节点或者在某个节点的响应函数中做了中断处理 event.propagationStopped = true 如上图所示，当我们从节点 c 发送事件 “foobar”，倘若节点 a，b 均做了 “foobar” 事件的监听，则 事件会经由 c 依次传递给 b，a 节点。如： // 节点 c 的组件脚本中 this.node.dispatchEvent( new cc.Event.EventCustom('foobar', true) ); 如果我们希望在 b 节点截获事件后就不再将事件传递，我们可以通过调用 event.stopPropagation() 函数来完成。具体方法如下： // 节点 b 的组件脚本中 this.node.on('foobar', (event) => { event.propagationStopped = true; }); 请注意，在发送用户自定义事件的时候，请不要直接创建 cc.Event 对象，因为它是一个抽象类，请创建 cc.Event.EventCustom 对象来进行派发。 事件对象 在事件监听回调中，开发者会接收到一个 cc.Event 类型的事件对象 event，propagationStopped 就是 cc.Event 的标准 API，其它重要的 API 包含： API 名 类型 意义 type String 事件的类型（事件名） target cc.Node 接收到事件的原始对象 currentTarget cc.Node 接收到事件的当前对象，UI 事件在冒泡阶段当前对象可能与原始对象不同， getType Function 获取事件的类型 propagationStopped Function 停止冒泡阶段，事件将不会继续向父节点传递，当前节点的剩余监听器仍然会接收到事件 propagationImmediateStopped Function 立即停止事件的传递，事件将不会传给父节点以及当前节点的剩余监听器 getCurrentTarget Function 获取当前接收到事件的目标节点 detail Function 自定义事件的信息（属于 cc.Event.EventCustom） setUserData Function 设置自定义事件的信息（属于 cc.Event.EventCustom） getUserData Function 获取自定义事件的信息（属于 cc.Event.EventCustom） 完整的 API 列表可以参考 cc.Event 及其子类的 API 文档。 注意事项 Cocos Creator 3D 和 Cocos Creator 的事件系统带有屏幕坐标的轻微差别。由于 3D 世界的屏幕就是 Canvas 的大小，而 UI 世界是带有屏幕适配计算，所以实际的尺寸并不是屏幕的尺寸，所以在获取到的屏幕坐标两者是完全不一样的。如果你想要获取真实的屏幕大小，可以通过 cc.view.getCanvasSize() 来获取，如果你要的是 UI 屏幕坐标，可以通过 cc.view.getVisibleSize() 来获取。系统事件所得到的位置就是屏幕位置，节点得到的位置就是 UI 世界点击位置。 "},"scripting/":{"url":"scripting/","title":"脚本指南","keywords":"","body":"脚本 Cocos Creator 3D 脚本用于实现用户定义的（游戏）行为。 脚本创建 语言支持 脚本基础 cc 类 组件 "},"scripting/setup.html":{"url":"scripting/setup.html","title":"脚本创建","keywords":"","body":"创建脚本 创建组件脚本 在 Cocos Creator 3D 中，脚本也是资源的一部分。你可以在资源编辑器中通过点击\"创建\"按钮来添加并选择 JavaScript 或者 TypeScript 来创建一份组件脚本。此时你会在你的资源编辑器中得到一份新的脚本： 一份简单的组件脚本如下： import { _decorator, Component } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"NewScript\") export class NewScript extends Component { /* class member could be defined like this */ // dummy = ''; /* use `property` decorator if your want the member to be serializable */ // @property // serializableDummy = 0; start () { // Your initialization goes here. } // update (deltaTime) { // // Your update function goes here. // } } 编辑脚本 用户可根据自己的需求，选择自己喜爱的文本工具（如：Vim, Sublime Text, Web Storm, VSCode...）进行脚本编辑，请先到 设置 中进行设置。 通过双击脚本资源，可以直接打开脚本编辑器进行编辑。当编辑完脚本并保存，Cocos Creator 3D 会自动检测到脚本的改动，并迅速编译。 在代码编写之前，请先阅读 脚本语言支持 了解更多关于脚本的内容。 添加脚本到场景节点中 将脚本添加到场景节点中，实际上就是为这个节点添加一份组件。我们先将刚刚创建出来的 NewScript.js 重命名为 say-hello.js。然后选中我们希望添加的场景节点，此时该节点的属性会显示在 属性检查器 中。在 属性检查器 的最下方有一个 添加组件 的按钮，点击按钮并选择 添加用户脚本 -> say-hello 来添加我们刚刚编写的脚本组件。 如果一切顺利，你将会看到你的脚本显示在 属性检查器 中： 注意：用户也可以通过直接拖拽脚本资源到 属性检查器 的方式来添加脚本。 默认脚本编辑工具配置 继续前往 脚本语言支持。 "},"scripting/basic.html":{"url":"scripting/basic.html","title":"语言支持与运行环境","keywords":"","body":"运行环境 Cocos Creator 3D 引擎的 API 都存在于模块 cc中， 使用标准的 ES6 模块导入语法将其导入： import { Component, // 导入类 Component _decorator, // 导入命名空间 _decorator } from \"cc\"; import * as cc from \"cc\"; // 将整个 Cocos Creator 3D 模块导入为命名空间 Cocos Creator 3D @_decorator.ccclass(\"MyComponent\") export class MyComponent extends Component { public v = new cc.Vec3(); } 保留标识符 cc 注意，由于历史原因，cc 是 Cocos Creator 3D 保留使用的标识符， 其行为相当于在任何模块顶部已经定义了名为 cc 的对象。 因此，你不应该将 cc 用作任何全局对象的名称： /* const cc = {}; // 每个 Cocos Creator 3D 脚本都等价于在此处含有隐式定义 */ import * as cc from \"cc\"; // 错误：命名空间导入名称 cc 由 Cocos Creator 3D 保留使用 const cc = { x: 0 }; console.log(cc.x); // 错误：全局对象名称 cc 由 Cocos Creator 3D 保留使用 function f () { const cc = { x: 0 }; console.log(cc.x); // 正确：cc 可以用作局部对象的名称 const o = { cc: 0 }; console.log(o.cc); // 正确：cc 可以用作属性名 } console.log(cc, typeof cc); // 错误：行为是未定义的 "},"scripting/ccclass.html":{"url":"scripting/ccclass.html","title":"ccclass","keywords":"","body":"cc 类 将装饰器 ccclass 应用在类上时，此类称为 cc 类。 cc 类注入了额外的信息以控制 Cocos Creator 3D 对该类对象的序列化、编辑器对该类对象的展示等。 ccclass cc 类的各种特性是通过 ccclass(name) 的 cc 类选项参数来指定的。 cc 类名 选项 name 指定了 cc 类的名称。cc 类名应该是独一无二的。 当需要相应的 cc 类时，可以通过其 cc 类名来查找，例如： 序列化。 若对象是 cc 类对象， 则在序列化时将记录该对象的 cc 类名， 反序列化时将根据此名称找到相应的 cc 类进行序列化。 当 cc 类是组件类时，Node 通过可以组件类的 cc 类名查找该组件； cc 属性 当装饰器 property 应用在 cc 类的属性或访问器上时，此属性称为 cc 属性。 与 cc 类类似，cc 属性注入了额外的信息以控制 Cocos Creator 3D 对该属性的序列化、编辑器对该属性的展示等。 property cc 属性的各种特性是通过 property() 的 cc 属性选项参数来指定的。 cc 类型 选项 type 指定了属性的 cc 类型。 可以通过以下几种形式的参数指定类型： 构造函数。 构造函数所指定的类型就直接作为属性的 cc 类型。 注意，当 Javascript 构造函数 Number、String、Boolean 用作 cc 类型时将给出警告，并且将 分别视为 cc 类型 CCFloat、CCString、CCBoolean。 Cocos Creator 3D 内置属性类型标识。 CCInteger、CCFloat、CCBoolean、CCString 是内置属性类型标识。 CCInteger 声明类型为 Cocos Creator 3D 整数； CCFloat 声明类型为 Cocos Creator 3D 浮点数； CCString 声明类型为 Cocos Creator 3D 字符串； CCBoolean 声明类型为 Cocos Creator 3D 布尔值。 数组。 通过将构造函数、Cocos Creator 3D 内置属性类型标识或数组作为数组元素时， 属性被指定为 Cocos Creator 3D 数组。 例如 [CCInteger] 就将类型声明为元素为Cocos Creator 3D 整数的 Cocos Creator 3D 数组。 若属性未指定 cc 类型，Cocos Creator 3D 将从属性的默认值或初始化式的求值结果推导其 cc 类型： 若值的类型是 Javascript 原始类型 number、string、boolean， 则其 cc 类型分别为 Cocos Creator 3D 浮点数、Cocos Creator 3D 字符串、Cocos Creator 3D 布尔值。 否则，若值是对象类型，则相当于使用对象的构造函数指定了 cc 类型； 否则，属性的 cc 类型是未定义的。 关于 cc 类型如何影响 cc 属性以及对未定义 cc 类型的属性的处理，见： 编辑器和属性类型 序列化 下列代码演示了不同 cc 类型 的 cc 属性的声明： import { _decorator, CCInteger, Node } from \"cc\"; const { ccclass, property } = _decorator; @ccclass class MyClass { @property(CCInteger) // 声明属性 _id 的 cc 类型为 Cocos 整数 private _id = 0; @property(Node) // 声明属性 _targetNode 的 cc 类型为 Node private _targetNode: Node | null = null; @property([Node]) // 声明属性 _children 的 cc 类型为 Node 数组 private _children: Node[] = []; @property private _count = 0; // 未声明 cc 类型，从初始化式的求值结果推断为 Cocos 浮点数 @property(String) // 警告：不应该使用构造函数 String // 等价于 CCString private _name: string = ''; @property private _children2 = []; // 未声明 cc 类型，从初始化式的求值结果推断为：元素为未定义的 Cocos 数组 } 默认值 选项 default 指定了 cc 属性的默认值。 "},"scripting/component.html":{"url":"scripting/component.html","title":"组件","keywords":"","body":"组件 所有继承自 Component 的类都称为组件类， 其对象称为组件，实现了 Cocos Creator 3D EC 系统中的组件概念。 组件类必须是 cc 类。 import { Component } from \"cc\"; @ccclass(\"MyComponent\") class MyComponent extends Component { } 组件的创建和销毁 组件的生命周期完全由结点操控。 与普通类对象不同，组件不能由构造函数创建： const component = new MyComponent(); // 错误：组件无法由构造函数创建 相反地，组件必须由结点来创建： const myComponent = node.addComponent(MyComponent); 在此之后，称组件附加到了结点上。 调用 Node.removeComponent 方法移除指定的组件并将其销毁。 组件总是附加在某个结点上，除了： 在组件类的构造函数结束之前； 组件从结点上移除之后。 import { Component } from \"cc\"; @ccclass(\"MyComponent\") class MyComponent extends Component { constructor () { console.log(this.node.name); // 错误：组件并未附加到结点上 } public printNodeName () { console.log(this.node.name); } } // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> const myComponent = node.addComponent(MyComponent); myComponent.printNodeName(); // 正确 node.removeComponent(); myComponent.printNodeName(); // 错误：组件并未附加到结点上 "},"editor/":{"url":"editor/","title":"面板介绍","keywords":"","body":"编辑器界面介绍 这一章将会介绍编辑器界面，熟悉组成编辑器的各个面板、菜单和功能按钮。Cocos Creator 编辑器由多个面板组成，面板可以自由移动、组合，以适应不同项目和开发者的需要。我们在这里将会以默认编辑器布局为例，快速浏览各个面板的名称和作用： 场景编辑器 场景编辑器 是用来展示和编辑场景中可视内容的工作区域。所见即所得的场景搭建工作都依靠场景编辑器中的显示来完成。 详情请阅读 场景编辑器 一节。 层级管理器 层级管理器 用树状列表的形式展示场景中的所有节点和他们的层级关系，所有在 场景编辑器 中看到的内容都可以在 层级管理器 中找到对应的节点条目，在编辑场景时这两个面板的内容会同步显示，一般我们也会同时使用这两个面板来搭建场景。 详情请阅读 层级管理器 一节。 资源管理器 资源管理器 里显示了项目资源文件夹（assets）中的所有资源。这里会以树状结构显示文件夹并自动同步在操作系统中对项目资源文件夹内容的修改。您可以将文件从项目外面直接拖拽进来，或使用菜单导入资源。 详情请阅读 资源管理器 一节。 属性检查器 属性检查器 是我们查看并编辑当前选中节点和组件属性的工作区域，这个面板会以最适合的形式展示和编辑来自脚本定义的属性数据。 详情请阅读 属性检查器 一节。 控制台 控制台 会显示报错、警告或其他编辑器和引擎生成的日志信息。 详情请阅读 控制台 一节。 动画编辑器 动画编辑器 可以编辑并存储动画数据。 详情请阅读 熟悉动画编辑器 一节。 偏好设置 偏好设置 里提供各种编辑器个性化的全局设置，包括原生开发环境、游戏预览、其他插件的全局设置等。 详情请阅读 偏好设置 一节。 项目设置 项目设置 里提供各种项目特定的个性化设置，包括分组管理、模块设置、项目预览、自定义引擎等。 详情请阅读 项目设置 一节。 "},"editor/scene/":{"url":"editor/scene/","title":"场景编辑器","keywords":"","body":"场景编辑器 场景编辑器 是内容创作的核心工作区域，您将使用它选择和摆放场景图像、角色、特效、UI 等各类游戏元素。在这个工作区域里，您可以选中并通过 变换工具 修改节点的位置、旋转、缩放、尺寸等属性，并可以获得所见即所得的场景效果预览。 视图介绍 导航 3D视图和2D视图的导航方式有所不同，通过工具栏中的3D/2D按钮可以切换3D和2D视图，3D视图用于3D场景编辑，2D视图主要用于UI，Sprite等2D元素的编辑。 3D视图 在3D视图下，您可以通过以下操作来移动和定位 场景编辑器 的视图： 鼠标左键+Alt：摄像机围绕视图中心点旋转。 鼠标中键：平移视图。 鼠标滚轮：摄像机前后移动。 鼠标右键+WASD：摄像机漫游。 F 快捷键：摄像机聚焦到当前选中节点。 2D视图 在2D视图下，您可以通过以下操作来移动和定位 场景编辑器 的视图： 鼠标中键：平移视图。 鼠标滚轮：以当前鼠标悬停位置为中心缩放视图。 鼠标右键：平移视图。 F 快捷键：摄像机聚焦到当前选中节点。 坐标系和网格 场景中网格是我们摆放场景元素时位置的重要参考信息，关于坐标系和位置等节点属性的关系，请阅读 坐标系和变换 一节 选择节点 在场景视图中点击鼠标左键选择物体所在节点，选择节点是使用变换工具设置节点位置、旋转、缩放等操作的前提。 Gizmo 操作简介 场景编辑器 的核心功能就是以所见即所得的方式编辑和布置场景中的可见元素，我们主要通过 Gizmo 工具来辅助完成场景的可视化编辑。 变换工具Gizmo 摄像机Gizmo 灯光Gizmo 碰撞器Gizmo 粒子系统Gizmo "},"editor/hierarchy/":{"url":"editor/hierarchy/","title":"层级管理器","keywords":"","body":"层级管理器 层级管理器 面板用来展现当前场景里大部分节点的层级关系。场景中有部分不需要显示的节点，一般是支撑场景显示的必要因素，但不可操作，用户可以忽略，有做插件的时可另看详细说明（后续补充）。 你可以在 层级管理器 里选择，创建，移动，重命名或删除节点，任意节点都可创建出子节点，子节点的坐标系相对于父级节点。选中节点，节点呈现蓝底白字的高亮状态，节点的详细属性会在 属性检查器 中显示。 面板介绍 层级管理器 面板上主要有顶部菜单区，底部树形列表区： 顶部菜单的功能有：新建节点按钮 ，搜索类型按钮 ，搜索框，全部折叠或展开按钮 ，刷新列表按钮 。 底部树形列表区主要体现节点的层级关系，根节点是 场景节点，编辑 prefab 文件时，根节点是不是 场景节点，而是自身的顶层节点。树形区域的尾部有 20px 高度的空白区域，点击此处可以 取消选中，即 层级管理器 中可以没有选中项。 面板支持右击菜单，不同位置和节点的右击菜单内容会有差异。 面板支持键盘快捷方式： 复制：Ctrl or Cmd + C 粘贴：Ctrl or Cmd + V 拷贝：Ctrl or Cmd + D，Ctrl + 拖动节点 删除：Delete 上下选择：上下箭头 节点的折叠：左箭头 或 Backspace 节点的展开：右箭头 或 Enter 多选：Ctrl or Cmd + 点击 多选：Shift + 点击 新建节点 点击 新建节点按钮 新增节点的时候，会先出现一个 输入框 要求填入节点的名称，如果输入为空，则不会创建节点。树形列表中如果没有选中项，则默认新建到当前根节点上；如果有多个选中项，此时会新建到第一个选中节点里。 此外节点的右击菜单中也有 新建 的入口。 对于 UI 节点，它的显示有个规则：需要其上级节点中至少有一个含有 cc.UITransformComponent 组件，所以在创建 UI 节点的时候，为了让其显示，会主动检查该条规则，如果不符合规则，会辅助添加一个 Canvas 节点作为它的父级，以满足创建后可见。 此外还可以通过 资源管理器 中拖动一个 prefab 资源到 层级管理器 里生成一个节点。 选中节点 在节点列表中可以使用以下操作选中节点： 点击可单选节点 键盘上下箭头可以上下切换选中 按住 Ctrl or Cmd + 点击，可以多选节点 按住 Shift + 点击，可以多选节点 移动节点 节点的移动分为移动到目标节点的上方，下方，内部。 移动需要两个节点：被移动的节点 和 目标位置节点，其中会对 目标位置节点 的高度进行三节划分，偏上，中部，偏下，各占 4px 左右。移动鼠标时会识别所处的位置： 偏上，样式为节点的顶部有已橙色横线，此时释放鼠标会将 被移动的节点 移到 目标位置节点 的上方，两者是平级的。 中部，样式为节点有橙色条背景，此时释放鼠标会将 被移动的节点 移到 目标位置节点 的内部，排在最末尾。 偏下，样式为节点有虚线连接线到尾部橙色横线，此时释放鼠标会将 被移动的节点 移到 目标位置节点 的下方，两者是平级的。 此外 属性检查器 的某些属性值需要 cc.Node 类型数据，此时可以从 层级管理器 拖节点到 属性检查器。 搜索节点 头部菜单中的 搜索类型按钮 有 3 种排序方式：搜索名称，搜索 UUID，搜索组件名称。其中 搜索组件名称 是搜索节点组件，可在 属性检查器 查看到组件名称，如 cc.ModelComponent。 搜索框 变动即时搜索，在搜索结果中选中节点，清空搜索内容后，视窗范围内会重新定位到该选中的节点，以达到通过搜索来定位节点的目的。 折叠节点 全部折叠或展开按钮 便于回缩视图范围，更容易找到节点。树形中的父级节点支持快捷键方式，首先选中节点，然后键盘操作： 节点的折叠：左箭头 或 Backspace 节点的展开：右箭头 或 Enter 重命名节点 选中某个节点，快捷键 F2 或右击菜单的 重命名 可以进入修改名称，名称不能为空，为空或 快捷键 Esc 会取消此次重命名。节点之间可以有相同的名称。 "},"editor/assets/":{"url":"editor/assets/","title":"资源管理器","keywords":"","body":"资源管理器 资源管理器 面板是我们用来访问和管理项目资源的重要工具。在开始制作游戏时，导入资源 通常是必须的步骤。您可以在新建项目时使用 Hello World 模板项目，新建项目后打开项目，就可以在 资源管理器 面板看到一些类型资源。 面板介绍 资源管理器 面板上主要有头部菜单区，中部树形列表区，底部信息显示区： 头部菜单区的功能有：新建资源按钮 ，排序方式按钮 ，搜索类型按钮 ，搜索框，全部折叠或展开按钮 ，刷新列表按钮 中部树形列表区主要体现资源的层级关系，根节点是对应 操作系统的文件管理器 的资源根文件夹，编辑器中称为一个资源的 DataBase ( 简称 DB )，其中 Assets DB 在项目文件夹中，属于项目资源；Internal DB 是编辑器自带的，提供一些内置的必要资源，属于只读资源，不可以增删改操作，但可以直接引用内部或复制出来。 底部显示区是选中资源后显示该资源的 URL, 如 db://assets 面板的右击菜单也是重要的功能，不同位置的右击菜单内容有差异，其中不可用的菜单显示为灰色。 面板的快捷方式目前支持资源的操作： 复制：Ctrl or Cmd + C 粘贴：Ctrl or Cmd + V 拷贝：Ctrl or Cmd + D，Ctrl + 拖动资源 删除：Delete 上下选择：上下箭头 文件夹的折叠：左箭头 或 Backspace 文件夹的展开：右箭头 或 Enter 多选：Ctrl or Cmd + 点击 多选：Shift + 点击 新建资源 点击 新建资源按钮 新增资源的时候，会先出现一个 输入框 要求填入资源的名称，如果输入为空，则不会创建资源。树形列表中如果没有选中项，则默认新建到 Asset DB 根节点上；如果有多个选中项，此时会新建到第一个选中项里。 此外文件夹的右击菜单中也有 新建 的入口。 新建资源 右击菜单的新建资源 选中资源 在资源列表中可以使用以下操作选中资源： 点击可单选资源 键盘上下箭头可以上下切换选中 按住 Ctrl or Cmd + 点击，可以多选资源 按住 Shift + 点击，可以多选资源 移动资源 通过对树形节点的拖动来实现资源的移动： 移动资源，资源从树形列表中的一个文件夹里拖出到另一个文件夹，此时会有一个橙色的框表示新位置所属的文件夹的范围。 拖出资源，可以将 .prefab, .gltf, .mesh, .fbx 资源拖到 场景面板 或 层级面板 里生成节点。 拖入资源，从 层级面板 拖动节点到列表中的某个文件夹，可实现保存该节点为一个 .prefab 资源,详见 预制资源（Prefab）；从 操作系统的文件管理器 拖动文件到列表中，可实现资源的导入。 删除资源 右击菜单中的 删除，或者键盘快捷方式 Delete，支持多选后批量删除资源，资源删除后可以在 操作系统的回收站 将其还原。 重新导入资源 右击菜单中的 重新导入资源 可以更新生成到 Library 的数据，支持批量重新导入。 排序资源 头部菜单中的 排序方式按钮 有 2 种排序方式：按名称排序，按类型排序， 排序方式有记忆，下次打开编辑器会保持已存的排序方式。 搜索资源 头部菜单中的 搜索类型按钮 有 3 种排序方式：搜索名称，搜索 UUID，搜索类型。其中 搜索类型 是搜索资源的 Importer 类型，不是资源的后缀类型名称。 搜索框 变动即时搜索，在搜索结果中选中资源，清空搜索内容后，视窗范围内会重新定位到该选中的资源，以达到通过搜索来定位资源的目的。 折叠资源 全部折叠或展开按钮 便于回缩视图范围，更容易找到资源。树形中的父级节点支持快捷键方式，首先选中资源，然后键盘操作： 文件夹的折叠：左箭头 或 Backspace 文件夹的展开：右箭头 或 Enter 重命名资源 选中某个资源，快捷键 F2 或右击菜单的 重命名 可以进入修改名称，名称不能为空，为空或 快捷键 Esc 会取消此次重命名。脚本的名称不能以数字开头且不能与现有脚本文件重名。 "},"editor/inspector/":{"url":"editor/inspector/","title":"属性检查器","keywords":"","body":"属性检查器 属性检查器 是我们查看并编辑当前选中节点和组件属性的工作区域。在 场景编辑器 或 层级管理器 中选中节点，就会在 属性检查器 中显示该节点的属性和节点上所有组件的属性以供您查询和编辑。 节点名称和激活开关 左上角的复选框表示节点的激活状态，使用节点处于非激活状态时，节点上所有图像渲染相关的组件都会被关闭，整个节点包括子节点就会被有效的隐藏。 节点激活开关右边显示的是节点的名称，和 层级管理器 中的节点显示名称一致。 节点属性 属性检查器 接下来会显示节点的属性，节点的属性排列在 Node 标题的下面，点击 Node 可以将节点的属性折叠或展开。 Node 标题右侧有一个节点设置按钮，可以重置节点属性或者重置节点属性和 所有组件属性的修改，或者粘贴复制的组件。 节点的属性除了位置（Position）、旋转（Rotation）、缩放（Scale）、尺寸（Size）等变换属性以外，还包括锚点（Anchor）、颜色（Color）、不透明度（Opacity）、倾角（Skew）等。修改节点的属性通常可以立刻在场景编辑器中看到节点的外观或位置变化。 组件属性 节点属性下面，会列出节点上挂载的所有组件和组件的属性。和节点属性一样，点击组件的名称就会切换该组件属性的折叠/展开状态。在节点上挂载了很多组件的情况下，可以通过折叠不常修改的组件属性来获得更大的工作区域。组件名称的右侧有帮助文档和组件设置的按钮。帮助文档按钮可以跳转到该组件相关的文档介绍页面，组件设置按钮可以对组件执行移除、重置、上移、下移、复制、粘贴等功能。 用户通过脚本创建的组件，其属性是由脚本声明的。不同类型的属性在 属性检查器 中有不同的控件外观和编辑方式。我们将在 声明属性 一节中详细介绍属性的定义方法。 编辑属性 属性 是组件脚本中声明的公开并可被序列化存储在场景和动画数据中的变量。通过 属性检查器 我们可以快捷的修改属性设置，达到不需要编程就可以调整游戏数据和玩法的目的。 通常可以根据变量使用内存位置不同将属性分为 值类型 和 引用类型 两大类。 值类型属性 值类型 包括数字、字符串、枚举等简单的占用很少内存的变量类型： 数值（Number）：可以直接使用键盘输入，也可以按输入框旁边的上下箭头逐步增减属性值。 向量（Vec2）：向量的控件是两个数值输入组合在一起，并且输入框上会以 x，y 标识每个数值对应的子属性名。 字符串（String）：直接在文本框里用键盘输入字符串，字符串输入控件分为单行和多行两种，多行文本框可以按回车换行。 布尔（Boolean）：以复选框的形式来编辑，选中状态表示属性值为 true，非选中状态表示 false。 枚举（Enum）：以下拉菜单的形式编辑，点击枚举菜单，然后从弹出的菜单列表里选择一项，即可完成枚举值的修改。 颜色（Color）：点击颜色属性预览框，会弹出 颜色选择器 窗口，在这个窗口里可以用鼠标直接点选需要的颜色，或在下面的 RGBA 颜色输入框中直接输入指定的颜色。点击 颜色选择器 窗口以外的任何位置会关闭窗口并以最后选定的颜色作为属性颜色。 引用类型属性 引用类型 包括更复杂的对象，比如节点、组件或资源。和值类型各式各样的编辑方式不同，引用类型通常只有一种编辑方式：拖拽节点或资源到属性栏中。 引用类型的属性在初始化后会显示 None，因为无法通过脚本为引用类型的属性设置初始值。这时可以根据属性的类型将相应类型的节点或资源拖拽上去，即可完成引用赋值。 需要拖拽节点来赋值的属性栏上会显示成标签，标签上可能会显示 cc.Node，表示任意节点都可以拖拽上去，或者标签显示组件名如 cc.AnimationComponent 等，这时需要拖拽挂载了相应组件的节点才行。 需要拖拽资源赋值的属性栏上会显示成标签，标签上显示的是资源的类型，如 prefab、texture 等。只要从 资源管理器 中拖拽相应类型的资源过来就可以完成赋值。 合并操作 属性检查器 内允许多选节点，同时修改多个节点上的属性。多选节点后，不一致的属性将会以 ui 组件 的 invalid 行为进行显示。 "},"editor/console/":{"url":"editor/console/","title":"控制台","keywords":"","body":"控制台 控制台 会显示报错、警告或其他编辑器和引擎生成的日志信息。不同重要级别的信息会以不同颜色显示。 关于日志 日志系统基于 js 的 console 模块。编辑器运行的时候，会捕获每一个进程里 console 打印出来的必要日志，并以颜色进行区分。 会被捕获的日志类型以及显示颜色： 日志（console.log）: 灰色文字，编辑器以及插件内开发者觉得有必要打印到控制台的内容。 警告（console.warn）: 黄色文字，程序运行遇到的不影响结果的异常情况。 错误（console.error）: 红色文字，运行中遇到的会影响结果的一场，必须解决的问题，或者是未被捕获的错误信息。 面板操作 控制台所有的功能都在顶部的一条工具栏上，从左到右的功能依次是： 清空当前控制台内的所有日志 打开日志记录文件 输入文本以过滤显示的日志 输入文本是否启用正则匹配 过滤显示的日志类型 其他设置 控制台的其他设置在偏好设置内，请参考 偏好设置 里的扩展设置。 "},"editor/animation/":{"url":"editor/animation/","title":"动画编辑器","keywords":"","body":"动画系统 本章将介绍 Cocos Creator 3D 的动画系统，除了标准的位移、旋转、缩放动画和序列帧动画以外，这套动画系统还支持任意组件属性和用户自定义属性的驱动，再加上可任意编辑的时间曲线和创新的移动轨迹编辑功能，能够让内容生产人员不写一行代码就制作出细腻的各种动态效果。 注意：Cocos Creator 3D 自带的动画编辑器适用于制作一些不太复杂的、需要与逻辑进行联动的动画，例如 UI 动画。如果要制作复杂的特效、角色动画、嵌套动画，可以考虑改用 Spine 或者 DragonBones 进行制作。 关于 Animation 熟悉动画编辑器 创建 Animation 组件和动画剪辑 编辑动画序列 制作帧动画 编辑动画曲线 动画事件 先从关于 Animation开始了解。 "},"editor/preferences/":{"url":"editor/preferences/","title":"偏好设置","keywords":"","body":"偏好设置 偏好设置 面板中提供了编辑器的个性化设置，要打开 偏好设置 面板，请从主菜单的 Cocos Creator 3D -> 偏好设置 菜单进入。 设置可以分成下列几部分： 通用设置 通用设置主要是针对编辑器相关的一些基础数据进行配置。 原生开发环境 原生开发环境内存储的是一些与引擎、开发、调试相关的配置信息。 数据编辑 数据编辑内存放的是一些与资源编辑、数据修改相关的配置。 扩展 插件内允许直接注入配置项目到偏好设置里。注册到偏好设置里的配置项就会显示在这里。 "},"editor/project/":{"url":"editor/project/","title":"项目设置","keywords":"","body":"项目设置 项目设置 面板通过主菜单的 项目 -> 项目设置 菜单打开，这里包括所有特定项目相关的设置。 项目设置分为全局设置和本地设置。 全局设置存放在 $HOME/profiles/packages/project-settings.json 本地设置存放在 $PROJECT/profies/packages/project-settings.json 我们可以通过每个菜单页面顶部的 local 进入本地配置，并且去除 Use Global 选项来使用本地项目配置。 如果需要在不同开发者之间同步项目设置，请将 $PROJECT/profies/packages/project-settings.json 目录加入到版本控制。 并且在每个编辑器上，去除 Use Global 选项，强制使用本地配置。 通用设置 通用设置主要是针对项目全局的一些基础数据进行配置。 项目预览 预览相关的一些配置信息。 模块设置 构建发布引擎的时候，打包进入最终发布包内的引擎模块设置。 引擎设置 自定义引擎、引擎内可选择的模块的一些配置。 "},"editor/components/":{"url":"editor/components/","title":"组件","keywords":"","body":"组件 Cocos Creator 3D 中包括以下功能组件： AudioSourceComponent ModelComponent SkinningModelComponent CameraComponent DirectionalLightComponent SphereLightComponent SpotLightComponent AnimationComponent BillboardComponent LineComponent ParticleSystemComponent BoxColliderComponent SphereColliderComponent RigidBodyComponent UI组件 继续前往 AudioSourceComponent 说明文档。 "},"engine/renderable/model-component.html":{"url":"engine/renderable/model-component.html","title":"ModelComponent","keywords":"","body":"模型组件 模型组件用于显示一个静态的3D模型。通过mesh设置模型网格，通过material改变模型外观。 属性 功能 mesh 用于渲染的3D模型资源。 materials 用于渲染模型的材质，一个材质对应mesh中的一个submesh。 shadowCastingMode 如果场景启用了平面阴影，则启用后会渲染平面阴影。 visibility 用于模型会被哪个摄像机渲染，只有visibility与模型相同的摄像机才会渲染该模型。 "},"editor/components/camera-component.html":{"url":"editor/components/camera-component.html","title":"CameraComponent","keywords":"","body":"相机组件 相机组件是我们用来呈现场景画面的重要功能组件。 属性名称 说明 ClearFlags 相机清空标识。包含：DONT_CLEAR：不清空；DEPTH_ONLY：只清空深度； SLOD_COLOR：清空颜色、深度与模板缓冲 Color 清空为指定的颜色 Depth 清空为指定的深度 Stencil 清空为指定的模板缓冲 Far 远裁剪距离 Near 近裁剪距离 Fov 视场角 OrthoHeight 正交相机的高度 Priority 优先级。在渲染流程中会优先渲染高优先级的相机 Projection 投影模式。分为 透视投影（PERSPECTIVE） 和 正交投影（ORTHO） Rect 相机的视口大小 Visibility 相机的可见性。用于控制不同模型在同一相机中的可见性。 "},"particle-system/billboard-component.html":{"url":"particle-system/billboard-component.html","title":"BillboardComponent","keywords":"","body":"Billboard组件 billboard组件用于渲染一个始终面向摄像机的方块。 属性 功能 height billboard的高度。 width billboard的宽度。 rotation billboard绕中心点旋转的角度。 texture billboard显示的贴图。 "},"particle-system/line-component.html":{"url":"particle-system/line-component.html","title":"LineComponent","keywords":"","body":"Line组件 Line组件用于渲染3D场景中给定的点连成的线段。Line组件渲染的线段是有宽度的，并且总是面向摄像机，这与billboard组件相似。 属性 功能 texture 线段中显示的贴图。 worldSpace 线段中各个点的坐标采用哪个坐标系，勾选使用世界坐标系，不选使用本地坐标系。 positions 每个线段端点的坐标。 wdith 线段宽度，如果采用曲线，则表示沿着线段方向上的曲线变化。 tile 贴图平铺次数。 offset 贴图坐标的偏移。 color 线段颜色，如果采用渐变色，则表示沿着线段方向上的颜色渐变。 "},"ui-system/components/editor/":{"url":"ui-system/components/editor/","title":"UI 组件","keywords":"","body":"常用 UI 控件 本篇文档将介绍 UI 系统中常用的控件，使用核心渲染组件和对齐策略，这些控件将构成我们游戏中 UI 的大部分交互部分。 在编辑器内，我们提供了一些常用的 UI 预设来方便自动创建 UI 节点，创建方式如下： 对于预设未设定的 UI 组件，可以通过选中节点在 Inspector 界面手动的方式来添加，操作如下： 组件目录 渲染组件 基础组件 "},"ui-system/components/editor/render-component.html":{"url":"ui-system/components/editor/render-component.html","title":"UI 渲染组件","keywords":"","body":"渲染组件介绍 SpriteComponent 介绍 LabelComponent 介绍 MaskComponent 介绍 LabelOutlineComponent 介绍 GraphicsComponent 介绍 RichTextComponent 介绍 UIModelComponent 介绍 "},"ui-system/components/editor/sprite.html":{"url":"ui-system/components/editor/sprite.html","title":"SpriteComponent 参考","keywords":"","body":"Sprite 组件参考 Sprite（精灵）是 2D 游戏中最常见的显示图像的方式，在节点上添加 Sprite 组件，就可以在场景中显示项目资源中的图片。 点击 属性检查器 下面的 添加组件 按钮，然后从 UI 中选择 Sprite，即可添加 Sprite 组件到节点上。 Sprite 属性 属性 功能说明 Color 图片颜色 SharedMaterial 用户自定义材质，没有设置则用内置材质 Priority 渲染排序优先级。详情参考渲染排序规则 Atlas Sprite 显示图片资源所属的图集（该功能会在稍后的版本里移除，改用碎图自动打包的方式）。 Sprite Frame 渲染 Sprite 使用的 SpriteFrame 图片资源。（Sprite Frame 后面的 编辑 按钮用于编辑图像资源的九宫格切分，详情请参考 使用 Sprite 编辑器制作九宫格图像） Type 渲染模式，包括普通（Simple）、九宫格（Sliced）、平铺（Tiled）、填充（Filled）和网格（Mesh）渲染五种模式 Size Mode 指定 Sprite 的尺寸Trimmed 表示会使用原始图片资源裁剪透明像素后的尺寸Raw 表示会使用原始图片未经裁剪的尺寸 Custom 表示会使用自定义尺寸。当用户手动修改过 Size 属性后，Size Mode 会被自动设置为 Custom，除非再次指定为前两种尺寸。 Trim 是否渲染原始图像周围的透明像素区域，详情请参考 图像资源的自动剪裁 Src Blend Factor 当前图像混合模式 Dst Blend Factor 背景图像混合模式，和上面的属性共同作用，可以将前景和背景 Sprite 用不同的方式混合渲染，效果预览可以参考 glBlendFunc Tool 添加 Sprite 组件之后，通过从 资源管理器 中拖拽 SpriteFrame 类型的资源到 Sprite Frame 属性引用中，就可以通过 Sprite 组件显示资源图像。 如果拖拽的 SpriteFrame 资源是包含在一个 Atlas 图集资源中的，那么 Sprite 的 Atlas 属性也会被一起设置。 若要动态更换 SpriteFrame 则需要先动态加载图片资源，然后再进行替换，详情请参考 获取和加载资源：动态加载。 渲染模式 Sprite 组件支持五种渲染模式： 普通模式（Simple）：按照原始图片资源样子渲染 Sprite，一般在这个模式下我们不会手动修改节点的尺寸，来保证场景中显示的图像和美术人员生产的图片比例一致。 九宫格模式（Sliced）：图像将被分割成九宫格，并按照一定规则进行缩放以适应可随意设置的尺寸(size)。通常用于 UI 元素，或将可以无限放大而不影响图像质量的图片制作成九宫格图来节省游戏资源空间。详细信息请阅读 使用 Sprite 编辑器制作九宫格图像 一节。 填充模式（Filled）：根据原点和填充模式的设置，按照一定的方向和比例绘制原始图片的一部分。经常用于进度条的动态展示。 填充模式（Filled） Type 属性选择填充模式后，会出现一组新的属性可供配置，让我们依次介绍他们的作用。 属性 功能说明 Fill Type 填充类型选择，有 HORIZONTAL（横向填充）、VERTICAL（纵向填充）和 RADIAL （扇形填充）三种。 Fill Start 填充起始位置的标准化数值（从 0 ~ 1，表示填充总量的百分比），选择横向填充时，Fill Start 设为 0，就会从图像最左边开始填充 Fill Range 填充范围的标准化数值（同样从 0 ~ 1），设为 1，就会填充最多整个原始图像的范围。 Fill Center 填充中心点，只有选择了 RADIAL 类型才会出现这个属性。决定了扇形填充时会环绕 Sprite 上的哪个点。 Fill Range 填充范围补充说明 在 HORIZONTAL 和 VERTICAL 这两种填充类型下，Fill Start 设置的数值将影响填充总量，如果 Fill Start 设为 0.5，那么即使 Fill Range 设为 1.0，实际填充的范围也仍然只有 Sprite 总大小的一半。 而 RADIAL 类型中 Fill Start 只决定开始填充的方向，Fill Start 为 0 时，从 x 轴正方向开始填充。Fill Range 决定填充总量，值为 1 时将填充整个圆形。Fill Range 为正值时逆时针填充，为负值时顺时针填充。 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/label.html":{"url":"ui-system/components/editor/label.html","title":"LabelComponent 参考","keywords":"","body":"Label 组件参考 Label 组件用来显示一段文字，文字可以是系统字体，TrueType 字体或者 BMFont 字体。另外，Label 还具有排版功能。 点击 属性检查器 下面的 添加组件 按钮，然后从 UI 中选择 Label，即可添加 Label 组件到节点上。 Label 属性 属性 功能说明 Color 图片颜色 SharedMaterial 用户自定义材质，没有设置则用内置材质 Priority 渲染排序优先级。详情参考渲染排序规则 String 文本内容字符串。 Horizontal Align 文本的水平对齐方式。可选值有 LEFT，CENTER 和 RIGHT。 Vertical Align 文本的垂直对齐方式。可选值有 TOP，CENTER 和 BOTTOM。 Font Size 文本字体大小。 Line Height 文本的行高。 Overflow 文本的排版方式，目前支持 CLAMP，SHRINK 和 RESIZE_HEIGHT。详情见下方的 Label 排版 或者 文字排版。 Enable Wrap Text 是否开启文本换行。（在排版方式设为 CLAMP、SHRINK 时生效） Font 指定文本渲染需要的字体文件，如果使用系统字体，则此属性可以为空。 Font Family 文字字体名字。在使用系统字体时生效。 Cache Mode 文本缓存类型（v2.0.9 中新增），仅对 系统字体 或 ttf 字体有效，BMFont 字体无需进行这个优化。包括 NONE、BITMAP、CHAR 三种模式。详情见下方的 文本缓存类型。 Use System Font 布尔值，是否使用系统字体。 IsBold 文字是否加粗，支持系统字以及部分 ttf。 IsItalic 文字是否倾斜，支持系统字以及 ttf。 IsUnderline 文字是否加下划线，支持系统字以及 ttf。 Src Blend Factor 当前渲染混合模式 Dst Blend Factor 背景混合模式，和上面的属性共同作用，可以将前景和背景渲染的文本用不同的方式混合，效果预览可以参考 glBlendFunc Tool Label 排版 属性 功能说明 CLAMP 文字尺寸不会根据 Content Size 的大小进行缩放，Wrap Text 关闭的情况下，按照正常文字排列，超出 Content Size 的部分将不会显示。Wrap Text 开启的情况下，会试图将本行超出范围的文字换行到下一行。如果纵向空间也不够时，也会隐藏无法完整显示的文字。 SHRINK 文字尺寸会根据 Content Size 大小进行自动缩放（不会自动放大，最大显示 Font Size 规定的尺寸），Wrap Text 开启时，当宽度不足时会优先将文字换到下一行，如果换行后还无法完整显示，则会将文字进行自动适配 Content Size 的大小。如果 Wrap Text 关闭时，则直接按照当前文字进行排版，如果超出边界则会进行自动缩放。 RESIZE_HEIGHT 文本的 Content Size 会根据文字排版进行适配，这个状态下用户无法手动修改文本的高度，文本的高度由内部算法自动计算出来。 文本缓存类型（Cache Mode） 属性 功能说明 NONE 默认值，Label 中的整段文本将生成一张位图。 BITMAP 选择后，Label 中的整段文本仍将生成一张位图。只要满足动态合图的要求，就会和动态合图中的其它 Sprite 或者 Label 合并 Draw Call。由于动态合图会占用更多内存，该模式只能用于文本不常更新的 Label。 CHAR 原理类似 BMFont，Label 将以“字”为单位将文本缓存到全局共享的位图中，相同字体样式和字号的每个字符将在全局共享一份缓存。能支持文本的频繁修改，对性能和内存最友好。不过目前该模式还存在如下限制，我们将在后续的版本中进行优化：1、该模式只能用于字体样式和字号（通过记录字体的 fontSize、fontFamily、color、outline 为关键信息，以此进行字符的重复使用，其他有使用特殊自定义文本格式的需要注意）固定，并且不会频繁出现巨量未使用过的字符的 Label。这是为了节约缓存，因为全局共享的位图尺寸为 2048*2048，只有场景切换时才会清除，一旦位图被占满后新出现的字符将无法渲染。2、Overflow 不支持 SHRINK。3、不能参与动态合图（同样启用 CHAR 模式的多个 Label 在渲染顺序不被打断的情况下仍然能合并 Draw Call） 注意： Cache Mode 对所有平台都有优化效果。 详细说明 Label 组件可以通过往 属性检查器 里的 Font 属性拖拽 TTF 字体文件和 BMFont 字体文件来修改渲染的字体类型。如果不想继续使用字体文件，可以通过勾选 Use System Font 来重新启用系统字体。 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/mask.html":{"url":"ui-system/components/editor/mask.html","title":"MaskComponent 参考","keywords":"","body":"Mask（遮罩）组件参考 Mask 用于规定子节点可渲染的范围，带有 Mask 组件的节点会使用该节点的约束框（也就是 属性检查器 中 Node 组件的 Size 规定的范围）创建一个矩形渲染遮罩，该节点的所有子节点都会依据这个遮罩进行裁剪，遮罩范围外的将不会渲染。 点击 属性检查器 下面的 添加组件 按钮，然后从 UI 中选择 Mask，即可添加 Mask 组件到节点上。注意该组件不能添加到有其他渲染组件（如 Sprite、Label 等）的节点上。 只有当模板像素的 alpha 值大于该值时，才会绘制内容。该属性的取值范围是 0 ~ 1，1 表示完全禁用。 | Sprite Frame | 遮罩所需要的贴图，只在遮罩类型设为 **IMAGE_STENCIL** 时生效 | Segements | 椭圆遮罩的曲线细分数，只在遮罩类型设为 **ELLIPSE** 时生效 --> 注意：节点添加了 Mask 组件之后，所有在该节点下的子节点，在渲染的时候都会受 Mask 影响。 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/label-outline.html":{"url":"ui-system/components/editor/label-outline.html","title":"LabelOutlineComponent 参考","keywords":"","body":"LabelOutline 文字外发光组件参考 为除了 bmfont 的字体提供额外描边效果。 LabelOutline 属性 属性 功能说明 Color 字体发光边缘颜色 Width 字体发光边缘宽度 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/graphics.html":{"url":"ui-system/components/editor/graphics.html","title":"GraphicsComponent 参考","keywords":"","body":"Graphics 组件参考 Graphics 组件提供了一系列绘画接口，这些接口参考了 canvas 的绘画接口来进行实现。 新建一个空节点，然后点击 属性检查器 下方的 添加组件 按钮，从 添加渲染组件 中选择 Graphics，即可添加 Graphics 组件到节点上。 路径 方法 功能说明 moveTo (x, y) 把路径移动到画布中的指定点，不创建线条 lineTo (x, y) 添加一个新点，然后在画布中创建从该点到最后指定点的线条 bezierCurveTo (c1x, c1y, c2x, c2y, x, y) 创建三次方贝塞尔曲线 quadraticCurveTo (cx, cy, x, y) 创建二次贝塞尔曲线 arc (cx, cy, r, a0, a1, counterclockwise) 创建弧/曲线（用于创建圆形或部分圆） ellipse (cx, cy, rx, ry) 创建椭圆 circle (cx, cy, r) 创建圆形 rect (x, y, w, h) 创建矩形 close () 创建从当前点回到起始点的路径 stroke () 绘制已定义的路径 fill () 填充当前绘图（路径） clear () 清楚所有路径 颜色，样式 属性 功能说明 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 strokeColor 设置或返回笔触的颜色 fillColor 设置或返回填充绘画的颜色 更多关于 Graphics 的信息请前往 绘画 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/richtext.html":{"url":"ui-system/components/editor/richtext.html","title":"RichTextComponent 参考","keywords":"","body":"RichText 组件参考 RichText 组件用来显示一段带有不同样式效果的文字，你可以通过一些简单的 BBCode 标签来设置文字的样式。 目前支持的样式有：颜色(color)，字体大小(size)，字体描边(outline)，加粗(b)，斜体(i)，下划线(u)，换行(br)，图片(img)和点击事件(on)，并且不同的 BBCode 标签是可以支持相互嵌套的。 更多关于 BBCode 标签的内容，请参考本文档的 BBCode 标签格式说明 小节。 点击 属性检查器 下面的添加组件按钮，然后从添加渲染组件中选择 RichText，即可添加 RichText 组件到节点上。 RichText 属性 属性 功能说明 String 富文本的内容字符串, 你可以在里面使用 BBCode 来指定特定文本的样式 Horizontal Align 水平对齐方式 Font Size 字体大小, 单位是 point （注意，该字段不会影响 BBCode 里面设置的字体大小） Font 富文本定制字体，所有的 label 片断都会使用这个定制的 TTF 字体 Line Height 字体行高, 单位是 point Max Width 富文本的最大宽度, 传 0 的话意味着必须手动换行. Image Atlas 对于 img 标签里面的 src 属性名称，都需要在 imageAtlas 里面找到一个有效的 spriteFrame，否则 img tag 会判定为无效。 Handle Touch Event 选中此选项后，RichText 将阻止节点边界框中的所有输入事件（鼠标和触摸），从而防止输入事件穿透到底层节点。 BBCode 标签格式 基本格式 目前支持的标签类型有：size，color, b, i, u, img 和 on，分别用来定制字体大小，字体颜色, 加粗，斜体，下划线，图片和点击事件。 每一个标签都有一个起始标签和一个结束标签，起始标签的名字和属性格式必要符合要求，且全部为小写。 结束标签的名字不做任何检查，只需要满足结束标签的定义即可。 下面分别是应用 size 和 color 标签的一个例子： 你好，Creator 支持标签 注意：所有的 tag 名称必须是小写，且属性值是用=号赋值 名称 描述 示例 注意事项 color 指定字体渲染颜色，颜色值可以是内置颜色，比如 white，black 等，也可以使用 16 进制颜色值，比如#ff0000 表示红色 Red Text size 指定字体渲染大小，大小值必须是一个整数 enlarge me Size 值必须使用等号赋值 outline 设置文本的描边颜色和描边宽度 A label with outline 如果你没有指定描边的颜色或者宽度的话，那么默认的颜色是白色(#ffffff),默认的宽度是 1 b 指定使用粗体来渲染 This text will be rendered as bold 名字必须是小写，且不能写成 bold i 指定使用斜体来渲染 This text will be rendered as italic 名字必须是小写，且不能写成 italic u 给文本添加下划线 This text will have a underline 名字必须是小写，且不能写成 underline on 指定一个点击事件处理函数，当点击该 Tag 所在文本内容时，会调用该事件响应函数 click me! 除了 on 标签可以添加 click 属性，color 和 size 标签也可以添加，比如 click me param 当点击事件触发时，可以在回调函数的第二个参数获取该数值 click me! 依赖 click 事件 br 插入一个空行 注意： 和 都是不支持的。 img 给富文本添加图文混排功能，img 的 src 属性必须是 ImageAtlas 图集里面的一个有效的 spriteframe 名称 注意: 只有 这种写法是有效的。如果你指定一张很大的图片，那么该图片创建出来的精灵会被等比缩放，缩放的值等于富文本的行高除以精灵的高度。 标签与标签是支持嵌套的，且嵌套规则跟 HTML 是一样的。比如下面的嵌套标签设置一个文本的渲染大小为 30，且颜色为绿色。 I'm green 也可以实现为: I'm green 有以下两种方式可以设置 RichText 的颜色： 选中节点，在 属性检查器 的 RichTextComponent -> Color 中设置 RichText 的整体颜色 使用 bbcode 对 RichText 内部分别设置颜色 注意：两者不可混用，如果混用了，将以第一种方式设置的颜色为准。 详细说明 富文本组件全部由 JS 层实现，采用底层的 Label 节点拼装而成，并且在上层做排版逻辑。 这意味着，你新建一个复杂的富文本，底层可能有十几个 label 节点，而这些 label 节点都是采用系统字体渲染的， 所以，一般情况下，你不应该在游戏的主循环里面频繁地修改富文本的文本内容, 这可能会导致性能比较低。 另外，如果能不使用富文本组件，就尽量使用普通的文本组件，并且 BMFont 的效率是最高的。 其他渲染模块参考 基础模块参考 "},"ui-system/components/editor/base-component.html":{"url":"ui-system/components/editor/base-component.html","title":"UI 基础组件","keywords":"","body":"基础 UI 组件介绍 CanvasComponent 介绍 UITransformComponent 介绍 WidgetComponent 介绍 ButtonComponent 介绍 LayoutComponent 组件介绍 EditBoxComponent 组件介绍 ScrollViewComponent 组件介绍 ScrollBarComponent 组件介绍 ProgressBarComponent 组件介绍 ToggleComponent 组件介绍 ToggleGroupComponent 组件介绍 SliderComponent 组件介绍 "},"ui-system/components/editor/canvas.html":{"url":"ui-system/components/editor/canvas.html","title":"CanvasComponent 参考","keywords":"","body":"Canvas（画布）组件参考 Canvas（画布） 组件能够随时获得设备屏幕的实际分辨率并对场景中所有渲染元素进行适当的缩放。场景中的 Canvas 可以有多个，所有 UI 元素都必须在 Canvas 及其子节点下才能被渲染，Canvas 的设计分辨率和适配方案统一通过项目配置获取。在 Canvas 内部会自带一个相机，默认照射 z 轴方向是从 0 - 1000，所以针对 UI 上的 z 轴设计必须在这个范围内才能正常显示。 Canvas 组件不仅是 UI 渲染的根节点，同时在游戏制作时还有一个很重要的功能在多分辨率适配方案，具体请参考多分辨率适配方案。 Canvas 属性 属性 功能说明 priority 跟其余 Canvas 做排序使用。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/ui-reorder-component.html":{"url":"ui-system/components/editor/ui-reorder-component.html","title":"UIReorderComponent 参考","keywords":"","body":"UIReorderComponent 渲染排序组件 组件提供用于非渲染组件但是可能涉及到其子节点需要进行优先级排序的节点使用，该组件与渲染组件不可并存。 UITransform 属性介绍 属性 功能说明 Priority 渲染排序优先级。详情参考渲染排序规则 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/ui-transform.html":{"url":"ui-system/components/editor/ui-transform.html","title":"UITransformComponent 参考","keywords":"","body":"UI 变换组件 Cocos Creator 3D 大多数的节点变换操作已经在节点在节点上完成，对于 UI 部分由于涉及到 UI 尺寸以及 UI 锚点问题，所以衍生出了 UI 变换组件。一般用于点击事件的计算，以及适配的作用。 UITransform 属性介绍 属性 功能说明 ContentSize UI 内容尺寸 AnchorPoint UI 锚点位置 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/widget.html":{"url":"ui-system/components/editor/widget.html","title":"WidgetComponent 参考","keywords":"","body":"Widget 组件参考 Widget (对齐挂件) 是一个很常用的 UI 布局组件。它能使当前节点自动对齐到父物体的任意位置，或者约束尺寸，让你的游戏可以方便地适配不同的分辨率。对齐方案详细说明请参考对齐方案 选项 选项 说明 备注 Top 对齐上边界 选中后，将在旁边显示一个输入框，用于设定当前节点的上边界和父物体的上边界之间的距离。 Bottom 对齐下边界 选中后，将在旁边显示一个输入框，用于设定当前节点的下边界和父物体的下边界之间的距离。 Left 对齐左边界 选中后，将在旁边显示一个输入框，用于设定当前节点的左边界和父物体的左边界之间的距离。 Right 对齐右边界 选中后，将在旁边显示一个输入框，用于设定当前节点的右边界和父物体的右边界之间的距离。 HorizontalCenter 水平方向居中 VerticalCenter 竖直方向居中 Target 对齐目标 指定对齐参照的节点，当这里未指定目标时会使用直接父级节点作为对齐目标 Align Mode 指定 widget 的对齐方式，用于决定运行时 widget 应何时更新 通常设置为 ALWAYS，每次节点产生变动时重新对齐。设置为 ONCE 时，仅在组件初始化时进行一次对齐。 对齐边界 我们可以在 Canvas 下新建一个 sprite，在 sprite 节点上添加一个 Widget 组件，然后做如下一些测试： 左对齐，左边界距离 100 px： 下对齐，下边界距离 50%： 百分比将以父节点的宽或高作为基准 右下对齐，边界距离 0 px： 居中对齐 水平方向居中： 竖直方向居中，并且右边界距离 50%： 约束尺寸 如果左右同时对齐，或者上下同时对齐，那么在相应方向上的尺寸就会被拉伸。 下面演示一下，在场景中放置两个矩形 Sprite，大的作为对话框背景，小的作为对话框上的按钮。按钮节点作为对话框的子节点，并且按钮设置成 Sliced 模式以便展示拉伸效果。 宽度拉伸，左右边距 10%： 高度拉伸，上下边距 0，同时水平居中： 水平和竖直同时拉伸，边距 50 px： 对节点位置、尺寸的限制 如果 Align Mode 属性设为 ALWAYS 时，会在运行时每帧都按照设置的对齐策略进行对齐，组件所在节点的位置（position）和尺寸（width，height）属性可能会被限制，不能通过 API 或动画系统自由修改。这是因为通过 Widget 对齐是在每帧的最后阶段进行处理的，因此对 Widget 组件中已经设置了对齐的相关属性进行设置，最后都会被 Widget 组件本身的更新所重置。 如果需要同时满足对齐策略和可以在运行时改变位置和尺寸的需要，可以通过以下两种方式实现： 确保 Widget 组件的 Align Mode 属性设置为 ONCE，该属性只会负责在组件初始化（onEnable）时进行一次对齐，而不会每帧再进行一次对齐。可以在初始化时自动完成对齐，然后就可以通过 API 或动画系统对 UI 进行移动变换了。 通过调用 Widget 组件的对齐边距 API，包括 top、 bottom、 left、 right，直接修改 Widget 所在节点的位置或某一轴向的拉伸。这些属性也可以在动画编辑器中添加相应关键帧，保证对齐的同时实现各种丰富的 UI 动画。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/button.html":{"url":"ui-system/components/editor/button.html","title":"ButtonComponent 参考","keywords":"","body":"Button（按钮）组件参考 Button 组件可以响应用户的点击操作，当用户点击 Button 时，Button 自身会有状态变化。另外，Button 还可以让用户在完成点击操作后响应一个自定义的行为。 点击 属性检查器 下面的 添加组件 按钮，然后从 添加 UI 组件 中选择 Button，即可添加 Button 组件到节点上。 Button 属性 属性 功能说明 Target Node 类型，当 Button 发生 Transition 的时候，会相应地修改 Target 节点的 SpriteFrame，颜色或者 Scale。 interactable 布尔类型，设为 false 时，则 Button 组件进入禁用状态。 Transition 枚举类型，包括 NONE, COLOR，SPRITE 和 SCALE。每种类型对应不同的 Transition 设置。详情见下方的 Button Transition 部分。 Click Event 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Button 事件 部分。 Button Transition Button 的 Transition 用来指定当用户点击 Button 时的状态表现。目前主要有 NONE，COLOR，SPRITE 和 SCALE。 Color Transition 属性 功能说明 Normal Button 在 Normal 状态下的颜色。 Pressed Button 在 Pressed 状态下的颜色。 Hover Button 在 Hover 状态下的颜色。 Disabled Button 在 Disabled 状态下的颜色。 Duration Button 状态切换需要的时间间隔。 Sprite Transition 属性 功能说明 Normal Button 在 Normal 状态下的 SpriteFrame。 Pressed Button 在 Pressed 状态下的 SpriteFrame。 Hover Button 在 Hover 状态下的 SpriteFrame。 Disabled Button 在 Disabled 状态下的 SpriteFrame。 Scale Transition 属性 功能 Duration Button 状态切换需要的时间间隔。 ZoomScale 当用户点击按钮后，按钮会缩放到一个值，这个值等于 Button 原始 scale * zoomScale, zoomScale 可以为负数 详细说明 Button 目前只支持 Click 事件，即当用户点击并释放 Button 时才会触发相应的回调函数。 组件事件结构 属性 功能说明 Target 带有脚本组件的节点。 Component 脚本组件名称。 Handler 指定一个回调函数，当用户点击 Button 并释放时会触发此函数。 CustomEventData 用户指定任意的字符串作为事件回调的最后一个参数传入。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 cc.Component.EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, ButtonComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const clickEventHandler = new cc.Component.EventHandler(); clickEventHandler.target = this.node; //这个 node 节点是你的事件处理代码组件所属的节点 clickEventHandler.component = 'example';//这个是代码文件名 clickEventHandler.handler = 'callback'; clickEventHandler.customEventData = 'foobar'; const button = this.node.getComponent(ButtonComponent); button.clickEvents.push(clickEventHandler); } callback(event: Event, customEventData: string){ //这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 const node = event.target as Node; const button = node.getComponent(ButtonComponent); console.log(customEventData); // foobar } } 方法二 通过 button.node.on('click', ...) 的方式来添加，这是一种非常简便的方式，但是该方式有一定的局限性，在事件回调里面无法 获得当前点击按钮的屏幕坐标点。 //假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, ButtonComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(ButtonComponent) button: ButtonComponent | null = null; onLoad(){ this.button.node.on('click', this.callback, this); } callback(button: ButtonComponent){ // 注意这种方式注册的事件，无法传递 customEventData } } 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/layout.html":{"url":"ui-system/components/editor/layout.html","title":"LayoutComponent 组件参考","keywords":"","body":"Layout 组件参考 Layout 是一种容器组件，容器能够开启自动布局功能，自动按照规范排列所有子物体，方便用户制作列表、翻页等功能。 水平布局容器 垂直布局容器 网格布局容器 点击 属性检查器 下面的 添加组件 按钮，然后从 添加 UI 组件 中选择 Layout，即可添加 Layout 组件到节点上。 Layout 属性 属性 功能说明 Type 布局类型，支持 NONE, HORIZONTAL，VERTICAL 和 GRID。请参考详自动布局。 ResizeMode 缩放模式，支持 NONE，CHILDREN 和 CONTAINER。 PaddingLeft 排版时，子物体相对于容器左边框的距离。 PaddingRight 排版时，子物体相对于容器右边框的距离。 PaddingTop 排版时，子物体相对于容器上边框的距离。 PaddingBottom 排版时，子物体相对于容器下边框的距离。 SpacingX 水平排版时，子物体与子物体在水平方向上的间距。NONE 模式无此属性。 SpacingY 垂直排版时，子物体与子物体在垂直方向上的间距。NONE 模式无此属性。 Horizontal Direction 指定水平排版时，第一个子节点从容器的左边还是右边开始布局。当容器为 Grid 类型时，此属性和 Start Axis 属性一起决定 Grid 布局元素的起始水平排列方向。 Vertical Direction 指定垂直排版时，第一个子节点从容器的上面还是下面开始布局。当容器为 Grid 类型时，此属性和 Start Axis 属性一起决定 Grid 布局元素的起始垂直排列方向。 Cell Size 此属性只在 Grid 布局时存在，指定网格容器里面排版元素的大小。 Start Axis 此属性只在 Grid 布局时存在，指定网格容器里面元素排版指定的起始方向轴。 详细说明 添加 Layout 组件之后，默认的布局类型是 NONE，它表示容器不会修改子物体的大小和位置，当用户手动摆放子物体时，容器会以能够容纳所有子物体的最小矩形区域作为自身的大小。 通过修改 属性检查器 里面的 Type 可以切换布局容器的类型，可以切换成水平，垂直或者网格布局。 另外，所有的容器均支持 ResizeMode（NONE 容器只支持 NONE 和 CONTAINER）。 当 ResizeMode 设置为 NONE 时，子物体和容器的大小变化互不影响。 设置为 CHILDREN 则子物体大小会随着容器的大小而变化。 设置为 CONTAINER 则容器的大小会随着子物体的大小变化。 在使用网格布局时，当 Start Axis 设置为 HORIZONTAL 时, 将在新行开始之前填充整行。设置为 VERTICAL 时, 它将在新列开始之前填充整个列。 注意：Layout 设置后的结果需要到下一帧才会更新，除非你设置完以后手动调用 updateLayout API。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/editbox.html":{"url":"ui-system/components/editor/editbox.html","title":"EditBoxComponent 组件参考","keywords":"","body":"EditBox 组件参考 EditBox 是一种文本输入组件，该组件让你可以轻松获取用户输入的文本。 点击 属性检查器 下面的 添加组件 按钮，然后从 添加 UI 组件 中选择 EditBox，即可添加 EditBox 组件到节点上。 EditBox 属性 属性 功能说明 String 输入框的初始输入内容，如果为空则会显示占位符的文本 Placeholder 输入框占位符的文本内容 Background 输入框背景节点上挂载的 Sprite 组件对象 TextLabel 输入框输入文本节点上挂载的 Label 组件对象 PlaceholderLabel 输入框占位符节点上挂载的 Label 组件对象 Keyboard Return Type 指定移动设备上面回车按钮的样式 Input Flag 指定输入标识：可以指定输入方式为密码或者单词首字母大写（仅支持 Android 平台） Input Mode 指定输入模式: ANY 表示多行输入，其它都是单行输入，移动平台上还可以指定键盘样式。 MaxLength 输入框最大允许输入的字符个数 TabIndex 修改 DOM 输入元素的 tabIndex，这个属性只有在 Web 上面修改有意义。 EditBox 事件 事件结构参考：组件事件结构 Editing Did Began：该事件在用户点击输入框获取焦点的时候被触发。 Editing Did Ended：在单行模式下面，一般是在用户按下回车或者点击屏幕输入框以外的地方调用该函数。 如果是多行输入，一般是在用户点击屏幕输入框以外的地方调用该函数。 Editing Return：该事件在用户按下回车键的时候被触发, 如果是单行输入框，按回车键还会使输入框失去焦点。 Text Changed：该事件在用户每一次输入文字变化的时候被触发。 详细说明 Keyboard Return Type 特指在移动设备上面进行输入的时候，弹出的虚拟键盘上面的回车键样式。 如果需要输入密码，则需要把 Input Flag 设置为 password，同时 Input Mode 必须是 Any 之外的选择，一般选择 Single Line。 如果要输入多行，可以把 Input Mode 设置为 Any。 背景图片支持九宫格缩放 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 cc.Component.EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, EditBoxComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { const editboxEventHandler = new cc.Component.EventHandler(); editboxEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 editboxEventHandler.component = 'example'; editboxEventHandler.handler = 'onEditDidBegan'; editboxEventHandler.customEventData = 'foobar'; const editbox = this.node.getComponent(EditBoxComponent); editbox.editingDidBegan.push(editboxEventHandler); // 你也可以通过类似的方式来注册其它回调函数 // editbox.editingDidEnded.push(editboxEventHandler); // editbox.textChanged.push(editboxEventHandler); // editbox.editingReturn.push(editboxEventHandler); } onEditDidBegan(editbox, customEventData) { // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } // 假设这个回调是给 editingDidEnded 事件的 onEditDidEnded(editbox, customEventData) { // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } // 假设这个回调是给 textChanged 事件的 onTextChanged(text, editbox, customEventData) { // 这里的 text 表示 修改完后的 EditBox 的文本内容 // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } // 假设这个回调是给 editingReturn 事件的 onEditingReturn(editbox, customEventData) { // 这里 editbox 是一个 cc.EditBox 对象 // 这里的 customEventData 参数就等于你之前设置的 \"foobar\" } 方法二 通过 editbox.node.on('editing-did-began', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, EditBoxComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(EditBoxComponent) editbox: EditBoxComponent | null = null; onLoad(){ this.editbox.node.on('editing-did-began', this.callback, this); } callback(editbox: EditBoxComponent){ // 回调的参数是 editbox 组件，注意这种方式注册的事件，无法传递 customEventData } } 同样的，你也可以注册 editing-did-ended, text-changed 和 editing-return 事件，这些事件的回调函数的参数与 editing-did-began 的参数一致。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/scrollview.html":{"url":"ui-system/components/editor/scrollview.html","title":"ScrollViewComponent 组件参考","keywords":"","body":"ScrollView 组件参考 ScrollView 是一种带滚动功能的容器，它提供一种方式可以在有限的显示区域内浏览更多的内容。通常 ScrollView 会与 Mask 组件配合使用，同时也可以添加 ScrollBar 组件来显示浏览内容的位置。 点击 属性检查器 下面的 添加组件 按钮，然后从 添加 UI 组件 中选择 ScrollView，即可添加 ScrollView 组件到节点上。 ScrollView 属性 属性 功能说明 content 它是一个节点引用，用来创建 ScrollView 的可滚动内容，通常这可能是一个包含一张巨大图片的节点。 Horizontal 布尔值，是否允许横向滚动。 Vertical 布尔值，是否允许纵向滚动。 Inertia 滚动的时候是否有加速度。 Brake 浮点数，滚动之后的减速系数。取值范围是 0-1，如果是 1 则立马停止滚动，如果是 0，则会一直滚动到 content 的边界。 Elastic 布尔值，是否回弹。 Bounce Duration 浮点数，回弹所需要的时间。取值范围是 0-10。 Horizontal ScrollBar 它是一个节点引用，用来创建一个滚动条来显示 content 在水平方向上的位置。 Vertical ScrollBar 它是一个节点引用，用来创建一个滚动条来显示 content 在垂直方向上的位置 ScrollView Events 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Scrollview 事件 CancelInnerEvents 如果这个属性被设置为 true，那么滚动行为会取消子节点上注册的触摸事件，默认被设置为 true。 ScrollView 事件 事件结构参考：组件事件结构 Scrollview 的事件回调有两个参数，第一个参数是 ScrollView 本身，第二个参数是 ScrollView 的事件类型。 ScrollBar 设置 ScrollBar 是可选的，你可以选择只设置 Horizontal ScrollBar 或者 Vertical ScrollBar，当然也可以两者都设置。建立关联可以通过在 层级管理器 里面拖拽一个带有 ScrollBar 组件的节点到 ScrollView 的相应字段完成。 详细说明 ScrollView 组件必须有指定的 content 节点才能起作用，通过指定滚动方向和 content 节点在此方向上的长度来计算滚动时的位置信息，Content 节点也可以通过添加 WidgetComponnet 设置自动 resize，也可以通过添加 LayoutComponnet 来完成子节点布局，但是这两个组件不应该同时添加到一个节点上以避免产生不可预料的后果。 通常一个 ScrollView 的节点树如下图： 这里的 view 用来定义一个可以显示的滚动区域，所以通常 MaskComponent 组件会被添加到 view 上。可以滚动的内容可以直接放到 content 节点或者添加节 content 的子节点上。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 cc.Component.EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, ScrollViewComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad() { const scrollViewEventHandler = new cc.Component.EventHandler(); scrollViewEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 scrollViewEventHandler.component = 'example';// 这个是代码文件名 scrollViewEventHandler.handler = 'callback'; scrollViewEventHandler.customEventData = 'foobar'; const scrollview = this.node.getComponent(ScrollViewComponent); scrollview.scrollEvents.push(scrollViewEventHandler); } callback(scrollview, eventType, customEventData){ // 这里 scrollview 是一个 Scrollview 组件对象实例 // 这里的 eventType === cc.ScrollViewComponent.EventType enum 里面的值 // 这里的 customEventData 参数就等于你之前设置的 'foobar' } } 方法二 通过 scrollview.node.on('scroll-to-top', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, ScrollViewComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(ScrollViewComponent) scrollview: ScrollViewComponent | null = null; onLoad(){ this.scrollview.node.on('scroll-to-top', this.callback, this); } callback(scrollView: ScrollViewComponent){ // 回调的参数是 ScrollView 组件，注意这种方式注册的事件，无法传递 customEventData } } 同样的，你也可以注册 scrolling, touch-up, scroll-began 等事件，这些事件的回调函数的参数与 scroll-to-top 的参数一致。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/scrollbar.html":{"url":"ui-system/components/editor/scrollbar.html","title":"ScrollBarComponent 组件参考","keywords":"","body":"ScrollBar 组件参考 ScrollBar 允许用户通过拖动滑块来滚动一张图片（公测版本暂不支持），它与 Slider 组件有点类似，但是它主要是用于滚动而 Slider 则用来设置数值。 点击 属性检查器 下面的 添加组件 按钮，然后从 添加 UI 组件 中选择 ScrollBar，即可添加 ScrollBar 组件到节点上。 ScrollBar 属性 属性 功能说明 Handle ScrollBar 前景图片，它的长度/宽度会根据 ScrollView 的 content 的大小和实际显示区域的大小来计算。 Direction 滚动方向，目前包含水平和垂直两个方向。 Enable Auto Hide 是否开启自动隐藏，如果开启了，那么在 ScrollBar 显示后的 Auto Hide Time 时间内会自动消失。 Auto Hide Time 自动隐藏时间，需要配合设置 Enable Auto Hide 详细说明 ScrollBar 一般不会单独使用，它需要与 ScrollView 配合使用，另外 ScrollBar 需要指定一个 Sprite 组件，即属性面板里面的 Handle。 通常我们还会给 ScrollBar 指定一张背景图片，用来指示整个 ScrollBar 的长度或者宽度。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/progress.html":{"url":"ui-system/components/editor/progress.html","title":"ProgressBarComponent 组件参考","keywords":"","body":"ProgressBar 组件参考 ProgressBar（进度条）经常被用于在游戏中显示某个操作的进度，在节点上添加 ProgressBar 组件，然后给该组件关联一个 Bar Sprite 就可以在场景中控制 Bar Sprite 来显示进度了。 点击 属性检查器 下面的添加组件按钮，然后从添加 UI 组件中选择ProgressBar，即可添加 ProgressBar 组件到节点上。 ProgressBar 属性 属性 功能说明 Bar Sprite 进度条渲染所需要的 Sprite 组件，可以通过拖拽一个带有 Sprite组件的节点到该属性上来建立关联。 Mode 支持 HORIZONTAL（水平）、VERTICAL（垂直）和 FILLED（填充）三种模式，可以通过配合 reverse 属性来改变起始方向。 Total Length 当进度条为 100%时 Bar Sprite 的总长度/总宽度。在 FILLED 模式下 Total Length 表示取 Bar Sprite 总显示范围的百分比，取值范围从 0 ~ 1。 Progress 浮点，取值范围是 0~1，不允许输入之外的数值。 Reverse 布尔值，默认的填充方向是从左至右/从下到上，开启后变成从右到左/从上到下。 详细说明 添加 ProgressBar 组件之后，通过从 层级管理器 中拖拽一个带有Sprite组件的节点到 Bar Sprite 属性上，此时便可以通过拖动 progress 滑块来控制进度条的显示了。 Bar Sprite 可以是自身节点，子节点，或者任何一个带有Sprite组件的节点。另外，Bar Sprite 可以自由选择 Simple、Sliced 和 Filled 渲染模式。 进度条的模式选择 FILLED 的情况下，Bar Sprite 的 Type 也需要设置为 FILLED，否则会报警告。 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/toggle.html":{"url":"ui-system/components/editor/toggle.html","title":"ToggleComponent 组件参考","keywords":"","body":"Toggle 组件参考 Toggle 是一个 CheckBox，当它和 ToggleGroup 一起使用的时候，可以变成 RadioButton。 点击 属性检查器 下面的 添加组件 按钮，然后从 添加 UI 组件 中选择 Toggle，即可添加 Toggle 组件到节点上。 Toggle 属性 属性 功能说明 isChecked 布尔类型，如果这个设置为 true，则 check mark 组件会处于 enabled 状态，否则处于 disabled 状态。 checkMark cc.SpriteComponent 类型，Toggle 处于选中状态时显示的图片 toggleGroup cc.ToggleContainerComponent 类型， Toggle 所属的 ToggleGroup，这个属性是可选的。如果这个属性为 null，则 Toggle 是一个 CheckBox，否则，Toggle 是一个 RadioButton。 Check Events 列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。详情见下方的 Toggle 事件 部分 注意：因为 Toggle 继承自 Button，所以关于 Toggle 的 Button 相关属性的详细说明和用法请参考 Button 组件。 Toggle 事件 事件结构参考：组件事件结构 | Toggle 的事件回调有二个参数，第一个参数是 Toggle 本身, 第二个参数是 customEventData。 详细说明 Toggle 组件的节点树一般为： 这里需要注意的是，checkMark 组件所在的节点需要放在 background 节点的上面。 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 cc.Component.EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, ToggleComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const checkEventHandler = new cc.Component.EventHandler(); checkEventHandler.target = this.node; //这个 node 节点是你的事件处理代码组件所属的节点 checkEventHandler.component = 'example';//这个是代码文件名 checkEventHandler.handler = 'callback'; checkEventHandler.customEventData = 'foobar'; const toggle = this.node.getComponent(ToggleComponent); toggle.checkEvents.push(checkEventHandler); } callback(event: Event, customEventData: string){ //这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 // 这里的 customEventData 参数就等于之前设置的 'foobar' } } 方法二 通过 toggle.node.on('toggle', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, ToggleComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(ToggleComponent) toggle: ToggleComponent | null = null; onLoad(){ this.toggle.node.on('toggle', this.callback, this); } callback(toggle: ToggleComponnet){ // 回调的参数是 toggle 组件，注意这种方式注册的事件，无法传递 customEventData } } 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/toggleContainer.html":{"url":"ui-system/components/editor/toggleContainer.html","title":"ToggleContainerComponent 组件参考","keywords":"","body":"ToggleContainer 组件参考 ToggleContainer 不是一个可见的 UI 组件，它可以用来修改一组 Toggle 组件的行为。当一组 Toggle 属于同一个 ToggleContainer 的时候，任何时候只能有一个 Toggle 处于选中状态。 注意：所有包含 Toggle 组件的一级子节点都会自动被添加到该容器中 点击 属性检查器 下面的 添加组件 按钮，然后从 添加 UI 组件 中选择 ToggleContainer，即可添加 ToggleContainer 组件到节点上。 ToggleContainer 属性 属性 功能说明 AllowSwitchOff 如果这个设置为 true， 那么 toggle 按钮在被点击的时候可以反复地被选中和未选中。 CheckEvents 选中事件。列表类型，默认为空，用户添加的每一个事件由节点引用，组件名称和一个响应函数组成。 ToggleContainer 事件 事件结构参考：组件事件结构 | ToggleContainer 的事件回调有二个参数，第一个参数是 Toggle 本身, 第二个参数是 customEventData。 详细说明 ToggleContainer 一般不会单独使用，它需要与 Toggle 配合使用来实现 RadioButton 的单选效果。 通过脚本代码添加回调 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 cc.Component.EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, ToggleContainerComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const containerEventHandler = new cc.Component.EventHandler(); containerEventHandler.target = this.node; // 这个 node 节点是你的事件处理代码组件所属的节点 containerEventHandler.component = 'example';// 这个是代码文件名 containerEventHandler.handler = 'callback'; containerEventHandler.customEventData = 'foobar'; const container = this.node.getComponent(ToggleContainerComponent); container.checkEvents.push(containerEventHandler); } callback(event: Event, customEventData: string){ //这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 // 这里的 customEventData 参数就等于之前设置的 'foobar' } } 其他基础模块参考 渲染模块参考 "},"ui-system/components/editor/slider.html":{"url":"ui-system/components/editor/slider.html","title":"SliderComponent 组件参考","keywords":"","body":"Slider 组件参考 Slider 是一个滑动器组件。 点击 属性检查器 下面的 添加组件 按钮，然后从 添加 UI 组件 中选择 Slider，即可添加 Slider 组件到节点上。 Slider 属性 属性 功能说明 handle 滑块按钮部件，可以通过该按钮进行滑动调节 Slider 数值大小 direction 滑动器的方向，分为横向和竖向 progress 当前进度值，该数值的区间是 0-1 之间 slideEvents 滑动器组件事件回调函数 Slider 事件 事件结构参考：组件事件结构 | Slider 的事件回调有两个参数，第一个参数是 Slider 本身，第二个参数是 CustomEventData 详细说明 Slider 通常用于调节数值的 UI（例如音量调节），它主要的部件一个滑块按钮，该部件用于用户交互，通过该部件可进行调节 Slider 的数值大小。 通常一个 Slider 的节点树如下图： 通过脚本代码添加回调 方法一 这种方法添加的事件回调和使用编辑器添加的事件回调是一样的，都是通过代码添加。首先需要构造一个 cc.Component.EventHandler 对象，然后设置好对应的 target、component、handler 和 customEventData 参数。 import { _decorator, Component, Event, Node, SliderComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { onLoad(){ const sliderEventHandler = new cc.Component.EventHandler(); sliderEventHandler.target = this.node; //这个 node 节点是你的事件处理代码组件所属的节点 sliderEventHandler.component = 'example';//这个是代码文件名 sliderEventHandler.handler = 'callback'; sliderEventHandler.customEventData = 'foobar'; const slider = this.node.getComponent(SliderComponent); slider.slideEvents.push(sliderEventHandler); } callback(event: Event, customEventData: string){ //这里 event 是一个 Touch Event 对象，你可以通过 event.target 取到事件的发送节点 // 这里的 customEventData 参数就等于之前设置的 'foobar' } } 方法二 通过 slider.node.on('slide', ...) 的方式来添加 // 假设我们在一个组件的 onLoad 方法里面添加事件处理回调，在 callback 函数中进行事件处理: import { _decorator, Component, SliderComponent } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"example\") export class example extends Component { @property(SliderComponent) slider: SliderComponent | null = null; onLoad(){ this.toggle.node.on('toggle', this.callback, this); } callback(slider: SliderComponent){ // 回调的参数是 slider 组件，注意这种方式注册的事件，无法传递 customEventData } } 其他基础模块参考 渲染模块参考 "},"editor/preview/":{"url":"editor/preview/","title":"项目预览调试","keywords":"","body":"项目预览调试 在使用主要编辑器面板进行资源导入、场景搭建、组件配置、属性调整之后，我们可以通过预览来查看调试游戏在 Web 平台运行的实际效果。 注意：Cocos Creator 3D 目前仅支持 web 平台的预览模式，模拟器预览会在之后的版本迭代中接入。 浏览器预览 预览流程简介与常见错误处理 先从 浏览器预览 开始了解。 "},"editor/preview/browser.html":{"url":"editor/preview/browser.html","title":"浏览器预览","keywords":"","body":"浏览器预览 预览 在编辑器工具栏上选择 浏览器 后，点击旁边的按钮，会在用户的默认桌面浏览器中直接运行游戏的网页版本。推荐使用谷歌浏览器（Chrome）作为开发过程中预览调试用的浏览器，因为谷歌浏览器（Chrome）的开发者工具是最为全面强大的。 浏览器预览界面的最上边有一系列控制按钮可以对预览效果进行控制： 最左边选择预览窗口的比例大小，来模拟在不同移动设备上的显示效果 Rotate 按钮决定显示横屏还是竖屏 Debug Mode 里可以选择脚本中哪些级别的日志会输出到浏览器控制台中 Show FPS 按钮可以选择是否显示每秒帧数和 Drawcall 数量等调试信息 FPS 限制最高每秒帧数 Pause 暂停游戏 刷新预览 如果在编辑器内对场景做了修改，想要刷新预览效果，直接在浏览器里面刷新或者点击编辑器的刷新按钮即可。不同在于，编辑器的刷新按钮，将会刷新所有的预览页面。如果想要让预览页面自动刷新，保存场景即可。保存场景自动刷新的设置在 项目设置 -> 项目预览 里可以修改。 预览场景 预览场景默认是当前打开场景，如果需要调整可以在 项目设置 -> 项目预览 里修改预览的初始场景（注意 : 需要勾选 local 菜单，和取消选中 Use Global，详情请参考项目设置）。 手机端预览 如果想要查看手机端的预览情况，可以使用浏览器开发者工具的手机端预览模式或者是将鼠标移动到编辑器工具栏左边的 ip 预览地址上，会显示一个预览的二维码。手机端扫一扫即可，当然也可以直接在手机端浏览器里直接输入预览的 url 地址。这一方法的前提是，手机需要和电脑在同一网段。由于电脑的网络有可能有多个，如果编辑器预览 url 的 ip 地址选择不正确，可以在 偏好设置 -> 通用设置 -> 选择本机预览地址 里面修改，详情可以参考偏好设置的说明。 自定义预览模板 预览也支持自定义的模板方便用户自定义需要的预览效果，自定义的预览模板可以放置在项目目录下的 preview-template 文件夹内。预览时将会查找该目录下的 index 文件，如果存在就是要该文件作为预览的模板。 project-folder |--assets |--build |--preview-template |--index.html 需要注意的是：预览模板里存在一些预览菜单项以及预览调试工具等内容，所以在增删一些模板语法写的内容时要稍加注意，如果随意修改有可能会导致预览模板不可用。 使用浏览器开发者工具进行调试 以谷歌浏览器为例，通过功能菜单的 开发者/开发者工具 可以打开开发者工具界面，如上图所示。在开发者工具中，我们可以查看运行日志、打断点进行调试、在调用堆栈中查看每一步各个变量的值、甚至进行资源加载和性能分析。 要学习使用开发者工具进行调试，请阅读 极客学院的 Chrome Dev Tools 使用指南，或其他浏览器的开发者工具帮助。 浏览器兼容性 Cocos Creator 3D 开发过程中测试的桌面浏览器包括： Chrome，Firefox（火狐），IE11 其他浏览器只要内核版本够高也可以正常使用，对部分浏览器来说请勿开启 IE6 兼容模式。 移动设备上测试的浏览器包括：Safari (iOS)，Chrome，QQ 浏览器，UC 浏览器，百度浏览器，微信内置 Webview。 继续了解 预览流程简介与常见错误处理 "},"particle-system/editor/":{"url":"particle-system/editor/","title":"粒子编辑器","keywords":"","body":"粒子编辑器 粒子编辑器主要包括编辑粒子属性的界面介绍以及如何查看与编辑已选中粒子的状态，主要有以下几个部分组成： 曲线编辑器 渐变色编辑器 控制面板 "},"particle-system/editor/curve-editor.html":{"url":"particle-system/editor/curve-editor.html","title":"曲线编辑器","keywords":"","body":"曲线编辑器 曲线编辑器可以设置粒子中某个属性随时间变化的曲线，曲线编辑器的界面如下图 曲线编辑器可以进行如下操作： 横坐标表示粒子的单位化的生命周期，比如一个粒子的生命周期为5s，则0.5代表2.5s。纵坐标表示属性值，可通过上方编辑栏调整纵坐标区间，默认区间为[-1,1]。 右键单击曲线上一点可以添加一个关键帧。 拖动关键帧可以改变其坐标。 通过转动关键帧旁的线段可以改变该点的斜率。 编辑器下方有内置的曲线模板，单击某个模板可直接将其应用到当前曲线中。 "},"particle-system/editor/gradient-editor.html":{"url":"particle-system/editor/gradient-editor.html","title":"渐变色编辑器","keywords":"","body":"渐变色编辑器 渐变色编辑器可以设置粒子中某个属性随时间变化的颜色，渐变色编辑器的界面如下图 渐变色编辑器可以进行如下操作： Mode可以选择两种模式，Blend模式会按照当前时刻相邻的两个关键帧进行插值得到当前帧的颜色，Fixed模式会直接使用当前时刻的前一个关键帧颜色。 点击色带上方的空白处可以插入一个alpha关键帧，点击色带下方的空白处可以插入一个rgb关键帧 拖动关键帧左右移动可以调节关键帧位置，拖动关键帧上下移动可以删除该关键帧 在Color/Alpha编辑框内可以编辑对应的rgb或alpha值 Location可以编辑已选中的关键帧的位置 "},"particle-system/editor/particle-effect-panel.html":{"url":"particle-system/editor/particle-effect-panel.html","title":"控制面板","keywords":"","body":"粒子控制面板 粒子控制面板可对在编辑器中选中的粒子进行一些操作，界面如下图： 可进行如下操作： ：播放/暂停粒子 ：重新播放粒子 ：停止播放粒子 Playback Speed：调整粒子播放速度Playback Time:显示粒子播放时长Particles：显示当前粒子数量 "},"editor/animation/animation.html":{"url":"editor/animation/animation.html","title":"关于 Animation","keywords":"","body":"关于Animation 在制作动画之前首先需要先为节点添加动画组件，并为组件挂载 clip 文件后才能编辑。在此之前，有必要先了解一下 clip 动画剪辑和 Animation 组件的相关概念。 Animation 组件 之前我们了解到 Cocos Creator 3D 是组件式的结构。那么 Animation 也不例外，它也是节点上的一个组件，只有为节点添加动画组件后，才能赋予节点参与到动画的的能力。因而点击相关节点后，如果节点没有动画组件，动画编辑器的界面上将会显示 添加 Animation 组件 按钮，点击即可添加。 Clip 动画剪辑 动画剪辑就是一份动画的声明数据，我们将它挂载到 Animation 组件上，就能够将这份动画数据应用到节点上，一个动画组件可以挂载多份动画剪辑。在没有 clip 的节点上是不能够编辑动画的，点击相关节点后，如果节点只有 Animation 组件却没有 clip 文件，动画编辑器将会显示 创建 clip 文件 按钮，点击即可创建并赋给组件。在动画编辑模式下亦可以通过动画编辑器左下角的 clip 选项来切换编辑不同的动画剪辑。 动画编辑模式 动画在普通模式下是不允许编辑的，只有在动画编辑模式下，才能够编辑动画文件。但是在动画编辑模式下，无法对节点进行 添加 / 删除 / 重命名 操作。 打开编辑模式： 选中一个包含 Animation 组件，并且包含有一个以上 clip 文件的节点，然后在动画编辑器左上角点击进入 动画编辑模式 的按钮。 退出编辑模式： 点击动画编辑器上点击右上角的退出按钮，或者在场景编辑器左上角的关闭按钮 更多细节参见 Animation 的系统设计以及 Animation 的脚本控制。 继续前往 熟悉编辑器 说明文档。 "},"editor/animation/animation-editor.html":{"url":"editor/animation/animation-editor.html","title":"熟悉动画编辑器","keywords":"","body":"熟悉动画编辑器 编辑器的主要面板介绍 动画编辑器一共可以划分为 6 个主要部分。 a. 工具栏 b. 时间轴与事件 c. 节点列表 d. 节点内关键帧预览 e. 属性列表 f. 属性轨道关键帧预览 a.工具栏 这里负责显示一些常用功能按钮 功能 图标 快捷键 备注 移动到第一帧 Ctrl / Cmd + Left - 移动到前一帧 Left - 播放/暂停 Ctrl / Cmd + P - 移动到下一帧 Right - 移动到最后一帧 Ctrl / Cmd + Right 移动到有效范围的最后一帧 停止动画 Ctrl / Cmd + S 点击停止当前动画，停止后将会移动到第一帧 添加事件关键帧 - 点击将会在当前时间控制线的位置添加事件关键帧 退出动画编辑模式 Ctrl + Q 点击退出动画编辑模式 切换时间轴显示刻度方式 - 默认是 00-00的方式，点击可以切换为 frame （以关键帧数）显示的方式。具体关于时间轴刻度可以参见 时间轴的刻度单位表示方式。 显示当前时间与跳转到对应时间 - 显示当前时间控制线的具体时间，也可以手动输入来使当前时间控制线调整到对应时间，支持直接输入 frame 或者是 00-00 的时间刻度。 调整默认关键帧间隔数 - 填入的关键帧间隔数将作为有多个关键帧同时生成时取做间隔数（例如：制作帧动画一次性拖入多张图片，此时添加的多个关键帧之间的间隔会取该值） 排列选中关键帧 - 选中的关键帧将以第一个帧为基准，以输入框内的数值作为间隔依次排列。 b.时间轴与事件 这里主要是显示时间轴，添加的自定义事件帧也会在这里显示。同时右键点击可以将事件控制先移动到对应位置，右键菜单可以进行 添加/移除、复制/粘贴 事件关键帧等，同时动画的有效长度也会有对应的显示效果。 时间轴的刻度表现方式 默认时间轴上刻度的表示法是 01-05。该数值由两部分组成，前面的数字表示当前秒数，后面的数字表示在当前这一秒里的第几帧。 01-05 表示该刻度在时间轴上位于从动画开始经过了 1 秒又 5 帧 的时间。 因为帧率（sample）可以随时调整，因此同一个刻度表示的时间点也会随着帧率变化而有所不同。 当帧率为 30 时，01-05 表示动画开始后 1 + 5/30 = 1.1667 秒。 当帧率为 10 时，01-05 表示动画开始后 1 + 5/10 = 1.5 秒。 虽然当前刻度表示的时间点会随着帧率变化，但一旦在一个位置添加了关键帧，该关键帧所在的总帧数是不会改变的， 假如我们在帧率 30 时向 01-05 刻度上添加了关键帧，该关键帧位于动画开始后总第 35 帧。之后把帧率修改为 10，该关键帧仍然处在动画开始后第 35 帧，而此时关键帧所在位置的刻度读数为 03-05。换算成时间以后正好是之前的 3 倍。 点击按钮 可以将刻度更改为 frame 的方式，并来回切换。 事件关键帧 在时间轴位置右键或者点击时间轴按钮可以添加事件关键帧，点击事件关键帧邮件菜单可以对齐进行移除、复制等操作，同时选中后也支持一系列的复制粘贴、删除快捷键。 c.节点列表 clip 动画数据中索引节点的方式是以挂载 Animation 组件的节点为根节点的相对路径， 因而在同个父节点下的同名节点，只能够产生一份动画数据，并且只能应用到第一个同名节点上。 这里的节点与层级管理器的节点是一一映射的，利用这个关系，当节点列表的节点数量过多难于查阅时，可以利用层级管理器的搜索功能来定位节点。在层级管理器点击节点，在动画编辑器内也会相应的跳转到对应节点位置来达到合理的显示效果。 选中节点图示 由于动画编辑器的节点列表融合了 clip 里面的数据后有可能会出现比原节点更多的节点信息，但这部分多余的节点就是丢失的节点，是无法编辑与使用的，界面上会显示为黄色同时关键帧轨道处也是置灰的状态。这时候可以将丢失的节点通过右键菜单的迁移数据来将数据转移到其他节点上。 具体的操作指南可以参见后续创建动画剪辑的章节。 d.节点内关键帧预览 这里主要是显示各个节点上的所有帧的预览。在此处关键帧位置右键菜单可以删除关键帧，亦可以移动关键帧的位置。同时单击此处不同节点的关键帧将会选中对应的节点，双击关键帧可以将时间控制线移动到该位置，在没有选中属性的情况下，Ctrl / Cmd + Shift + Left / Right 可以将时间控制线向上/下一个关键帧位置处移动。 e.属性列表 主要显示当前选中节点上参与动画的属性列表，每条属性显示项上有关键帧的 icon 图示，对应当前属性轨道对应当前时间控制线位置的关键帧状态，点击可以添加/移除对应关键帧。右键菜单可以移除当前轨道或清空数据等。在上方的加号按钮点击可以为当前选中节点添加属性轨道。 与节点一样的是，属性轨道也有存在丢失的可能，当前节点上不存在动画 clip 里记录的属性，该属性便是当前节点下丢失的属性。丢失的属性一样显示为黄色，这种情况下可以退出编辑模式后给对应节点添加相关属性或是直接移除该丢失的属性轨道。 f.属性轨道关键帧预览 主要显示各个属性轨道上具体的关键帧设置情况，也是关键帧编辑的主要区域。可以直接在轨道上右键来添加关键帧，亦可以拖动时间控制线到对应位置后按下 enter 键添加。同时在该区域也支持框选、点选关键帧来进行移动、复制、粘贴等操作。 基本操作指南 切换不同的动画剪辑进行编辑 点击动画编辑器左下角的 clip 选项，选择需要编辑的 clip 既可 在动画编辑模式下，点击其他带有动画剪辑的节点，既可将当前动画根节点切换为新选中的节点，从而编辑新的动画剪辑 更改时间轴缩放比例 在操作中如果觉得动画编辑器显示的范围太小，需要按比例缩小，让更多的关键帧显示到编辑器内怎么办？ 在图中b、d、f区域内滚动鼠标滚轮，可以放大，或者缩小时间轴的显示比例。 移动显示区域 如果想看动画编辑器右侧超出编辑器被隐藏的关键帧或是左侧被隐藏的关键帧，这时候就需要移动显示区域： 在图中b、d、f区域内按下鼠标中键/右键拖拽。 更改当前选中的时间 在时间轴（图 b 区域）区域内点击任意位置或者拖拽时间控制线，都可以更改当前的时间节点。 拖拽时间控制线 在工具栏点击控制时间控制线的按钮 双击关键帧，可以将当前时间跳转到对应位置 使用快捷键控制当前时间位置 播放/暂停动画 在图 a 区域内点击播放按钮，按钮会自动变更为暂停，再次点击则是播放 播放状态下，保存场景等操作会终止播放 快捷键 Ctrl / Cmd + P 控制 更多关于关键帧的操作，请查看 编辑动画序列 章节 快捷键汇总 功能 快捷键 说明 向前移动一帧 Left(←) 如果已经在第 0 帧，则忽略当前操作，未选中关键帧时移动的是小红线，选中节点后移动的是关键帧； 向后移动一帧 Right(→) 未选中关键帧时移动的是小红线，选中节点后移动的是关键帧； 移动到第一帧 Ctrl / Cmd + Left(←) - 移动到最后一帧 Ctrl / Cmd + Left(←) 当前 clip 内的有效帧数 删除当前选中关键帧 Delete / Cmd + Backspace - 播放/暂停动画 Alt + P - 停止动画 Alt + S 当前时间将变为 0 添加关键帧 Enter 选中属性轨道后，将会在在时间控制线位置添加关键帧，没有选中情况则忽略 跳到上一个关键帧 Ctrl / Cmd + Shift + Left(←) 移动到时间控制线左边最近的一个关键帧（选中属性轨道上或选中节点上） 跳到下一个关键帧 Ctrl / Cmd + Shift + Right(→) 移动到时间控制线右边最近的一个关键帧（选中属性轨道上或选中节点上） 多选关键帧 Ctrl 按住 Ctrl 点击关键帧可多选关键帧 全选轨道关键帧 Ctrl / Cmd + A 全选选中属性轨道的全部关键帧 复制生成关键帧 Alt 选中关键帧后，按下 Alt 不放 并拖动选中的关键帧可以复制对应的关键帧到新的移动位置 复制选中的关键帧 Ctrl / Cmd + C - 粘贴上一次复制的关键帧 Ctrl / Cmd + V - 取消选中的关键帧或事件帧 Esc - "},"editor/animation/animation-create.html":{"url":"editor/animation/animation-create.html","title":"创建 Animation 组件和动画剪辑","keywords":"","body":"创建Animation组件和动画剪辑 创建 Animation 组件 在每个节点上，我们都可以添加不同的组件。如果我们想在这个节点上创建动画，也必须为它新建一个 Animation 组件。 创建的方法有两种： 选中相应的节点，在属性检查器中点击下方的添加组件，在 Components 中选择 AnimationComponent。 打开动画编辑器，然后在层级管理器中选中需要添加动画的节点，在动画编辑器中点击添加 Animation 组件按钮。 具体 Animation 组件的参数使用可以参见Animation组件参考 创建与挂载动画剪辑 现在节点上已经有了 Animation 组件了，但是还没有相应的动画剪辑数据，动画剪辑也有两种创建方式： 在资源管理器中点击左上方的+，或者右键空白区域，选择 Animation Clip，这时候会在管理器中创建一个名为 'New AnimationClip' 的剪辑文件。 单单创建还是不够的，我们再次在层级管理器中点选刚刚的节点，在属性检查器中找到 Animation，这时候的 Clips 显示的是 0，我们将它改成 1。 然后将刚刚在资源管理器中创建的 'New AnimationClip' ，拖入刚刚出现的animation-clip 选择框内。 如果 Animation 组件中还没有添加动画剪辑文件，也可以在动画编辑器中直接点击 新建 AnimationClip 按钮，根据弹出的窗口创建一个新的动画剪辑文件，新建完的动画剪辑会自动附在动画组件上。 注意: 如果选择覆盖已有的剪辑文件，被覆盖的文件内容会被清空。 至此我们已经完成了动画制作之前的准备工作，下一步就是要 编辑动画序列 了。 "},"editor/animation/animation-clip.html":{"url":"editor/animation/animation-clip.html","title":"编辑动画序列","keywords":"","body":"编辑动画序列 在节点上挂载了动画剪辑后，点击进入动画编辑模式就可以进入动画编辑模式了，之后便可以在动画剪辑中创建一些动画帧数据。 首先需要了解一下动画属性，动画属性包括了节点自有的 position、rotation 等属性，也包含了组件 Component 中自定义的属性。 组件包含的属性前会加上组件的名字，比如 cc.SpriteComponent.spriteFrame。 属性轨道上对应的蓝色棱形就是关键帧。 Animation（动画） 组件可以以动画方式驱动所在节点和子节点上的节点和组件属性，包括用户自定义脚本中的属性。根据这个特性，可以灵活实现各种动画需求。具体的动画实现依不同的动画需求，步骤不同，案例可以参考官方的 example-3d 。这里主要介绍一些常见的编辑操作方法，便于快速的编辑实现效果 关键帧常见操作 在动画的制作过程中，经常会有一些对关键帧的操作处理，这里集合了动画编辑器的各种对关键帧处理的方法，了解这些方法技巧能更快编辑动画剪辑。 选中关键帧 点击我们创建的关键帧后，关键帧会呈现选中状态，此时关键帧由蓝变白，目前有以下方式可以选中： 右键点击关键帧即可选中，按下 Ctrl 再右击可多选 直接在关键帧区域拖动框选关键帧 在选中属性轨道后，按下 Ctrl / Cmd + A 可以全选轨道关键帧 添加关键帧 选中对应节点和对应的属性，移动时间控制线到需要添加关键帧的位置，按下 enter 键 移动时间控制线到需要添加关键帧的位置，在对应的属性列表项里，点击 即可 在对应的属性轨道位置上右键，选择 添加关键帧 添加属性轨道后，直接在属性检查器的对应位置修改属性或者进行场景操作即可自动生成关键帧 移除关键帧 选中需要删除的关键帧，按下 delete / Cmd + backspace 键 在需要删除的关键帧位置右键，弹出菜单后，选中 移除关键帧 拖动时间控制线到需要移除关键帧的位置或者直接双击关键帧后，在对应的属性列表项里，点击 即可 修改关键帧数据 在时间轴上双击需要修改的关键帧，时间控制线将会移动到该位置或者直接拖动时间控制线到对应位置，直接在 属性检查器 内修改相对应的属性即可（确保动画编辑器处于编辑状态）。例如属性列表中有 position、x、y 三个属性轨道，选中关键帧之后，则可以修改 属性检查器 中的 position、x、y 属性。 在动画编辑模式下，将时间控制线移动到时间轴上没有关键帧的位置，然后在属性检查器中修改相对应的属性，也会自动插入一帧。 移动关键帧 选中关键帧后，在选中的关键帧上后右键按住不放进行拖动，松开即移动完成 移动过程中会有移动距离和最终位置帧数的提示 复制/粘贴关键帧 选中关键帧后，按照常规快捷键 C / V 即可进行复制粘贴 选中关键帧后，在选中的关键帧上右键，选择 复制关键帧 ，之后选择其他位置右键，选择 粘贴关键帧 即可 选中关键帧后，按下 Alt 键，在选中的关键帧上按住不放进行拖动，松开鼠标后关键帧将会复制到移动的对应位置 属性轨道数据常见操作 一个动画剪辑内可能包含了多个节点，每个节点上挂载多个动画属性，每个属性内的数据才是实际的关键帧，属性内的关键帧操作上面已经提到过了。这边主要介绍一些针对整个属性轨道的操作： 添加属性轨道：点击属性列表旁边的 + 小按钮，弹出可添加的属性菜单后，点击需要添加的属性即可 移除属性轨道：右键点击属性列表项，选择移除属性轨道 清空轨道数据：右键点击属性列表项，选择清空属性轨道 节点数据常见操作 动画剪辑通过节点的名字定义数据的位置，本身忽略了根节点，其余的子节点通过与根节点的相对路径索引找到对应的数据。 清空节点数据：在动画编辑器的节点项位置右键，选择 清空数据，在弹窗提示后选择 清除 即可 迁移节点数据：有时候我们会在制作完成动画后，将节点重命名，这样会造成动画数据所以出现问题，如下图： 这时候我们可以在丢失节点上右键点击 迁移数据，之后再去点击其他节点，将数据迁移上去。如果点击迁移数据后不想迁移了，直接在时间轴区域点击或者是在点击其他节点后的弹窗点击取消即可。 修改 clip 常见属性 sample： 定义当前动画数据每秒的帧率，默认为 60，这个参数会影响时间轴上每两个整数秒刻度之间的帧数量（也就是两秒之内有多少格）。 speed： 当前动画的播放速度，默认为 1。 duration： 当动画播放速度为 1 的时候，动画的持续时间。 real time： 动画从开始播放到结束，真正持续的时间，对应编辑器右下角括号内的数字。 wrap mode： 循环模式，具体配置效果请参见 循环模式 在编辑器面板上的对应控件修改对应属性后，焦点离开后即生效。 更多关于动画序列的设计部分以及脚本编写动画的内容，可以参见 动画剪辑 。 继续前往 制作帧动画 说明文档。 "},"editor/animation/sprite-animation.html":{"url":"editor/animation/sprite-animation.html","title":"编辑帧动画","keywords":"","body":"制作帧动画 我们刚刚了解了属性帧的操作，现在来看看具体怎么创建一个帧动画。 为节点新增 Sprite 组件 首先我们需要让节点能正常显示纹理，所以需要为节点增加Sprite组件。 选中节点后在属性检查器中通过 添加组件 按钮，选择 UI -> Render -> Sprite。 在属性列表中添加 cc.Sprite.spriteFrame 节点可以正常显示纹理后，还需要为纹理创建一个属性轨道。 在动画编辑器属性列表旁点击 +，然后选择 cc.SpriteComponent -> spriteFrame 添加帧 从资源管理器中，将纹理拖拽到属性帧区域，放在 cc.Sprite.spriteFrame 轨道上。 再将下一帧需要显示的纹理拖到指定位置，然后点击播放就可以预览刚刚创建的动画了。 如果同时拖拽多个纹理到属性轨道上，轨道上将按钮纹理选中的顺序，将其按照顺序，以工具栏上显示间隔数来排列生成关键帧。 排列修改关键帧间隔 帧动画的间隔帧数通常是固定的，有时添加了多个张纹理后，想要调整间隔数，就可以先在工具栏上方填写想要的间隔帧数，之后选中需要排列的关键帧，点击工具栏上的排列按钮或者在选中的关键帧上右击，选择 排列选中的关键帧 即可。 继续前往 编辑动画曲线 说明文档。 "},"editor/animation/animation-curve.html":{"url":"editor/animation/animation-curve.html","title":"编辑动画曲线","keywords":"","body":"编辑动画曲线 我们已经创建了基本的动画了。 但有时候我们会需要在两帧之间实现 EaseInOut 等缓动效果，那么在动画编辑器中怎么实现呢？ 我们首先需要在一条轨道上创建两个不相等的帧，比如在 position 上创建两帧，从 0,0 到 100,100。 这时候两帧之间会出现一根连接线（连接关键帧之间的蓝色线段），双击连接线，可以打开曲线编辑器。 曲线编辑器打开时，如果当前的动画曲线数据是预设里的，左边的预设对应项会有金黄色边框的选中效果。动画曲线的修改都是实时的，无需点击保存，修改完点击右上角的关闭按钮即可。 使用预设曲线 我们在曲线编辑器左侧可以选择预设的各种效果。比如说 Ease In 等，通过点击对应的曲线就可应用到当前的动画曲线上。 自定义曲线 有时候预设的曲线不能够满足动画需求时，我们也可以自己修改曲线。 在曲线编辑器的预览曲线图内，有两个灰色的控制点，拖拽控制点可以更改曲线的轨迹。 如果控制点需要拖出视野外，则可以使用鼠标滚轮缩放预览图。 修改过程中的曲线数据会实时的显示在曲线区域左上角的输入框内，同时该输入框还支持手动输入曲线数据来生成曲线，当然曲线数据的格式必须是四个数字用逗号隔开的格式，否则无法正常应用。 保存自定义曲线 有时项目需求的一些自定义曲线数据需要复用，就可以将其保存在 User 的预设库内。具体可以在编辑需要保存的曲线数据后，在左上方的预设菜单选择 User 选项再在左下方的输入框内输入希望保存的曲线数据名称，点击 add 即可添加。 注意：同名曲线会做覆盖处理，自定义曲线的保存是没有做撤销处理的，所以如果被覆盖了就需要重新添加的。 保存在预设里的自定义曲线，和其他库的预设曲线一样，点击即可应用。同时，鼠标移到曲线上方，会出现一个删除的图标，点击即可删除对应曲线数据。 更多关于动画曲线的设计以及脚本控制代码的部分可以参考 动画曲线 继续前往 添加动画事件 说明文档。 "},"editor/animation/animation-event.html":{"url":"editor/animation/animation-event.html","title":"动画事件","keywords":"","body":"动画事件 在游戏中，经常需要在动画结束或者某一帧的特定时刻，执行一些函数方法。这时候就可以通过添加动画事件来实现，在某个关键帧上添加事件函数后，动画系统将会在动画执行到该关键帧时，去匹配动画根节点身上的对应函数方法并执行它们。在脚本内添加帧事件的相关处理，以及更多内容请参考 帧事件。 添加事件帧 首先将时间控制线移动到需要添加事件的位置，然后点击工具栏区域的按钮，这时候在对应的时间轴上会出现一个一样的金色图标，这就是我们添加的事件。 删除事件帧 在添加的时间帧位置，右键点击，选择删除即可，在此处的删除将会删除该时间位置所有的时间帧函数。 添加事件帧函数 在事件函数编辑器的左上方点击 + 按钮，即可添加新的事件帧函数 删除时间帧函数 需要单独删除对应时间位置的某个帧函数，可以在事件函数编辑器中，点击函数名旁边的删除按钮。 编辑指定事件触发函数 双击刚添加的事件帧，可以打开事件编辑器，在编辑器内，我们可以手动输入需要触发的 function 名字，触发的时候会根据这个函数名，去动画根节点的各个组件内匹配相应的方法。 如果需要添加传入的参数，则在 Params 旁点击 + 或者 - ，目前只支持 Boolean、String、Number 三种类型的参数。 出现修改后，事件函数编辑器的标题旁会出现红色的星号，事件函数的修改是需要手动保存的，修改后点击上方的保存按钮即可保存。如果没有保存，在关闭事件编辑器也会有提示保存的弹框。 "},"editor/publish/":{"url":"editor/publish/","title":"构建发布","keywords":"","body":"发布工作流 在项目正常开发，预览效果达到要求的情况下，可以构建项目来进行更多的测试。目前 Cocos Creator 3D 仅支持 Web 和 微信两个平台的构建，更多的构建平台，会在后续的版本中持续推进。 导读 熟悉构建发布面板 了解通用构建参数 发布到 web 平台 发布到微信小游戏 接入微信小游戏的开放数据域 命令行发布项目 定制项目的构建模版 构建流程简介与常见错误处理 先从 熟悉构建发布面板 开始了解。 "},"editor/publish/build-panel.html":{"url":"editor/publish/build-panel.html","title":"熟悉构建发布面板","keywords":"","body":"熟悉构建发布面板 构建发布面板使用简介 点击主菜单中的 项目 -> 构建发布 或者使用快捷键 Ctrl / Cmd + Shift + B 即可打开构建发布面板，构建发布是以构建任务的形式进行，可以同时进行多个平台的构建任务。由于引擎的复用是以平台作为区分的，所以不支持同一平台同时构建，但可以给同一平台添加多个构建任务。如果同时添加了多个同一平台的构建任务，编辑器将会按照任务添加的先后顺序，在该平台的构建任务完成后自动开始继续构建下一个任务。 新建构建任务 点击右上方的 新建构建任务 按钮，即可打开构建参数配置面板，在该区域内填写好相关的构建参数，点击构建即可。 在点击构建之前，请确保当前的场景数据没有未保存的内容。当前场景有内容尚未保存，点击构建后构建将会弹框提示，可以选择保存场景数据、忽略或取消构建。选择保存和忽略都会继续进行构架，而取消构建则会生成一条被取消的构建记录。 注：没有场景的项目构建是没有意义的，因而空场景的项目是不允许添加构建任务的。 其中构建参数的第一项，构建任务名，将会作为实际打包后的包体文件夹命名，默认是无需修改的，当需要覆盖旧有的包体文件夹时可以改成其他名字。 注：Cocos Creator 构建后是使用平台作为包体名称，并且构建默认会覆盖原来打包后的内容。而 Cocos Creator 3D 是将构建任务名称作为包体名称，允许更改，默认会使用和现有包体不一样的名字作为构建任务名，手动修改为同名后可覆盖原包体。 构建面板中的导出选项可将当前配置导出为 json 配置文件，导入选项可读取配置文件到构建设置，方便用户保存构建配置信息。 构建进度查看 点击构建后，可以在构建面板上看到当前的构建任务进行情况。构建进行中进度条将显示为黄色，如果构建成功，进度条会显示为绿色，并且每个子任务后都会有 √ 的标识。第一次构建的时候，引擎编译会比较慢请耐心等待。如果构建失败，进度条则会显示为红色，对应失败的子任务后会显示红色的感叹号。 构建完成后，点击运行即可预览构建后的项目效果。 构建参数查看 面板上的构建任务都会有一个 查看构建配置 按钮，点击即可查看之前构建的参数配置情况。 在编辑器内构建过的构建任务信息，将会保存在项目目录下的 profiles/packages/build.json 里，只要没有在面板上删除对应构建任务或者删除对应的实体文件，就可以在重新打开编辑器后查看之前构建的参数配置、运行预览等操作。 同时，点击构建构建后，编辑器也将打印出当前构建的参数内容，可以作为命令行构建的参数配置参考。 重新编译 经常在打包后，会想要更改之前配置参数或者是之前的项目内 bug 修复后希望重新构建。而构建面板这边提供了两种重新编译的入口，一种是直接在构建任务上，点击将会直接复用之前的构建配置参数进行重新构建。另一种则是在点击 查看构建配置参数 后也会有 重新构建 的按钮出现。不同的是，后一种允许修改除了构建任务名与构建平台以外的参数。 正在运行的构建项目 构建的预览 url 都是预览 URL 路径下的 build 路径，同一时间内编辑器内可以预览的 web 构建项目只有一个，只有点击对应项目的 运行 按钮后才会将新的项目地址放在服务器上。当前已经设置在编辑器服务器上的项目，会有比较明显的标识如下图，直接访问构建的预览 URL 访问到的就是该项目。 "},"editor/publish/build-options.html":{"url":"editor/publish/build-options.html","title":"通用构建参数介绍","keywords":"","body":"通用构建参数介绍 构建面板内的通用参数 发布路径 通过在 发布路径 的输入框中输入路径或者通过 ... 浏览按钮直接选择，我们可以为游戏指定一个发布路径，后续的多平台发布都会在这个发布路径中的子文件夹中创建资源或工程，发布后的文件夹名称会与构建任务对应名称（参见构建进度条项左上角）一致，。 默认的发布路径在项目文件夹下的 build 文件夹中，如果您使用 git、svn 等版本控制系统，可以将 build 文件夹在版本控制中忽略。 调试模式 在发布模式下，将会对资源的 uuid 、构建出来的引擎脚本与项目脚本进行压缩和混淆，并且将对同类资源的 json 做分包处理，减少资源加载的次数。在需要对项目进行调试处理时，建议勾上此项方便定位问题。 参与构建的场景 在构建过程中，除 resources 内的资源和脚本会全部打包出来外，其他资源都是根据参与构建的场景的使用情况来按需打包的。因而不勾选不需要发布的场景，可以减少构建后的包体体积。 Source Maps 构建默认会对引擎文件和项目脚本做压缩处理，如果需要生成 sourcemap 需要勾选此项。 内联所有 SpriteFrame 自动合并资源时，将所有 SpriteFrame 与被依赖的资源合并到同一个包中。建议网页平台开启，启用后会略微增大总包体，多消耗一点点网络流量，但是能显著减少网络请求数量。建议原生平台关闭，因为会增大热更新时的体积。 合并初始场景依赖的所有 JSON 自动合并资源时，将初始场景依赖的所有 JSON 文件都合并到初始场景所在的包中。默认关闭，启用后不会增大总包体，但如果这些 JSON 也被其它场景公用，则后面再次加载它们时 CPU 开销可能会稍微增加。 MD5 Cache 给构建后的所有资源文件名将加上 MD5 信息，解决 CDN 资源缓存问题。 启用后，如果出现资源加载不了的情况，说明找不到重名后的新文件。这通常是因为有些第三方资源没通过 cc.loader 加载引起的。这时可以在加载前先用以下方法转换 url ，转换后的路径就能正确加载。 url = cc.loader.md5Pipe.transformURL(url); Eruda 插入 Eruda 调试插件，Eruda 类似 DevTools 的迷你版，用于辅助调试。 如果需要调试，也可以开启 调试模式 和 Source Maps 的选项，这样构建出的版本会保留 sourcemap。 其他参与构建的参数配置 引擎模块设置 这部分设置可以在 项目设置-->模块设置 里更改，主要是用于剔除一些项目内不需要使用的引擎模块来减少打包后的包体。 引擎物理选项 这部分设置可以在 项目设置-->引擎设置-->physics 里更改，主要是用于设置当前引擎的物理选项配置。详情请参见 物理选项配置 Canvas 默认设置 这部分设置可以在 项目设置-->通用设置-->默认 Canvas 设置 里更改，主要用于设置多种分辨率的问题，如果项目内没有 Canvas 组件可以忽略该设置，详情请参见多分辨率适配方案 "},"editor/publish/publish-web.html":{"url":"editor/publish/publish-web.html","title":"发布到 web 平台","keywords":"","body":"发布到 Web 平台 Cocos Creator 3D 提供了两种 Web 平台的页面模板，可以通过 发布平台 的下拉菜单选择 Web Mobile 或 Web Desktop，他们的区别主要在于 Web Mobile 会默认将游戏视图撑满整个浏览器窗口，而 Web Desktop 允许在发布时指定一个游戏视图的分辨率，而且之后游戏视图也不会随着浏览器窗口大小变化而变化。 打开主菜单的 项目 -> 构建发布，打开构建发布面板。 参数说明 一些通用的构建通用参数介绍，请参考通用构建参数介绍 resolution 指定的游戏视图分辨率，仅在 web-desktop 下可以配置。 构建和预览 配置好构建参数后，点击 构建 按钮，开始 Web 平台版本构建。面板上会出现一个进度条，当进度条达到 100% 时，构建就完成了。 接下来可以点击 运行 按钮，在浏览器中打开构建后的游戏版本进行预览和调试。 上图所示就是 Web Mobile 模式的预览，可以看到游戏视图会占满整个窗口, 而 Web Desktop 则不会撑满屏幕，如下图。 浏览器兼容性 Cocos Creator 3D 开发过程中测试的桌面浏览器包括： Chrome，Firefox（火狐），IE11 其他浏览器只要内核版本够高也可以正常使用，对部分浏览器来说请勿开启 IE6 兼容模式。 移动设备上测试的浏览器包括：Safari (iOS)，Chrome，QQ 浏览器，UC 浏览器，百度浏览器，微信内置 Webview。 Retina 设置 可以在脚本中通过 cc.view.enableRetina(true) 设置是否使用高分辨率，构建到 Web 平台时默认会开启 Retina 显示。 发布到 Web 服务器 要在互联网上发布或分享您的游戏，只要点击 发布路径 旁边的 打开 按钮，打开发布路径之后，按照当前构建任务名称，将构建出的对应文件夹里的内容整个复制到您的 Web 服务器上就可以通过相应的地址访问了。 关于 Web 服务器的架设，可以自行搜索 Apache、Nginx、IIS、Express 等相关解决方案。 "},"editor/publish/publish-wechatgame.html":{"url":"editor/publish/publish-wechatgame.html","title":"发布到微信小游戏","keywords":"","body":"发布到微信小游戏 这篇文档将会覆盖： 小游戏的运行环境介绍 如何使用 Cocos Creator 3D发布微信小游戏 小游戏资源管理 微信小游戏 微信小游戏是微信小程序下的游戏产品平台，它不仅提供了强大的游戏能力，还和小程序一样，提供了大量的原生接口，比如支付，社交，文件系统，照片，NFC 等。相当于同时结合了 WEB 易于传播以及 Native 功能丰富的优势。 小游戏的运行环境是小程序环境的扩展，基本思路也是封装必要的 WEB 接口提供给用户，尽可能追求和 WEB 同样的开发体验。小游戏在小程序环境的基础上提供了 WebGL 接口的封装，使得渲染能力和性能有了大幅度提升。不过由于这些接口都是微信团队通过自研的原生实现封装的，所以并不可以等同为浏览器环境。 作为引擎方，为了尽可能简化开发者的工作量，我们为用户完成的主要工作包括： 引擎框架适配微信小游戏 API，纯游戏逻辑层面，用户不需要任何额外的修改 Cocos Creator 3D 编辑器提供了快捷的打包流程，直接发布为微信小游戏，并自动唤起小游戏的开发者工具 自动加载远程资源，缓存资源以及缓存资源版本控制 除此之外，小游戏的游戏提交，审核和发布流程和小程序是没有区别的，都需要遵守微信团队的要求和标准流程，具体信息可以参考文末的链接。 使用 Cocos Creator 3D 发布微信小游戏 在 微信公众平台 下载微信开发者工具 在编辑器菜单栏的 偏好设置 -> 原生开发环境 中设置微信开发者工具路径 登陆微信公众平台，找到 appid 在 构建发布 面板的 发布平台 中选择 微信小游戏，填入小游戏 appid，然后点击 构建 点击 运行 打开微信开发者工具 注意：微信开发者工具，如果之前在点击上没运行过，会出现：Please ensure that the IDE has been properly installed 的报错。需要手动打开一次微信开发者工具，然后才能在 Cocos Creator 3D 里直接点击 运行 调用。 预览部署 按照这样的流程，项目的 build 目录下就会生成一个微信小游戏的发布包 wechatgame 文件夹(具体构建任务名为准），其中已经包含了微信小游戏环境的配置文件：game.json 和 project.config.json 小游戏环境的资源管理 在小游戏环境中，资源管理是最特殊的部分，它和浏览器的不同在于下面四点： 小游戏的包内体积不能够超过 4MB，包含所有代码和资源，额外的资源必须通过网络请求下载。 对于从远程服务器下载的文件，小游戏环境没有浏览器的缓存以及过期更新机制。 对于小游戏包内资源，小游戏环境内并不是按需加载的，而是一次性加载所有包内资源，然后再启动页面。 不可以从远程服务器下载脚本文件。 这里引出了两个关键的问题，首页面加载速度和远程资源缓存及版本管理。对于首页面加载速度，我们建议用户只保存脚本文件在小游戏包内，其他资源都从远程服务器下载。而远程资源的下载、缓存和版本管理，其实在 Cocos Creator 3D 中，已经帮用户做好了。下面我就来解释一下这部分的逻辑。 在小游戏环境中，我们提供了一个 wxDownloader 对象，给它设置了 REMOTE_SERVER_ROOT 属性后，引擎下载资源的逻辑就变成： 检查资源是否在小游戏包内 不存在则查询本地缓存资源 如果没有缓存就从远程服务器下载 下载后保存到小游戏应用缓存内供再次访问时使用 缓存空间有大小限制，如果超出限制则会保存失败，此时打印提示信息并使用资源下载时的临时文件作为资源 注意：需要额外注意的是，一旦缓存空间占满之后，所有需要下载的资源都无法进行保存，只能使用下载保存的临时文件，而微信会在小游戏退出之后自动清理所有临时文件，所以下次再次运行小游戏时，这些资源又会再度下载，然后一直循环往复此过程。另外，缓存空间超出限制导致文件保存失败的问题不会在微信开发者工具上出现，因为微信开发者工具没有限制缓存大小，所以测试缓存时需要真实微信环境进行测试。 同时，当开启引擎的 md5Cache 功能后，文件的 url 会随着文件内容的改变而改变，这样当游戏发布新版本后，旧版本的资源在缓存中就自然失效了，只能从服务器请求新的资源，也就达到了版本控制的效果。 具体来说，开发者需要做的是： 构建时，在 构建发布配置 面板中勾选 md5Cache 功能。 设置 远程服务器地址，然后点击 构建。 构建完成后将微信小游戏发布包目录下的 res 文件夹完整的上传到服务器。 删除本地发布包目录下的 res 文件夹。 对于测试阶段来说，可能用户无法部署到正式服务器上，需要用本地服务器来测试，那么请在微信开发者工具中打开 详情 页面，勾选项目设置中的 不检验安全域名、TLS 版本以及 HTTPS 证书 选项。 注意：如果缓存资源超过微信环境限制，用户需要手动清除资源，可以在微信小游戏下使用 wx.downloader.cleanAllAssets() 和 wx.downloader.cleanOldAssets() 接口来清除缓存。前者会清除缓存目录下的所有缓存资源，请慎重使用；而后者会清除缓存目录下目前应用中未使用到的缓存资源。 平台 SDK 接入 除了纯游戏内容以外，其实微信小游戏环境还提供了非常强大的原生 SDK 接口，其中最重要的就是用户、社交、支付等，这些接口都是仅存在于微信小游戏环境中的，等同于其他平台的第三方 SDK 接口。这类 SDK 接口的移植工作在现阶段还是需要开发者自己处理。下面列举一些微信小游戏所提供的强大 SDK 能力： 用户接口：登陆，授权，用户信息等 微信支付 转发以及获得转发信息 文件上传下载 媒体：图片、录音、相机等 其他：位置、设备信息、扫码、NFC、等等 接入微信小游戏的开放数据域 微信小游戏为了保护其社交关系链数据，增加了 开放数据域 的概念，这是一个单独的游戏执行环境。开放数据域中的资源、引擎、程序，都和主游戏完全隔离，开发者只有在开放数据域中才能访问微信提供的 wx.getFriendCloudStorage() 和 wx.getGroupCloudStorage() 两个 API，用于实现一些例如排行榜的功能。 详情请参考 接入微信小游戏的开放数据域。 微信小游戏已知问题： 我们对微信小游戏的适配工作还未完全结束，目前仍不支持以下组件： VideoPlayer WebView 用户如果有需要，目前可以先自己直接调用微信的 API 来使用。 参考链接 微信小游戏开发文档 微信公众平台 小游戏 API 文档 微信开发者工具下载 微信开发者工具文档 微信缓存空间溢出测试案例 "},"editor/publish/publish-wechatgame-subcontext.html":{"url":"editor/publish/publish-wechatgame-subcontext.html","title":"接入微信小游戏的开放数据域","keywords":"","body":"接入微信小游戏的开放数据域 微信小游戏为了保护其社交关系链数据，增加了 开放数据域 的概念，这是一个单独的游戏执行环境。开放数据域中的资源、引擎、程序，都和主游戏完全隔离，开发者只有在开放数据域中才能访问微信提供的 wx.getFriendCloudStorage() 和 wx.getGroupCloudStorage() 两个 API，用于实现一些例如排行榜的功能。由于开放数据域只能在离屏画布 sharedCanvas 上渲染，因此需要我们把 sharedCanvas 绘制到主域上。 由于开放数据域是一个封闭、独立的 JavaScript 作用域，所以开发者需要创建两个项目： 主域项目工程（正常的游戏项目） 开放数据域项目工程（通过微信 API 获取用户数据来做排行榜等功能的项目） 在开放数据域项目工程中，独立通过开放数据域打包流程打包，并将构建后生成的发布包放置到主域工程的发布包 build 目录中，就可以作为完整的微信工程在模拟器和真机上进行预览调试了。 微信小游戏开放数据域 整合方法 创建开放数据域项目通过相关的 API 获取用户数据，根据自身需求制作 ui 的展示。整个开放数据域项目只应该包含其内容 UI，并且应该将场景中 Canvas 组件的设计分辨率设置为 UI 的完整分辨率，不需要对应主域的分辨率。 主域中创建一个节点作为开放数据域容器，添加 WXSubContextView 组件用于设置开放数据域视窗以及更新开放数据域贴图，这个节点的宽高比应该等于开放数据域设计分辨率的宽高比（否则会出现拉伸）。 WXSubContextView 技巧 这是新开放数据域方案的核心组件，通过这个组件除了常规的需求可以满足以外，还有一些小技巧可以方便用户更好地控制开放数据域的表现。 视窗更新 一般情况下，开放数据域的视窗是固定的，但是也存在开放数据域在主域的视窗节点发生更新的情况，比如使用 Widget 去适配父节点，比如场景切换后设计分辨率发生改变的情况，或者是开发者手动调整了视窗的尺寸。这种情况下，开发者必须要调用 updateSubContextViewport 接口来更新开放数据域中的视窗参数，以便事件可以被正确映射到开放数据域视窗中 手动更新贴图 当开放数据域被唤起后，只要 WXSubContextView 组件 load 成功，开放数据域贴图就开始更新到主域并显示，之后每帧都会更新贴图。但是开放数据域贴图的更新有时可能损耗比较高，开发者设计的开放数据域又是静态界面（比如翻页式的界面），此时就不需要每帧更新贴图，可以尝试通过禁用组件来阻止每帧更新逻辑，并通过手动调用 update 函数来在需要的时候更新： subContextView.enabled = false; subContextView.update(); 这样手动控制是性能最优的方案。 模块选择 由于微信开放数据域的代码和资源都无法与主域共享，所以对包体很敏感，开发者需要对开放数据域工程专门设置 项目模块剔除选项。需要注意的是，开发者在开放数据域项目中不能够勾选 WebGL Renderer，必须勾选 Canvas Renderer，因为开放数据域仅支持 Canvas 渲染。同时，Canvas 渲染下所支持的渲染组件也是受限的（UI 组件不受限制），目前仅支持： Sprite Label Graphics Mask 微信小游戏开放数据域发布流程 一、打开主域项目，在 菜单栏 -> 项目 中打开 构建发布 面板，选择 微信小游戏，填入 开放数据域代码目录。该目录是开放数据域构建后所在的路径，并且这个路径需要放在主域构建目录下。然后点击 构建。 该步骤会帮用户自动配置到主域项目 build -> wechatgame -> game.json 中，用于辨别开放数据域文件在主域发布包下的所在目录。 二、打开开放数据域项目，打开 构建发布 面板，选择 微信小游戏开放数据域。 三、发布路径 指定到主域项目工程的发布包目录即 build 目录下。然后点击 构建。 注意：游戏名称 必须和主域项目中设置的 开放数据域代码目录 名称一致。 或者可以不修改开放数据域的 发布路径，在开放数据域项目构建完成后手动将发布包拷贝到主域项目的发布包目录下。如下图所示： 四、在主域项目工程的 构建发布 面板中点击 运行 调起微信开发者工具，即可按照之前微信小游戏的正常流程进行发布和调试。 "},"editor/publish/publish-in-command-line.html":{"url":"editor/publish/publish-in-command-line.html","title":"命令行发布项目","keywords":"","body":"命令行发布项目 通过命令行发布项目可以帮助大家构建自己的自动化构建流程，大家可以修改命令行的参数来达到不同的构建需求。 命令行发布参考 例如：构建 web-desktop 平台、Debug 模式 Mac /Applications/CocosCreator.app/Contents/MacOS/CocosCreator --path projectPath --build \"platform=web-desktop;debug=true\" Windows CocosCreator/CocosCreator.exe --path projectPath --build \"platform=web-desktop;debug=true\" 构建参数 --path：指定项目路径 --build：指定构建项目使用的参数 在 --build 后如果没有指定参数，则会使用 Cocos Creator 3D 中构建面板当前的平台、模板等设置来作为默认参数。如果指定了其他参数设置，则会使用指定的参数来覆盖默认参数。可选择的参数有： configPath - 参数文件路径。如果定义了这个字段，那么构建时将会按照 json 文件格式来加载这个数据，并作为构建参数 excludedModules - engine 中需要排除的模块，模块可以从 这里 查找到 title - 项目名 platform - 构建的平台 [web-mobile、web-desktop、wechatgame、wechatgame-subcontext] buildPath - 构建目录 startScene - 主场景的 uuid 值（参与构建的场景将使用上一次的编辑器中的构建设置） debug - 是否为 debug 模式 previewWidth - web desktop 窗口宽度 previewHeight - web desktop 窗口高度 sourceMaps - 是否需要加入 source maps webOrientation - web mobile 平台（不含微信小游戏）下的旋转选项 [landscape、portrait、auto] inlineSpriteFrames - 是否内联所有 SpriteFrame mergeStartScene - 是否合并初始场景依赖的所有 JSON optimizeHotUpdate - 是否将图集中的全部 SpriteFrame 合并到同一个包中 template - native 平台下的模板选项 [default、link] embedWebDebugger - 是否在 web 平台下插入 vConsole 调试插件 md5Cache - 是否开启 md5 缓存 wechatgame - 微信小游戏发布选项 appid- 发布微信小游戏时需要的 id orientation - 微信小游戏屏幕方向 [landscape、portrait] 在 Jenkins 上部署 Cocos Creator 3D 命令行运行的时候也是需要 GUI 环境的。如果你的 Jenkins 无法使用 Cocos Creator 3D 命令行运行，一个解决办法是：确保 Jenkins 运行在 agent 模式下，这样才能访问到 WindowServer。详见：https://stackoverflow.com/questions/13966595/build-unity-project-with-jenkins-failed 如果你的 Jenkins 在 Windows 下无法编译，请在 Windows 的 控制面板 -> 管理工具 -> 服务 中为 Jenkins 的服务指定一个本地用户，然后重启电脑就可以了。不必单独设置一个 master-slave 模式。 "},"editor/publish/custom-project-build-template.html":{"url":"editor/publish/custom-project-build-template.html","title":"定制项目的构建模版","keywords":"","body":"定制项目构建流程 自定义发布模版 Cocos Creator 3D 支持对每个项目分别定制发布模板，只需要在项目路径下添加一个 build-templates 目录，里面按照平台路径划分子目录，然后里面的所有文件在构建结束后都会自动按照对应的目录结构复制到构建出的工程里。 结构类似： project-folder |--assets |--build |--build-templates |--web-mobile |--index.html 这样如果当前构建的平台是 web-mobile 的话，那么 build-templates/web-mobile/index.html 就会在构建后被拷贝到对应构建任务文件夹下。 "},"editor/publish/build-guide.html":{"url":"editor/publish/build-guide.html","title":"构建流程简介与常见错误处理","keywords":"","body":"构建流程简介与常见错误处理 构建流程简介 Cocos Creator 3D 的构建流程，这里拆分为三大块： a. 构建 setting.js（包含对资源和脚本的打包处理） b. 打包模板文件 c. 打包引擎 目前构建后的文件夹路径是会在构建是选择的发布路径里生成一个以平台为前缀的文件夹，如果当前发布路径文件夹内有和平台同名的文件夹，就按顺序添加 _001 以此类推。 a.构建 setting.js 编辑器内打包项目都会生成一个 setting.js 的文件，里面记录项目相关的很多重要配置和资源信息，是引擎能够正确查找资源的一个索引文件。因而 setting.js 的构建是打包过程中的一项重要工作。 严格来说这个部分不仅仅是构建出一个 setting.js ，但是由于这个文件的生成需要在项目内的资源整理完毕之后才能完整的生成，所以将这部分的处理都归结于 构建 setting.js，这一部分内容的构建时间通常会随着项目资源的增多而加长，主要可以拆分为资源的构建和脚本的构建。 构建资源 首先来介绍资源的打包过程。这一步骤内所指的对资源的打包是指除了脚本以外的资源文件，因为脚本是作为特殊文件来打包处理的。在打包资源阶段，编辑器会先汇总当前参与构建的场景以及所有在 resources 目录下的资源，每个资源的打包都会经过引擎的反序列化，查找出依赖资源再递归进行资源的打包。在反序列化之前会先配置整个项目的脚本环境，也就是加载所有的非插件项目脚本。因为脚本的加载正确与否会直接影响到反序列化的进行，因而如果脚本编写的不合法加载失败会直接导致构建失败。如果在反序列化过程中发现有依赖的资源丢失会发出警告，但会继续进行构建。这里的警告并不意味着问题不需要解决，如果资源丢失不解决，是难于保证构建后的内容不出问题的。 通过上面的介绍，我们知道只有在 resources 目录下的资源以及参与构建场景明确引用依赖的资源才会被打包到最终的构建文件夹内。所以如果在脚本内使用了某个资源但这个资源没有被场景引用也没有放在 resources 目录下，之后加载就会出现 404 了。 资源在打包过程中，在反序列化后会进行重新的压缩序列化，减小打包之后的包体。对 texture 资源的序列化文件会全部打包成一个 json 文件，其他序列化文件会根据构建配置参数来决定是否分包处理。打包之后，所有的序列化文件都会放置在构建后目录的 res/import 目录下，所有的资源源文件将会放置在 res/raw-assets 目录下。 资源打包过程中也会不断的收集参与资源构建的资源 uuid ，最终会整理写进 setting.js 。setting.js 会被写入在构建后文件夹的 src 目录下，生成之前将会根据是否构建调试模式来决定是否对文件内的 uuid 做压缩处理，所有使用到的 uuid 会进行整理，将出现 2 次 以上的存储进 uuids 数组内，之前使用 uuid 的位置替换为索引。 如果勾选了 md5Cache 选项，会在生成 setting.js 之前，对现有的所有资源文件加上 md5 时间戳。同时会在 setting.js 内放置整理后的 md5AssetsMap 。md5AssetsMap 是一个数组，以 [uuid_1, md5_1, uuid_2, md5_2, ...] 的格式存储的，其中 uuid_1 如果是个简单数字说明存储的是 uuids 数组内的 uuid 索引。 构建脚本 编辑器内对脚本的构建是分为两类的，插件脚本和非插件脚本。插件脚本会直接把源文件按照原来的目录结构拷到构建后文件夹的 src 目录下，所以插件脚本是不支持任何需要编译的脚本形式的比如 ts 或者是使用 es6 写法的 js。插件脚本的资源信息则会写进 settings 里的 jsList 数组内。 非插件脚本将会全部打包成 project.js （调试模式下是 project.dev.js ），放在对应的 src 目录下。 在资源和脚本构建完成后，编辑器会再整合一些项目设置与构建配置的参数内容，生成最终版的 setting.js 。这份 setting.js 是引擎运行时获取项目信息的索引所在，只有这份内容信息完整正确才能正确的加载项目资源运行场景。 b. 打包模板文件 这部分的流程内容对每个平台来说是固定的，通常也不会花费太多时间。目前 web 平台的 index.html 文件时支持用户自定义，其他模板文件暂时还不支持。模板文件主要就是根据不同的构建配置参数写入模板生成文件到构建后的文件夹内。 c. 打包引擎文件 引擎打包的主要步骤是 获取设置里排除的引擎模块信息； 检查缓存中的引擎版本与当前需要编译的引擎是否一致，内容一致无法再次编译直接拷贝； 根据引擎接口，执行打包引擎的 gulp 任务，之后拷贝编译后的 js 文件，并保存模块数据与引擎版本信息用于下次比对； 由于引擎的脚本文件比较多，打包引擎会比较慢。所以在每次打包之后，会缓存打包后的引擎脚本和引擎打包时的对应模块设置，这样如果之后有同一平台相同配置构建就会复用之前打包的引擎文件，如果不希望复用可以勾选构建配置面板的 强制更新引擎。 打包的引擎的过程中会根据配置的参数是否为调试模式来决定是否压缩引擎文件，同时会根据当前项目设置的引擎模块来选择剔除某些不需要的模块。 关于引擎文件的复用规则，这里有必要阐述下： 打包好的引擎文件将会放置在引擎目录的 bin/.cache/平台名称文件夹下, engine-folder |--bin |--.cache |--plarform-folder |--cocos3d-js.js |--.excludes |--cocos3d-js.min.js |--.excludes-min ... 而对应的 .excludes 文件内则是存储影响引擎打包的参数内容，分别是： excludes: 引擎模块设置 version: 引擎版本 sourceMaps：是否开始 sourcemap physics：物理选项 engineMtime：引擎 bin/.cache/dev/quick_compile.js 的修改时间 因而只要相关的引擎构建参数发生更改，就会重新编译引擎。 常见错误及处理 构建的整个进程是在一个单独的 worker 内的，所以如果想要查看构建过程的 log 信息或者查看出现报错时完整的调用栈，可以在主菜单的 开发者 -> 打开构建调试工具 里打开。 有必要说明的是，在构建之前请先确保参与构建的场景是可以正常预览的。一些场景的资源丢失或者其他脚本问题，是在预览阶段就能暴露出来的。在保证预览正常的情况下构建能更好的节约时间以及排查问题。 资源丢失 在前面的构建流程里介绍过，资源的构建会经过反序列查找依赖，而最经常出现的问题就是所依赖的资源在项目迭代过程中被不小心删除而导致资源丢失。这些资源的丢失可能平时并没有注意到，但一旦构建都会暴露出来的。 这时候，请复制报资源丢失信息里的 uuid 去资源管理器里面查找对应的资源，查看该资源依赖的资源是否都正常。 脚本资源加载报错 在前面介绍资源打包时有提到过，构建需要配置脚本环境，因而如果此时抛出的错误是脚本的，请参考报错内容对脚本进行更改。如果不清楚是哪个脚本的报错，可以找到报错信息调用栈内对应脚本的 uuid ，在资源管理器内查找定位。 引擎编译失败 通常不会出现此问题，如果遇到引擎编译失败，请带上你的报错信息截图在论坛或者其他反馈渠道告知我们。 其他报错 如果遇到其他无法自行解决的构建报错信息，请带上你的构建配置截图、构建调试工具里的 log 信息以及 demo 在论坛提问。 "},"asset/":{"url":"asset/","title":"关于资源","keywords":"","body":"关于资源 本章节将详细介绍 Cocos Creator 3D 中资源的整体工作流程，并对各类资源的使用方法及可能需要注意的地方做出说明。 资源管理器 资源管理器 作为访问管理资源的重要工具，开发者在管理资源时推荐先熟悉资源管理器的使用方法，关于资源管理器的详细介绍可见：资源管理器 资源工作流 资源工作流 通用的资源工作流程包括导入资源、同步资源、定位资源等说明可见：资源工作流 资源的获取和加载 资源的获取和加载的详细说明可见：获取和加载资源 资源的分包加载 对于小游戏平台的游戏分包，Cocos Creator 3D 为开发者提供了分包加载功能，详细说明可见：分包加载 常见资源类型工作流程 接下来我们会介绍 Cocos Creator 3D 中主要资源类型和相关工作流程： 场景资源 图像资源 纹理贴图资源 精灵帧资源 立方体贴图资源 图像资源的自动裁剪 预制资源 脚本资源 字体资源 声音资源 材质资源 模型资源 动画资源 "},"asset/asset-workflow.html":{"url":"asset/asset-workflow.html","title":"资源工作流","keywords":"","body":"资源工作流 导入资源 提供了三种 导入资源 的方式： 以新建文件的方式，通过 Cocos Creator 3D 窗口的 资源管理器 面板 创建按钮 导入资源 以复制文件的方式，在操作系统的文件管理器中，将资源文件复制到项目资源文件夹下，之后打开编辑器或激活编辑器窗口会自动刷新 资源管理器 的资源列表，完成导入资源。 以拖拽文件的方式，从操作系统的文件管理器中拖拽资源文件到 资源管理器 面板的某个文件夹位置，完成导入资源。 名称解释 英文 中文 dataBase 数据库 asset-db 项目资源数据库 internal-db 内置数据库 uuid 唯一标识符 meta 元信息 同步资源 资源管理器 面板中的资源和 操作系统的文件管理器 中看到的项目资源文件是同步的，在 资源管理器 中对资源的移动、重命名和删除，都会同步到 操作系统的文件管理器 ，反之亦然。 资源配置信息 .meta 文件 所有资源文件都会在导入时生成一份同名的 .meta 后缀的配置文件 这份配置文件提供了该资源在项目中的唯一标识 uuid 以及其他的一些配置信息，如图集中的小图引用，贴图资源的裁剪数据等，是识别一份合法资源的必要因素。 在 资源管理器 面板中 .meta 文件是不可见的，对资源的重命名，移动，删除，都会由编辑器自动同步该资源对应的 .meta 文件，以确保配置信息如 uuid 等保持不变，即不影响现有的引用。 不推荐直接在 操作系统的文件管理器 对资源文件进行操作，如有操作，请同步处理相应的 .meta 文件，如下建议： 关闭正在使用的编辑器，避免因为文件锁定或资源名称相同导致更新失败。 删除，重命名，移动资源时，请连同 .meta 文件一起删除，重命名，移动。 复制资源时如果连同 .meta 文件一起复制，将直接使用复制进来的 .meta 文件，而不是再生成新的 .meta 文件；如果只复制了资源文件，则会生成对应名称的新的 .meta 文件。 Library 中的资源 资源经过导入后会生成一份新的数据存在项目的 Library 文件夹里。在 Library 里的文件，其结构和资源是面向引擎的，是最终游戏时需要的格式，即机器友好，但对人的阅读不友好。这块。 当 library 丢失或损坏的时候，只要删除整个 library 文件夹再打开项目，就会重新生成资源库。 如何定位资源 一个资源有唯一的 uuid 来定位到该资源，但这种方式不够直观，还有另一种直观的方式：Database URL 格式例如 asset-db 对应的协议头是 db://assets ，internal-db 对应的协议头是 db://internal。 有文件夹层级的资源格式，如 db://assets/prefabs/fire.prefab SVN 或 GIT 同步资源 需要注意 .meta 文件的换行符，建议统一下团队成员电脑的换行符风格和规则，避免同步项目资源后打开项目，出现了大量的 .meta 文件修改 "},"asset/load-assets.html":{"url":"asset/load-assets.html","title":"获取和加载资源","keywords":"","body":"获取和加载资源 Cocos Creator 3D 采用与Cocos Creator统一的资源管理机制，在本篇教程，我们将介绍 资源属性的声明 如何在 属性检查器 里设置资源 动态加载资源 加载远程资源和设备资源 资源的依赖和释放 资源属性的声明 在 Cocos Creator 3D 中，所有继承自 cc.Asset 的类型都统称资源，如 cc.Texture2D, cc.SpriteFrame, cc.AnimationClip, cc.Prefab 等。它们的加载是统一并且自动化的，相互依赖的资源能够被自动预加载。 例如，当引擎在加载场景时，会先自动加载场景关联到的资源，这些资源如果再关联其它资源，其它也会被先被加载，等加载全部完成后，场景加载才会结束。 脚本中可以这样定义一个 Asset 属性： // NewScript.ts import { _decorator, Component } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"NewScript\") export class NewScript extends Component { @property({type: cc.SpriteFrame}) public spriteFrame: cc.SpriteFrame = null; } 如何在属性检查器里设置资源 只要在脚本中定义好类型，就能直接在 属性检查器 很方便地设置资源。假设我们创建了这样一个脚本： // NewScript.ts import { _decorator, Component } from \"cc\"; const { ccclass, property } = _decorator; @ccclass(\"NewScript\") export class NewScript extends Component { @property({type: cc.Texture2D}) public texture: cc.Texture2D = null; @property({type: cc.SpriteFrame}) public spriteFrame: cc.SpriteFrame = null; } 将它添加到节点后，在 属性检查器 中是这样的： 接下来我们从 资源管理器 里面分别将一张 Texture 和一个 SpriteFrame 拖到 属性检查器 的对应属性中： 结果如下： 这样就能在脚本里直接拿到设置好的资源： start () { const texture = this.texture; const spriteFrame = this.spriteFrame; } 在 属性检查器 里设置资源虽然很直观，但资源只能在场景里预先设好，没办法动态切换。如果需要动态切换，你需要看看下面的内容。 动态加载 动态加载资源要注意两点，一是所有需要通过脚本动态加载的资源，都必须放置在 resources 文件夹或它的子文件夹下。resources 需要在 assets 文件夹中手工创建，并且必须位于 assets 的根目录，就像这样： resources 文件夹中的资源，可以引用文件夹外部的其它资源，同样也可以被外部场景或资源引用到。项目构建时，除了已在 构建发布 面板勾选的场景外，resources 文件夹中的所有资源，连同它们关联依赖的 resources 文件夹外部的资源，都会被导出。 如果一份资源仅仅是被 resources 中的其它资源所依赖，而不需要直接被 cc.loader.loadRes 调用，那么 请不要 放在 resources 文件夹里。否则会增大包体和 settings.js 的大小，并且项目中无用的资源，将无法在构建的过程中自动剔除。同时在构建过程中，JSON 的自动合并策略也将受到影响，无法尽可能将零碎的 JSON 合并起来。 第二个要注意的是 Cocos Creator 3D 相比 Cocos Creator，资源动态加载的时候都是 异步 的，需要在回调函数中获得载入的资源。这么做是因为除了场景关联的资源，没有另外的资源预加载列表，动态加载的资源是真正的动态加载。 动态加载 Asset Cocos Creator 3D 提供了 cc.loader.loadRes 这个 API 来专门加载那些位于 resources 目录下的 Asset。和 cc.loader.load 不同的是，loadRes 一次只能加载单个 Asset。调用时，你只要传入相对 resources 的路径即可，并且路径的结尾处 不能 包含文件扩展名。 // 加载 Prefab cc.loader.loadRes(\"test assets/prefab\", (err: any, prefab: cc.Prefab) => { const newNode = cc.instantiate(prefab); cc.director.getScene().addChild(newNode); }); // 加载 AnimationClip cc.loader.loadRes(\"test assets/anim\", (err: any, clip: cc.AnimationClip) => { this.node.getComponent(cc.AnimationComponent).addClip(clip, \"anim\"); }); 加载 SpriteFrame 或 Texture2D 图片设置为 sprite-frame 或 texture 或其他图片类型后，将会在 资源管理器 中生成一个对应类型的资源。但如果直接加载 test assets/logo2，得到的类型将会是 cc.ImageAsset。你必须在图片路径之后加入资源类型，才能加载到图片生成的 对应资源的子资源, 如果不确定对应资源的路径可以在运行或预览时到settings.js中查看： // 加载 SpriteFrame，logo2 是 ImageAsset，texture 是 SpriteFrame/Texture-2d cc.loader.loadRes(\"test assets/logo2/texture\", (err: any, spriteFrame: cc.SpriteFrame) => { this.node.getComponent('cc.SpriteComponent').spriteFrame = spriteFrame; }); 如果指定了类型参数，就会在路径下查找指定类型的资源。当你需要获取 “子资源”（例如获取 Texture2D 生成的 SpriteFrame），就需要指定子资源的路径。 { const frame = atlas.getSpriteFrame('sheep_down_0'); sprite.spriteFrame = frame; }); ``` --> 资源释放 loadRes 加载进来的单个资源如果需要释放，可以调用 cc.loader.releaseRes，releaseRes 可以传入和 loadRes 相同的路径和类型参数。 cc.loader.releaseRes(\"test assets/image/spriteFrame\"); cc.loader.releaseRes(\"test assets/anim\"); 此外，你也可以使用 cc.loader.releaseAsset 来释放特定的 Asset 实例。 cc.loader.releaseAsset(spriteFrame); 资源批量加载 cc.loader.loadResDir 可以加载相同路径下的多个资源： // 加载 test assets 目录下所有资源 cc.loader.loadResDir(\"test assets\", (err: any, assets: Array) => { // ... }); // 加载 test assets 目录下所有 SpriteFrame，并且获取它们的路径 cc.loader.loadResDir(\"test assets\", cc.SpriteFrame, (err: any, assets: Array, urls: Array) => { // ... }); 加载远程资源和设备资源 在目前的 Cocos Creator 3D 中，我们支持加载远程贴图资源，这对于加载用户头像等需要向服务器请求的贴图很友好，需要注意的是，这需要开发者直接调用 cc.loader.load。同时，如果用户用其他方式下载了资源到本地设备存储中，也需要用同样的 API 来加载，上文中的 loadRes 等 API 只适用于应用包内的资源和热更新的本地资源。下面是这个 API 的用法： // 远程 url 带图片后缀名 const remoteUrl1 = \"http://unknown.org/someres.png\"; cc.loader.load(remoteUrl1, (err: any, image: cc.ImageAsset) => { // Use imageAsset to create sprite frame or texture }); // 远程 url 不带图片后缀名，此时必须指定远程图片文件的类型 const remoteUrl2 = \"http://unknown.org/emoji?id=124982374\"; cc.loader.load({url: remoteUrl2, type: 'png'}, (err: any, image: cc.ImageAsset) => { // Use imageAsset to create sprite frame }); 目前的此类手动资源加载还有一些限制，对用户影响比较大的是： 这种加载方式只支持图片、声音、文本等原生资源类型，不支持 SpriteFrame、SpriteAtlas、Tilemap 等资源的直接加载和解析（需要后续版本中的 AssetBundle 支持） Web 端的远程加载受到浏览器的 CORS 跨域策略限制，如果对方服务器禁止跨域访问，那么会加载失败，而且由于 WebGL 安全策略的限制，即便对方服务器允许 http 请求成功之后也无法渲染。 资源的依赖和释放 在加载完资源之后，所有的资源都会临时被缓存到 cc.loader 中，以避免重复加载资源时发送无意义的 http 请求，当然，缓存的内容都会占用内存，有些资源可能用户不再需要了，想要释放它们，这里介绍一下在做资源释放时需要注意的事项。 首先最为重要的一点就是：资源之间是互相依赖的。 比如下图，Prefab 资源中的 Node 包含 Sprite 组件，Sprite 组件依赖于 SpriteFrame，SpriteFrame 资源依赖于 Texture 资源，而 Prefab，SpriteFrame 和 Texture 资源都被 cc.loader 缓存起来了。这样做的好处是，有可能有另一个 SpriteAtlas 资源依赖于同样的一个 SpriteFrame 和 Texture，那么当你手动加载这个 SpriteAtlas 的时候，就不需要再重新请求贴图资源了，cc.loader 会自动使用缓存中的资源。 在搞明白资源的相互引用之后，资源释放的问题也就呼之欲出了，当你选择释放一个 Prefab 时，我们是不会自动释放它依赖的其他资源的，因为有可能这些依赖资源还有其他的用处。所以用户在释放资源时经常会问我们，为什么我都把资源释放了，内存占用还是居高不下？原因就是真正占用内存的贴图等基础资源并不会随着你释放 Prefab 或者 SpriteAtlas 而被释放。 接下来要介绍问题的另一个核心：JavaScript 中无法跟踪对象引用。 在 JavaScript 这种脚本语言中，由于其弱类型特性，以及为了代码的便利，往往是不包含内存管理功能的，所有对象的内存都由垃圾回收机制来管理。这就导致 JS 层逻辑永远不知道一个对象会在什么时候被释放，这意味着引擎无法通过类似引用计数的机制来管理外部对象对资源的引用，也无法严谨得统计资源是否不再被需要了。基于以上的原因，目前 cc.loader 的设计实际上是依赖于用户根据游戏逻辑管理资源，用户可以决定在某一时刻不再需要某些资源以及它依赖的资源，立即将它们在 cc.loader 中的缓存释放。也可以选择在释放依赖资源的时候，防止部分共享资源被释放。下面是一个简单的示例： // 直接释放某个贴图 cc.loader.release(texture); // 释放一个 prefab 以及所有它依赖的资源 const deps = cc.loader.getDependsRecursively('prefabs/sample'); cc.loader.release(deps); // 如果在这个 prefab 中有一些和场景其他部分共享的资源，你不希望它们被释放，可以将这个资源从依赖列表中删除 const deps = cc.loader.getDependsRecursively('prefabs/sample'); const index = deps.indexOf(texture2d._uuid); if (index !== -1) deps.splice(index, 1); cc.loader.release(deps); 最后一个值得关注的要点：JavaScript 的垃圾回收是延迟的。 想象一种情况，当你释放了 cc.loader 对某个资源的引用之后，由于考虑不周的原因，游戏逻辑再次请求了这个资源。此时垃圾回收还没有开始（垃圾回收的时机不可控），或者你的游戏逻辑某处，仍然持有一个对于这个旧资源的引用，那么意味着这个资源还存在内存中，但是 cc.loader 已经访问不到了，所以会重新加载它。这造成这个资源在内存中有两份同样的拷贝，浪费了内存。如果只是一个资源还好，但是如果类似的资源很多，甚至不止一次被重复加载，这对于内存的压力是有可能很高的。如果观察到游戏使用的内存曲线有这样的异常，请仔细检查游戏逻辑，是否存在泄漏，如果没有的话，垃圾回收机制是会正常回收这些内存的。 以上就是管理资源依赖和释放时需要注意的细节，这部分的功能和 API 设计还没有完全定案，我们还是希望尽力给大家带来尽可能方便的引擎 API，所以后续也会尝试一些其他的办法提升友好度，届时会更新这篇文档。 继续前往 事件 说明文档。 "},"asset/subpackage.html":{"url":"asset/subpackage.html","title":"分包加载","keywords":"","body":"分包加载 随着游戏玩法越来越丰富，游戏的代码量也越来越大，开发者对于扩大包大小的需求越来越强烈，同时微信小游戏也支持了分包加载的功能。所以 Cocos Creator 3D 支持 分包加载 这样一个功能，该功能支持 代码 和 资源 的分包加载。分包加载目前只支持各类小游戏平台，如微信小游戏。 分包加载，即把游戏内容按一定规则拆分在几个包里，在首次启动的时候只下载必要的包，这个必要的包称为 主包，开发者可以在主包内触发下载其他子包，这样可以有效降低首次启动的消耗时间。 配置方法 Cocos Creator 3D 的分包是以文件夹为单位来配置的，当我们选中一个文件夹时，在 属性检查器 中会出现文件夹的相关配置选项： 勾选 配置为子包 后，点击右上方的 确定，这个文件夹下的资源（包含代码和其他资源）就会被当做是子包的内容了。子包名 会在加载子包时作为加载的名字传入，默认会使用这个文件夹的名字。 注意：配置为子包后，只有原生资源，例如图片和音频会被最终放到子包中。Prefab、AnimationClip 等 JSON 类型的资源仍然会放在主包里。 注意：应尽量避免子包的嵌套，比如A文件夹被勾选为子包后，A文件夹下B文件夹也被勾选为子包。如果存在嵌套，则父文件夹不会将子文件夹中的内容打包 构建 分包的作用只会在项目构建后才会体现，预览的时候还是按照整包来进行加载的。项目构建后会在发布包目录下的 subpackages 生成对应的分包文件夹。 例如：将 example 工程中的 cases/01_graphics 文件夹配置为子包，那么项目构建后将会在发布包目录下的 subpackages 生成 01_graphics 文件夹。 构建发布时，会对 cases/01_graphics 子包文件夹下所有的 代码 和 资源 进行以下的相关处理： 代码：cases/01_graphics 文件夹下的所有代码会合并成一个命名为 01_graphics/game.js 的入口脚本文件，并且会将这些代码从主包中剔除。 资源：会把 cases/01_graphics 子包资源从发布包目录下的 res/raw-assets 文件夹移动到发布包目录下的 subpackages/01_graphics 目录下。 加载子包 引擎提供了一个统一的 api cc.loader.downloader.loadSubpackage 来加载子包文件里面的资源（包含代码和其他资源）。loadSubpackage 需要传入一个子包的名字，这个名字即是之前用户在项目中配置的子包名字，默认为子包文件夹的名字。 当子包加载完成后，会触发回调，如果加载失败的话，会返回一个错误信息。 cc.loader.downloader.loadSubpackage('01_graphics', (err: any) => { if (err) { return console.error(err); } console.log('load subpackage successfully.'); }); 如果加载成功，子包中的脚本将被执行，子包的资源加载路径将被添加到引擎中。开发者就可以用和访问主包完全一样的方式访问这个子包中的所有资源，无需关心这些资源原先是在主包还是在子包中。 微信小游戏 在微信小游戏平台的构建中，子包的配置也会按照规则自动生成到微信小游戏发布包目录下的 game.json 配置文件中。 注意：微信小游戏需要特定的版本才能支持分包功能。微信 6.6.7 客户端，2.1.0 及以上基础库开始支持，请更新至最新客户端版本，开发者工具请使用 1.02.1806120 及以上版本。更新了开发者工具后不要忘记修改开发者工具中的 详情 -> 项目设置 -> 调试基础库 为 2.1.0 及以上： 分包加载包大小的限制 目前微信小游戏分包大小有以下限制： 整个微信小游戏所有分包大小不超过 8M 单个分包/主包大小不能超过 4M 具体请参考 微信小游戏分包加载官方文档。 "},"asset/scene.html":{"url":"asset/scene.html","title":"场景资源","keywords":"","body":"场景资源 在 Cocos Creator 3D 中，游戏场景（Scene） 是开发时组织游戏内容的中心，也是呈现给玩家所有游戏内容的载体。而场景文件本身也作为游戏资源存在，其保存了游戏的大部分信息，也是创作的基础。 创建场景 我们现在共有三种创建场景的方式： 为了您的项目具备良好的文件夹目录结构，我们强烈建议您使用 方法一 创建场景 方法一：在 资源管理器 中选中你想要创建场景文件的文件夹，在文件夹目录上 右键/新建/场景文件，之后键入想要的场景名即可。 方法二：在 资源管理器 中点击创建菜单，创建新场景。 方法三：选择主菜单：文件/新建场景，会在层级管理器直接出现新场景，但资源管理器中不会出现新场景，需要在进行了场景保存后才会在资源文件夹的根目录下出现New Scene.scene场景文件。 保存场景 在标记场景的过程中，可通过快捷键 Ctrl + S (Windows) 或 Command + S (Mac) 来快速保存场景 切换场景 在 资源管理器 中，双击需要打开的场景。 如需游戏中切换场景，可通过 cc.director.loadScene 等 API 来实现游戏中动态场景加载及切换，详情请见我们的 API 文档。 场景资源的属性 作为一个资源文件，在 资源管理器 中选中想要管理的场景时，可设置场景文件是否要异步加载资源 而在打开场景文件之后，scene 作为场景节点树的根节点，在 层级管理器 中选中 Scene 节点,在左侧的属性检查器中可设置整个场景相关的属性，包括环境光设置，阴影设置和天空盒设置。 各类属性的详细说明请见： 环境光 阴影 天空盒 "},"asset/image.html":{"url":"asset/image.html","title":"图像资源","keywords":"","body":"图像资源 图像资源又经常被称作贴图、图片，是游戏中绝大部分图像渲染的数据源。图像资源一般由图像处理软件（比如 Photoshop，Windows 上自带的画图）制作而成并输出成 Cocos Creator 3D可以使用的文件格式，目前包括 JPG 和 PNG 两种。 导入图像资源 使用默认的资源导入方式就可以将图像资源导入到项目中，之后我们就可以在 资源管理器 中看到如下图所示的图像资源。 图像资源的类型 选中导入的图像资源，在右侧的属性检查器面板上，可以选择图像资源不同的使用方式，目前共有4中使用方式供开发者使用，如下所示： 各类型图像资源的详情在下面的章节中有详细介绍： raw 类型为原始图片类型，无作用，用户不需使用 texture 类型为图像资源类型，也为导入的默认类型，详情可见：Texture normal map 类型为法线贴图类型 sprite-frame 类型为精灵帧资源，用于 UI 制作上，详情可见：SpriteFrame texture cube 类型为立方贴图类型，使用在全景图上，用于制作天空盒上，详情可见：天空盒 在 资源管理器 中，图像资源的左边会显示一个和文件夹类似的三角图标，点击就可以展开看到它的子资源（sub asset），每个图像资源导入后编辑器会自动在它下面创建同名的 选中类型 的资源。选中资源本身可进行更改资源类型、设置图像翻转及设置图像在各平台的质量的操作。子资源的详细属性说明请见：子资源属性面板 "},"asset/sprite-frame.html":{"url":"asset/sprite-frame.html","title":"精灵帧资源","keywords":"","body":"精灵帧资源（SpriteFrame） Cocos Creator 3D SpriteFrame 资源跟 Creator 的 SpriteFrame 资源概念一致，是 Texture 资源的一种，用于 UI 制作上。 导入精灵帧资源 使用默认的资源导入方式就可以将图像资源导入到项目中，之后我们就可以在 资源管理器 中看到如下图所示的图像资源。 图像资源在 资源管理器 中会以自身图片的缩略图作为图标。在 资源管理器 中选中图像子资源后，属性检查器 下方会显示该图片的缩略图。 使用 SpriteFrame 拖拽 SpriteFrame 资源到该 Sprite 组件的 Sprite Frame 属性栏中，来切换该 Sprite 显示的图像。 "},"ui-system/components/engine/trim.html":{"url":"ui-system/components/engine/trim.html","title":"图像资源的自动裁剪","keywords":"","body":"图像资源的自动剪裁 导入图像资源后生成的 SpriteFrame 会进行自动剪裁，去除原始图片周围的透明像素区域。这样我们在使用 SpriteFrame 渲染 Sprite 时，将会获得有效图像更精确的大小。 Sprite 组件剪裁相关设置详解 和图片裁剪相关的 Sprite 组件设置有以下两个： Trim 勾选后将在渲染 Sprite 图像时去除图像周围的透明像素，我们将看到刚好能把图像包裹住的约束框。取消勾选，Sprite 节点的约束框会包括透明像素的部分。 Size Mode 用来将节点的尺寸设置为原图或原图裁剪透明像素后的大小，通常用于在序列帧动画中保证图像显示为正确的尺寸。有以下几种选择： TRIMMED 选择这个选项，会将节点的尺寸（size）设置为原始图片裁剪掉透明像素后的大小。 RAW 选择这个，会将节点尺寸设置为原始图片包括透明像素的大小。 CUSTOM 自定义尺寸，用户在使用 矩形变换工具 拖拽改变节点的尺寸，或通过修改 Size 属性，或在脚本中修改 width 或 height 后，都会自动将 Size Mode 设为 CUSTOM。表示用户将自己决定节点的尺寸，而不需要考虑原始图片的大小。 下图中展示了两种常见组合的渲染效果： 自带位置信息的序列帧动画 有很多动画师在绘制序列帧动画时，会使用一张较大的画布，然后将角色在动画中的运动直接通过角色在画布上的位置变化表现出来。在使用这种素材时，我们需要将 Sprite 组件 的 Trim 设为 false，将 Size Mode 设为 RAW。这样动画在播放每个序列帧时，都将使用原始图片的尺寸，并保留图像周围透明像素的信息，这样才能正确显示绘制在动画中的角色位移。 而 Trim 设为 true，则是在位移完全由角色位置属性控制的动画中，更推荐使用的方式。 TexturePacker 设置 在制作序列帧动画时，我们通常会使用TexturePacker这样的工具将序列帧打包成图集，并在导入后通过图集资源下的 SpriteFrame 来使用。在 TexturePacker 中输出图集资源时，Sprites 分类下的 Trim mode 请选择 Trim，一定不要选择 Crop, flush position，否则透明像素剪裁信息会丢失，您在使用图集里的资源时也就无法获得原始图片未剪裁的尺寸和偏移信息了。 "},"asset/prefab.html":{"url":"asset/prefab.html","title":"预制资源","keywords":"","body":"预制资源（Prefab） 对于项目中会重复生成的节点，使用预制体是很有必要的。 创建预制 在场景中将节点编辑好之后，直接将节点从 层级管理器 拖到 资源管理器 中即可完成预制体的创建。 完成创建后，原节点自动变为该预制体实例。 修改预制体 修改预制体有两种方式： 方式一：直接双击 资源管理器中 的预制体文件，此时可以在编辑器中编辑预制体资源，编辑完成之后，点击场景编辑器中的 保存 Prefab 即可保存编辑后的预制体，之后点击 关闭 可返回之前正在编辑的场景。 方式二：在场景中修改任意预制体实例之后，在 属性检查器 中点击 保存到资源 ，可将变更保存到资源。 此处的修改预制体资源在保存之后，再通过该预制体创建的新实例将会与更改后的资源相同，但在修改前已创建的实例并不会发生变化，此时如果想要将实例更新为更改后的预制体资源，操作与 还原预制 相同。 请注意，目前 Cocos Creator 3D 目前尚未添加 prefab 实例与资源自动同步的功能，该功能会在之后的版本中推出，请留意更新公告。 还原预制 在场景中修改了预制实例后，在 属性检查器 中直接点击 从资源回退，即可将预制对象还原为资源中的状态，该操作也可用于当预制资源已改变但实例未更新的情况 还原为普通节点 在编辑时随时可将预制体实例还原为普通节点，只需选中预制体实例在 属性检查器 中点击 还原为普通节点 ，即可变为普通节点。 预制的其他选项 预制体实例的 属性检查器 的其他功能如下： 定位：可快速点位到该实例的资源原型 重新关联到资源：当实例节点变红时（资源丢失），选中想要重新关联的预制资源，再点击 重新关联到资源 可将资源关联 "},"asset/script.html":{"url":"asset/script.html","title":"脚本资源","keywords":"","body":"脚本资源 在 Cocos Creator 3D 中，脚本也是资源的一部分。 关于脚本的详细介绍，可参考：脚本指南 关于脚本资源的创建和使用方法，详情可见：脚本创建 "},"asset/font.html":{"url":"asset/font.html","title":"字体资源","keywords":"","body":"字体资源 使用 Cocos Creator 制作的游戏中可以使用三类字体资源：系统字体，动态字体和位图字体。 其中系统字体是通过调用游戏运行平台自带的系统字体来渲染文字，不需要用户在项目中添加任何相关资源。要使用系统字体，请使用 Label组件 中的 Use System Font 属性。 导入字体资源 动态字体 目前 Cocos Creator 支持 TTF 格式的动态字体。只要将扩展名为 TTF 的字体文件拖拽到 资源管理器 中，即可完成字体资源的导入。 位图字体 位图字体由 fnt 格式的字体文件和一张 png 图片组成，fnt 文件提供了对每一个字符小图的索引。这种格式的字体可以由专门的软件生成，请参考： Glyph Designer Hiero BMFont (Windows) 在导入位图字体时，请务必将 fnt 文件和 png 文件同时拖拽到 资源管理器 中。 导入后的字体在 资源管理器 中显示如下： 注意 为了提高资源管理效率，建议将导入的 fnt 和 png 文件存放在单独的目录下，不要和其他资源混在一起。 使用字体资源 字体资源需要通过 Label 组件来渲染，下面是在场景中创建带有 Label 组件的节点的方法。 使用菜单创建 Label（字体）节点 在 层级管理器 中点击左上角的 创建节点 按钮，并选择 创建渲染节点/Label（文字），就会在场景中创建出一个带有 Label 组件的节点。 您也可以通过主菜单的 节点/创建渲染节点/Label（文字） 来完成创建，效果和上面的方法一样。 关联字体资源 使用上面方法创建的字体组件默认使用系统字体作为关联的资源，如果想要使用导入到项目中的 TTF 或位图字体，可以将您的字体资源拖拽到创建的 Label 组件中的 Font 属性栏中。 这时场景中的字体会立刻用刚才指定的字体资源进行渲染。您也可以根据项目需要，自由的切换同一个 Label 组件的 Font 属性，来使用 TTF 或位图字体。切换字体文件时，Label 组件的其他属性不受影响。 如果要恢复使用系统字体，可以点击 Use System Font 的属性复选框，来清除 Font 属性中指定的字体文件。 拖拽创建 Label（字体）节点 另外一种快捷使用指定资源创建字体节点的方法，是直接从 资源管理器 中拖拽字体文件（TTF 或位图字体都可以）到 层级管理器 中。和上面用菜单创建的唯一区别，是使用拖拽方式创建的文字节点会自动使用拖拽的字体资源来设置 Label 组件的 Font 属性。 "},"asset/audio.html":{"url":"asset/audio.html","title":"声音资源","keywords":"","body":"声音资源 声音资源就是音频文件 对于声音系统来说，其接口主要面向两种需求：长度较长的音乐，长度短的音效。 但对于声音资源来说，两者并没有区别，所有的音频资源在导入编辑器之后，AudioClip 资源通过 AudioSourceComponent 声音系统组件来进行相关的音频操作。关于声音系统的使用，请参考： 声音系统 支持的声音资源的格式 目前引擎的音频系统已经能够支持 web 原生支持的格式： .ogg .mp3 .wav .mp4 .m4a 声音资源的使用 在节点上添加了 AudioSourceComponent 组件之后，将导入的声音资源从 资源管理器 中 拖动到节点AudioSourceComponent组件的 Clip 中即可对该声音资源进行控制： "},"asset/material.html":{"url":"asset/material.html","title":"材质资源","keywords":"","body":"材质资源 材质创建 材质创建方式如下： 或 材质控制着每个模型最终的着色，材质由 Effect 构成，由材质操控 Effect 的着色流程。材质本身也可以看作是 Effect 资源的容器，材质可以任意切换当前要使用的 Effect 资源。下图就是我们创建的材质默认选择的 Effect 资源。 同时，我们还可以通过点击 Effect 属性右边的框要切换当前材质的 Effect。 Effect 创建 Effect 的创建方式跟 Material 的创建方式类似。 创建出来的 Effect 默认是一个 PBR 的 Effect。 以上就是一个材质的创建流程，更多信息可以参考：Effect 书写格式与语法 "},"asset/mesh.html":{"url":"asset/mesh.html","title":"模型资源","keywords":"","body":"模型资源 目前，我们支持 FBX 和 GLTF 两种格式的模型文件。 模型导入 从外部导入编辑器中后，在 资源管理器 中可得到对应的模型资源文件，其目录结构如下：（以 glTF 文件为例，fbx 文件相同） 无动画的模型文件结构如下： 包含动画的模型文件结构如下： 其中： .material 文件为材质文件 .mesh 文件为模型文件 .texture 文件为模型贴图文件 .animation 文件为模型动画文件 .skeleton 文件为模型骨骼文件 .prefab 文件为导入时自动生成的预制体文件 模型使用 将模型文件导入后，直接将模型文件的根节点从资源管理器 拖拽到 层级管理器 中想要放置的节点下即可完成节点创建，此时模型就成功在场景中创建了。 或者也可以将模型文件的节点展开，选中模型文件节点下的 .prefab 文件，从 资源管理器 拖拽到 层级管理器 中同样能够完成创建。 模型资源属性面板说明 当在 资源管理器 中 选中模型资源文件时（ .fbx 或 .gltf ）,在 属性检查器 中可以设置模型资源的相关属性： DumpMaterial ：当对模型文件自带的材质不满意想要修改时，需开启此选项，将文件结构目录下的材质文件 Dump 出模型资源中，此时就可以进行 材质的调整修改了 Normals 法线信息：有 Optional，Exclude，Require，Recalculate 四种选项 Tangents 切空间信息：有 Optional，Exclude，Require，Recalculate 四种选项 SkipValidation ：是否跳过标准检测 关于 glTF 目前我们的引擎已支持 glTF 2.0 规范，但暂时不支持以下功能： Sparse accessor morph target "},"asset/anim.html":{"url":"asset/anim.html","title":"动画资源","keywords":"","body":"动画资源 编辑器自定义动画 编辑器内自定义动画的创建以及格式请参考：动画创建，格式说明 "},"asset/texture.html":{"url":"asset/texture.html","title":"纹理贴图资源","keywords":"","body":"纹理贴图资源 纹理贴图资源是一种用于程序采样的资源，如模型上的贴图、精灵上的UI。 当程序渲染UI或者模型时，会对相应的纹理进行采样，然后填充在模型网格上，再加上光照等等一系列处理便渲染出了整个场景。 纹理资源可由 ImageAsset 转化而成，一些通用的图像交换格式如 png , jpeg 等等都可为 ImageAsset。 Texture2D Texture2D 是纹理资源的一种，通常用于 3D 模型的渲染，如模型材质中的反射贴图、环境光遮罩贴图等等。 在 Cocos Creator 3D 中的 Texture2D: 注：texture 类型即为 Texture2D 资源。 调整 Texture2D 的属性 当导入一张 ImageAsset 时，默认会将其设置为 Texture2D 的类型，这时会在原资源上会生成一个或多个子资源，点击原资源前的箭头便可以看到所有的子资源，如下动图所示： 选中生成的 Texture2D 子资源后可以看到以下面板 子资源 Texture2D 的属性面板 以下介绍了面板的所有属性： 属性 解释 anisotropy 各项异性值 minFilter 缩小过滤算法 magFilter 放大过滤算法 mipFilter 多级纹理过滤算法 wrapS S（U）方向纹理寻址模式 wrapT T（V）方向纹理寻址模式 使用 Texture2D Texture2D 是使用范围非常广泛的资源，在属性面板上任何标记为 cc.Texture2D 类型的属性，都可以拖入 Texture2D 类型的资源。 使用场景主要为编辑器环境与动态获取使用 在编辑器中，只需要将资源拖入即可； 动态使用时，需要先获取 ImageAsset 资源，然后根据获取到 ImageAsset 实例化出 Texture2D 资源； TextureCube TextureCube 为立方体纹理，可用于设置场景的天空盒，可以通过设置全景图 ImageAsset 为 TextureCube 类型获得，也可以通过制作 CubeMap 资源获得，在场景的天空盒章节有详细的使用和制作方式。 在 Cocos Creator 3D 中通过全景图获得的 TextureCube: 在 Cocos Creator 3D 中通过制作 CubeMap 获得的 TextureCube: 阅读天空盒 章节去了解更多 TextureCube 的使用与制作 CubeMap 的方式。 "},"concepts/scene/transform.html":{"url":"concepts/scene/transform.html","title":"坐标系和变换","keywords":"","body":"坐标系和变换 Cocos Creator 3D 坐标系 Cocos Creator 3D 的坐标系与 Cocos Creator 和 cocos2d-x 引擎的坐标系完全一致，采用笛卡尔右手坐标系，原点在左下角，x 向右，y 向上，z 向外。 屏幕坐标系 Cocos Creator 3D 的屏幕坐标系原点为屏幕左下角，x 向右，y 向上。 世界坐标系（World Coordinate）和本地坐标系（Local Coordinate） 世界坐标系也称为绝对坐标系，在 Cocos Creator 3D 游戏开发中表示场景空间内的统一坐标体系，「世界」就用来表示我们的游戏场景。 本地坐标系也称为相对坐标系，是和节点相关联的坐标系。每个节点都有独立的坐标系，当节点移动或改变方向时，和该节点关联的坐标系将随之移动或改变方向。 Cocos Creator 3D 中的 节点（Node） 之间可以有父子关系的层级结构，我们修改节点的 位置（Position） 属性设定的节点位置是该节点相对于父节点的 本地坐标系 而非世界坐标系。最后在绘制整个场景时 Cocos Creator 3D 会把这些节点的本地坐标映射成世界坐标系坐标。 子节点的本地坐标系 当场景中的节点存在父子层级关系的结构时，如下图所示： 我们按照以下的流程确定每个节点在世界坐标系下的位置： 从场景根级别开始处理每个节点，上图中 NodeA 就是一个根级别节点。首先根据 NodeA 的 位置（Position） 属性，在世界坐标系中确定 NodeA 的显示位置和坐标系原点位置。 接下来处理 NodeA 的所有直接子节点，也就是上图中 NodeB 以及和 NodeB 平级的节点。根据 NodeB 的位置，在 NodeA 的本地坐标系中确定 NodeB 在场景空间中的位置和坐标系原点位置。 之后不管有多少级节点，都继续按照层级高低依次处理，每个节点都使用父节点的坐标系和自身位置来确定在场景空间中的位置。 变换属性 节点主要包括 位置（Position）、旋转（Rotation）、缩放（Scale） 变换属性: "},"editor/preview/preview-guid.html":{"url":"editor/preview/preview-guid.html","title":"预览流程简介与常见错误处理","keywords":"","body":"预览流程简介与常见错误处理 流程简介 由于目前编辑器仅支持浏览器预览，这里仅介绍浏览器预览的流程。 浏览器预览本质上是编辑器开启了一个 express 服务器，在点击预览时打开用户的默认浏览器去访问预览 URL。预览模板里写了一些加载引擎和初始化场景的简单逻辑，而关于用户资源加载主要还是依赖于 setting.js 的生成，因为 setting.js 里面记载了当前项目的资源、脚本以及项目设置信息。预览的 setting.js 是调用构建插件的接口生成的，因而如果 setting.js 没有正常生成可以打开构建调试工具查看。 常见错误处理 在遇到预览无法正常显示时，请先打开开发者工具的 NetWork 查看此时是否有资源或者脚本加载失败。 setting.js 加载失败 在寻找这个问题的原因之前，请先确保在预览前编辑器内没有报错信息。 setting.js 加载失败说明 setting.js 没能正常生成，这时候可以打开 开发者 ——> 构建调试工具 查看是否有报错信息。正常情况下，如果生成失败基本会有对应的报错提示。比较常见的是脚本错误，因为在生成 settings 时会先加载一遍项目脚本，如果项目脚本内存在不合法的书写，那么在加载过程中会抛出异常导致 setting.js 生成失败。具体报错的脚本信息可以参考报错信息内的提示，通常在此处的报错内容，有效信息都是资源的 uuid ，可以复制对应的 uuid 到资源管理器里面搜索定位该脚本。 关于 setting.js 具体的生成流程，可以参考构建流程简介。预览的 setting.js 生成和在只勾选了调试模式的生成规则基本一样，区别在于预览只梳理资源信息，但并不会进行资源的打包生成。 资源加载 404 请使用报 404 的资源 uuid 到编辑器的资源管理器搜索对应资源，解决好该问题即可。 "},"editor/scene/camera-gizmo.html":{"url":"editor/scene/camera-gizmo.html","title":"摄像机Gizmo","keywords":"","body":"摄像机Gizmo 摄像机Gizmo 用于显示摄像机的裁剪范围，摄像机相关的信息可以查看摄像机介绍 透视像机（Perspective） 透视摄像机Gizmo 显示了由远近裁剪面，FOV，所构成的四棱台图形。可以使用方块控制点来编辑像机的远、近平面距离，FOV。 正交像机（Ortho） 正交摄像机Gizmo 显示了由远近裁剪面、正交高度，所构成的长方体图形。可以使用方块控制点来编辑像机的远、近平面距离，正交高度。 "},"editor/scene/collider-gizmo.html":{"url":"editor/scene/collider-gizmo.html","title":"碰撞器Gizmo","keywords":"","body":"碰撞器Gizmo 有关 Cocos Creator 3D 的碰撞器信息可以查看物理介绍 盒碰撞器（Box Collider） 盒碰撞器Gizmo 显示了盒子的长宽高，同时可以使用方块控制点来编辑长宽高。 球碰撞器（Sphere Collider) 球碰撞器Gizmo 显示了球的大小，同时可以使用方块控制点来编辑球的半径。 "},"editor/scene/light-gizmo.html":{"url":"editor/scene/light-gizmo.html","title":"灯光Gizmo","keywords":"","body":"灯光Gizmo 有关 Cocos Creator 3D 的灯光信息可以查看光源介绍 方向光（Directional Light) 方向光Gizmo 显示了当前方向光的方向 球面光（Sphere Light) 球面光Gizmo显示了光源的颜色以及光源范围，同时可以使用方块控制点来编辑光源的范围。 聚光（Spot Light） 聚光Gizmo 显示了光源的颜色、光源范围以及聚光的角度，同时可以使用方块控制点来编辑光源的范围和角度。 "},"editor/scene/particle-system-gizmo.html":{"url":"editor/scene/particle-system-gizmo.html","title":"粒子系统Gizmo","keywords":"","body":"粒子系统Gizmo 粒子系统的 Gizmo 主要用于可视化粒子系统的ShapeModule 方块（Box） 方块Gizmo 显示了方块的长宽高，同时可以使用方块控制点来编辑长宽高。 球（Sphere） 球Gizmo 显示了球的大小，同时可以使用方块控制点来编辑球的半径。 半球（Hemisphere） 半球Gizmo 显示了半球的大小，同时可以使用方块控制点来编辑半球的半径。 圆（Circle） 圆Gizmo 显示了半球的大小，同时可以使用方块控制点来编辑圆的半径。 圆锥（Cone） 圆锥Gizmo 显示了圆锥的形状，同时可以使用方块控制点来编辑圆锥的半径、角度、高度。 "},"editor/scene/transform-gizmo.html":{"url":"editor/scene/transform-gizmo.html","title":"变换工具Gizmo","keywords":"","body":"变换工具Gizmo 我们主要通过主窗口工具栏左上角的一系列 变换工具 来将场景中的节点按我们希望的方式布置。 移动变换工具 移动变换工具 是打开编辑器时默认处于激活状态的变换工具，之后这个工具也可以通过点击位于主窗口左上角工具栏第一个按钮来激活，或者在使用场景编辑器时按下快捷键 W，即可激活 移动变换工具。 选中任何节点，就能看到节点中心（或锚点所在位置）上出现了由红绿蓝三个箭头和红绿蓝三个方块组成的移动控制手柄 控制手柄 是指场景编辑器中在特定编辑状态下显示出的可用鼠标进行交互操作的控制器。这些控制器只用来辅助编辑，不会在游戏运行时显示。 移动变换工具激活时： 按住红色、绿色、蓝色箭头拖拽鼠标，将分别在 x、y、z 轴方向上移动节点； 按住红色、绿色、蓝色方块拖拽鼠标，将分别在 y-z平面、x-z平面、x-y平面上移动节点； 旋转变换工具 点击主窗口左上角工具栏第二个按钮，或在使用场景编辑器时按下 E 快捷键，即可激活 旋转变换工具。 旋转变换工具的手柄主要是三个相互正交的圆组成（2D视图下由一个箭头和一个圆环组成）。拖拽圆环上任意一点就可以旋转节点，放开鼠标之前，可以在控制手柄上看到当前旋转的范围。 旋转变换工具激活时： 按住红色、绿色、蓝色圆圈拖拽鼠标，将分别在绕 x、y、z 轴旋转节点； 缩放变换工具 点击主窗口左上角工具栏第三个按钮，或在使用场景编辑器时按下 R 快捷键，即可激活 缩放变换工具。 缩放工具由三个头部是正方体的坐标轴以及一个中心正方体组成。 缩放变换工具激活时： 按住红色、绿色、蓝色方块拖拽鼠标，将分别在 x、y、z 轴方向上缩放节点； 按住灰色方块拖拽鼠标，将同时在x、y、z轴上缩放节点； 矩形变换工具 点击主窗口左上角工具栏第四个按钮，或在使用场景编辑器时按下 T 快捷键，即可激活 矩形变换工具。 矩形变换工具由四个顶点控制点、四个边控制点、一个中心控制点组成。 矩形变换工具激活时： 拖拽控制手柄的任一顶点控制点，可以在保持对角顶点位置不变的情况下，同时修改UI节点尺寸中的 width 和 height 属性。 拖拽控制手柄的任一边控制点，可以在保持对边位置不变的情况下，修改UI节点尺寸中的 width 或 height 属性。 在UI元素的排版中，经常会需要使用 矩形变换工具 直接精确控制节点四条边的位置和长度。而对于必须保持原始图片宽高比的图像元素，通常不会使用矩形变换工具来调整尺寸。 "},"editor/scripting/":{"url":"editor/scripting/","title":"index","keywords":"","body":""},"function-guide/":{"url":"function-guide/","title":"功能地图","keywords":"","body":"功能地图 功能地图介绍了 Cocos Creator 3D 中的所有功能索引，在这里你可以快速浏览所有的功能。 "},"getting-started/install/":{"url":"getting-started/install/","title":"安装和启动","keywords":"","body":"安装和启动 下载 Cocos Creator 安装 选择系统对应的版本下载后，启动安装程序。 设置语言 选择安装目录 等待安装完毕 启动Cocos Creator "},"getting-started/introduction/":{"url":"getting-started/introduction/","title":"关于 Cocos Creator 3D","keywords":"","body":"关于 Cocos Creator 3D 产品定位 Cocos Creator 3D是在Cocos Creator结构的基础上增加3D渲染流程。 工作流程说明 在开发阶段，Cocos Creator 已经能够为用户带来巨大的效率和创造力提升，但我们所提供的工作流远不仅限于开发层面。对于成功的游戏来说，开发和调试、商业化 SDK 的集成、多平台发布、测试、上线这一整套工作流程不光缺一不可，而且要经过多次的迭代重复。 Cocos Creator 将整套手机页游解决方案整合在了编辑器工具里，无需在多个软件之间穿梭，只要打开 Cocos Creator 编辑器，各种一键式的自动化流程就能花最少的时间精力，解决上述所有问题。开发者就能够专注于开发阶段，提高产品竞争力和创造力！ 创建或导入资源 将图片、声音等资源拖拽到编辑器的 资源管理器 面板中，即可完成资源导入。 此外，你也可以在编辑器中直接创建场景、预制、动画、脚本、粒子等各类资源。 建造场景内容 项目中有了一些基本资源后，我们就可以开始搭建场景了，场景是游戏内容最基本的组织方式，也是向玩家展示游戏的基本形态。 我们通过 场景编辑器 将添加各类节点，负责展示游戏的美术音效资源，并作为后续交互功能的承载。 添加组件脚本，实现交互功能 我们可以为场景中的节点挂载各种内置组件和自定义脚本组件，来实现游戏逻辑的运行和交互。包括从最基本的动画播放、按钮响应，到驱动整个游戏逻辑的主循环脚本和玩家角色的控制。几乎所有游戏逻辑功能都是通过挂载脚本到场景中的节点来实现的。 一键预览和发布 搭建场景和开发功能的过程中，你可以随时点击预览来查看当前场景的运行效果。使用手机扫描二维码，可以立即在手机上预览游戏。当开发告一段落时，通过 构建发布 面板可以一键发布游戏到包括桌面、手机、Web 等多个平台。 功能特性 Cocos Creator 功能上的突出特色包括： 脚本中可以轻松声明可以在编辑器中随时调整的数据属性，对参数的调整可以由设计人员独立完成。 支持智能画布适配和免编程元素对齐的 UI 系统可以完美适配任意分辨率的设备屏幕。 专为 2D 游戏打造的动画系统，支持动画轨迹预览和复杂曲线编辑功能。 动态语言支持的脚本化开发，使得动态调试和移动设备远程调试变得异常轻松。 借助 Cocos2d-x 引擎，在享受脚本化开发的便捷同时，还能够一键发布到各类桌面和移动端平台，并保持原生级别的超高性能 脚本组件化和开放式的插件系统为开发者在不同深度上提供了定制工作流的方法，编辑器可以大尺度调教来适应不同团队和项目的需要。 架构特色 Cocos Creator 包含游戏引擎、资源管理、场景编辑、游戏预览和发布等游戏开发所需的全套功能，并且将所有的功能和工具链都整合在了一个统一的应用程序里。 它以数据驱动和组件化作为核心的游戏开发方式，并且在此基础上无缝融合了 Cocos 引擎成熟的 JavaScript API 体系，能够一方面适应 Cocos 系列引擎开发者用户习惯，另一方面为美术和策划人员提供前所未有的内容创作生产和即时预览测试环境。 编辑器在提供强大完整工具链的同时，提供了开放式的插件架构，开发者能够用 HTML + JavaScript 等前端通用技术轻松扩展编辑器功能，定制个性化的工作流程。 以下，是 Cocos Creator 的技术架构图 图一 图二 从图中我们可以看出，编辑器是由 Electron 驱动再结合引擎所搭建的开发环境，引擎则负责提供许多开发上易于使用的组件和适配各平台的统一接口。 引擎和编辑器的结合，带来的是数据驱动和组件化的功能开发方式，以及设计和程序两类人员的完美分工合作： 设计师在场景编辑器中搭建场景的图像表现 程序员开发可以挂载到场景任意物体上的功能组件 设计师负责为需要展现特定行为的物体挂载组件，并通过调试改善各项参数 程序员开发游戏所需要的数据结构和资源 设计师通过图形化的界面配置好各项数据和资源 -（就这样从简单到复杂，各种你能想像到的工作流程都可以实现） 以工作流为核心的开发理念，让不同职能的开发者能够快速找到最大化自己作用的工作切入点，并能够默契流畅的和团队其他成员配合。 使用说明 Cocos Creator 是一个支持 Windows 和 Mac 跨平台运行的应用程序，双击即可启动运行。相比传统的 Cocos2d-x 工作流程，将配置开发环境的要求完全免除，运行之后就可以立刻开始游戏内容创作或功能开发。 在数据驱动的工作流基础上，场景的创建和编辑成为了游戏开发的中心，设计工作和功能开发可以同步进行，无缝协作，不管是美术、策划还是程序员，都可以在生产过程的任意时刻点击预览按钮，在浏览器、移动设备模拟器或移动设备真机上测试游戏的最新状态。 程序员和设计人员现在可以实现各式各样的分工合作，不管是先搭建场景，再添加功能，还是先生产功能模块再由设计人员进行组合调试，Cocos Creator 都能满足开发团队的需要。脚本中定义的属性能够以最适合的视觉体验呈现在编辑器中，为内容生产者提供便利。 场景之外的内容资源可以由外部导入，比如图片、声音、图集、骨骼动画等等，除此之外我们还在不断完善编辑器生产资源的能力，包括目前已经完成的动画编辑器，美术人员可以使用这个工具制作出非常细腻富有表现力的动画资源，并可以随时在场景中看到动画的预览。 最后，开发完成的游戏可以通过图形工具一键发布到各个平台，从设计研发到测试发布，Cocos Creator 全部帮您搞定。 "},"physics/physics-system.html":{"url":"physics/physics-system.html","title":"物理系统","keywords":"","body":"物理系统 物理系统（PhysicsSystem）是一个模拟真实物理行为的系统，它负责对物理世界中的元素进行物理计算，比如计算各物体是否产生碰撞，以及物体的受力情况。所有元素计算完成后，还会更新到场景世界中，从而使游戏对象产生相应的物理行为。 目前 Cocos Creator 3D 中物理计算所处的流程 ： 所有 Update 结束后 → 物理计算 → 开始渲染 场景世界与物理世界，如图： 物理系统属性与接口 目前物理系统的属性暂时只能通过代码去设置，以后将会增加新的面板，使得某些物理系统的相关属性设置更好友好，请留意更新公告。 属性 解释 enable 是否开启物理系统，默认为 true allowSleep 是否允许物理系统自动休眠，默认为 true maxSubStep 物理每帧模拟的最大子步数，默认为 2 deltaTime 物理每步模拟消耗的时间，注意不是每帧，默认为 1 / 60 gravity 物理世界的重力值，默认为 (0, -10, 0) 目前可以用此方式获取到物理系统实例： PhysicsSystem.ins 注：Builtin 中不支持以上物理模拟相关的属性。 继续前往 物理组件 说明文档。 "},"physics/physics-use/physics-collider.html":{"url":"physics/physics-use/physics-collider.html","title":"ColliderComponent","keywords":"","body":"ColliderComponent 获取 Collider 组件 Cocos Creator 3D 目前支持两种语言进行开发，分别为 JavaScript 和 TypeScript。 注：TypeScript 具有良好的语法分析和类型提示，推荐使用 TypeScript 进行开发。 以获取 BoxColliderComponent 为例，在 JavaScript 中可以用以下方式获取相应的Collider组件： this.getComponent('cc.BoxColliderComponent') this.getComponent(cc.BoxColliderComponent) 在 TypeScript 中可以用以下方式获取相应的Collider组件： 上述 javascript 使用的方式 this.getComponent(BoxColliderComponent) (推荐使用，提示导入时，注意导入位置为“ cc ”) 注：若无智能导入提示，请检查工作目录是不是在工程的顶层，以及是否使用较新的 Vs Code 编辑器。 碰撞器和触发器 Collider 组件具有 isTrigger 属性，当 isTrigger 为 true 时，表示为碰撞器，反之为触发器。 注：关于碰撞器和触发器的区别将在 物理事件 中介绍。 Collider 和 RigidBody 的关系 Collider 和 RigidBody 组件都是为了服务于物理元素，分别操控着物理元素上的一部分属性。这也意味着要了解它们之间的关系，需要先了解 Cocos Creator 3D 中的物理元素是如何构成的。 元素如何构成 在物理简介中，介绍了一个物理元素是由 Collider 和 RigidBody 组件相互组合而成的，其中指出了一个元素只能有一个或零个 RigidBody 组件，但可以有多个 Collider 组件。 这便也意味着一个问题：父子节点链上的 Collider 如何代表物理元素？ 目前有两个思路： 每个节点只要有物理组件，就是一个元素，也就是说父子节点的组件无依赖关系，需要多个形状，往该节点上添加相应的 Collider 组件。 从自身节点开始往父链节点上搜索，如果找到了 RigidBody 组件，则将自身的 Collider 组件绑定到该节点上，否则，整条链上的 Collider 组件共享一个 RigidBody ，元素对应的节点是最顶层的 Collider 所对应的节点。 这两个思路各有利弊： 思路 1 不够直观，当需要多个形状在一起的时候，只能往一个节点上加，需要显示出形状时，需要增加子节点模型。 思路 1 调整参数时，需要调整两个地方，分别为子节点的位置信息和父节点上对应 Collider 组件的数据信息。 思路 2 增加了节点耦合，节点更新时，需要更新相应的依赖节点。 思路 2 在节点链被破坏时，需要维护内容更多，节点链在反复被破坏时需要处理更复杂的逻辑。 注：Cocos Creator 3D 的物理目前使用的是第一个思路，后续可能会进行调整，请留意版本更新公告。 Collider 的 attachedRigidbody 属性 在 Collider 组件中具有一个 attachedRigidbody 属性，这个属性可以获得当前 Collider 组件所绑定的 RigidBody 组件，但是请注意以下几点： 在自身节点无 RigidBody 组件时，该属性返回为 null attachedRigidbody 是一个只能获取并且只读的属性 继续前往 Rigidbody 组件 说明文档。 "},"physics/physics-use/physics-event.html":{"url":"physics/physics-use/physics-event.html","title":"物理事件","keywords":"","body":"物理事件 Cocos Creator 3D 的物理事件有触发事件和碰撞事件，分别由触发器和碰撞器产生。 触发器和碰撞器 当碰撞时，触发器不会产生物理行为，而碰撞器会产生物理行为，所以触发器是只进行碰撞检测的 Collider，而碰撞器是既进行碰撞检测，又进行物理模拟的 Collider。 两者的区别 触发器不会与其它触发器或者碰撞器做更精细的检测。 碰撞器与碰撞器会做更精细的检测，并会提供因碰撞产生的一些额外的数据，如碰撞点、法线等。 注：设置一个 Collider 组件为触发器，可以通过设置 Collider 组件的 isTrigger 属性。 触发事件和碰撞事件 触发事件 Cocos Creator 3D 中的触发事件由触发器生成，目前分为三种 onTriggerEnter、onTriggerStay、onTriggerExit，分别代表着触发开始，触发保持，触发结束。 监听触发事件，可以通过注册事件的方式来添加触发后的回调，以下步骤可以完成触发事件的监听： 通过 this.getComponent(ColliderComponent) 获取到 ColliderComponent 通过 ColliderComponent 的 on 或者 once 方法注册相应事件的回调 代码示例： public start () { let Collider = this.getComponent(ColliderComponent); Collider.on('onTriggerStay', this.onTrigger, this); } private onTrigger (event: ITriggerEvent) { console.log(event.type, event); } 碰撞事件 Cocos Creator 3D 中的碰撞事件由碰撞器生成，目前分为三种 onCollisionEnter、onCollisionStay、onCollisionExit，分别代表着碰撞开始，碰撞保持，碰撞结束。 监听碰撞事件，可以通过注册事件的方式来添加碰撞后的回调，以下步骤可以完成碰撞事件的监听： 通过 this.getComponent(ColliderComponent) 获取到 ColliderComponent 通过 ColliderComponent 的 on 或者 once 方法注册相应事件的回调 代码示例： public start () { let Collider = this.getComponent(ColliderComponent); Collider.on('onCollisionStay', this.onCollision, this); } private onCollision (event: ICollisionEvent) { console.log(event.type, event); } 注：ColliderComponent 是所有碰撞组件的父类。 两者的区别 触发事件由触发器生成，碰撞事件由碰撞器生成。 触发事件可以由一个触发器和另一个触发器或者另一个碰撞器产生，而碰撞事件需要由两个碰撞器产生。 继续前往 分组和掩码 说明文档。 "},"physics/physics-use/physics-group-mask.html":{"url":"physics/physics-use/physics-group-mask.html","title":"分组和掩码","keywords":"","body":"分组和掩码 在 Cocos Creator 3D 中，物理组件提供了设置组和掩码的接口，以下代码示例介绍了所有的接口 分组 设置分组值，以下代码中的 group 的值二进制为 011，分组可看作是存在于分组 0 和分组 1 中。 const group = 1 Collider.setGroup(group); 获取分组值，此示例中为 3，将 3 转为二进制为 011，可得分组为存在于分组 0 和分组 1 中。 Collider.getGroup(); 添加分组值，上述代码基础上，经过以下代码后，分组变为存在于分组 0 和分组 1 和分组 2 中。此时，分组值为 0111(二进制)，所以存在于分组 0、1、2 中。 const group = 1 Collider.addGroup(group); 减少分组值，上述代码基础上，经过以下代码后，分组变为存在于分组 0 和分组 1 中。此时，分组值为 0011(二进制)，所以存在于分组 0、1 中。 const group = 1 Collider.removeGroup(group); 上述方法接收参数均为十进制数字，为方便理解，此处用二进制解释，开发者熟悉后也可直接传入十进制数字进行分组操作。 掩码 设置掩码值，以下代码中的 mask 的值二进制为 011，表示检测的分组为分组 0 和分组 1 的。 const mask = 1 Collider.setMask(mask); 获取掩码值，此示例中为 3，将 3 转为二进制为 011，可得要检测的为分组 0 和分组 1 的内容。 console.log(Collider.getMask()); 添加掩码值，上述代码的基础上，经过以下代码后，该掩码表示检测的分组为分组 0 和分组 1 和分组 2 的。此时，掩码值为 0111(二进制)，所以检测分组 0、1、2 的内容。 const mask = 1 Collider.addMask(mask); 减少掩码值，上述代码的基础上，经过以下代码后，该掩码表示检测的分组为分组 0 或分组 1 的。此时，掩码值为 0011(二进制)，所以检测分组 0、1 的内容。 const mask = 1 Collider.removeMask(mask); 注：灵活使用分组和掩码可以减少额外检测的消耗。 回到 物理使用 说明文档。 "},"physics/physics-use/physics-rigidbody.html":{"url":"physics/physics-use/physics-rigidbody.html","title":"RigidBodyComponent","keywords":"","body":"RigidBodyComponent 获取刚体组件 与 ColliderComponent 中获取组件的方式类似，以下为 TypeScript 的代码示例： const rigidBody = this.getComponent(RigidBodyComponent); 休眠和唤醒刚体 代码示例： if (rigidBody.isAwake) { rigidBody.sleep(); // 休眠 } if (rigidBody.isSleeping) { rigidBody.wakeUp(); // 唤醒 } 让刚体运动起来 让刚体运动，需要改变刚体的速度，目前改变刚体的速度有以下几种方式： 通过重力 刚体组件提供了useGravity属性，设置为true将受到重力的作用。 通过力 刚体组件提供了applyForce接口，签名为：applyForce (force: Vec3, relativePoint?: Vec3)。 根据牛顿第二定律F = m * a，对刚体某点上施加力，这样就有了加速度，随着时间变化，速度会随加速度变化，就会使得刚体运动起来。 代码示例：rigidBody.applyForce(new Vec3(200, 0, 0)); 通过冲量 刚体组件提供了applyImpulse接口，签名为：applyImpulse (impulse: Vec3, relativePoint?: Vec3)。 根据动量守恒的方程式 F * Δt = m * Δv，对刚体某点施加冲量，随着时间增加，但物体的质量是恒定的，速度就会产生变化，刚体就会运动起来。 代码示例：rigidBody.applyImpulse(new Vec3(5, 0, 0)); 通过直接改变速度 线性速度 刚体组件提供了setLinearVelocity接口，可用于改变线性速度，签名为：setLinearVelocity (value: Vec3)。 旋转速度 刚体组件提供了setAngularVelocity接口，可用于改变旋转速度，签名为：setAngularVelocity (value: Vec3)。 代码示例： rigidBody.setLinearVelocity(new Vec3(5, 0, 0)); // 改变线性速度 rigidBody.setAngularVelocity(new Vec3(5, 0, 0)); // 改变旋转速度 限制刚体的运动 通过休眠 休眠刚体时，会将刚体所有的力和速度清空，这将使刚体停下来。 注：目前，施加力或冲量，以及改变速度会重新唤醒刚体，后续可能会进行调整，请留意版本更新公告。 通过阻尼 刚体组件提供了linearDamping和angularDamping属性，分别用于设置线性和旋转的阻尼。 阻尼参数的范围可以在 0 到无穷之间，0 意味着没有阻尼，无穷意味着满阻尼，通常来说，阻尼的值应在 0 到 0.1 之间。 通过固定旋转 刚体组件提供了fixedRotation属性，默认为 false，设置为 true 可以用于固定刚体，使其不会产生旋转。 通过因子 刚体组件提供了linearFactor和angularFactor属性，分别用于设置线性和旋转的因子。 因子是Vec3的类型，相应分量的数值用于缩放相应轴向的速度变化，默认值都为 1，代表着缩放为 1 倍，即无影响。 注：将因子某分量值设置为 0，可以固定某个轴向的移动或旋转，如果要完全固定旋转，请用 fixedRotation。 继续前往 物理事件 说明文档。 "},"scripting/language-support.html":{"url":"scripting/language-support.html","title":"语言支持","keywords":"","body":"语言支持 Javascript Cocos Creator 3D 对脚本中 Javascript 语言的支持为 ECMAScript 2015。 Typescript Cocos Creator 3D 对脚本中 Typescript 语言的支持为 Typescript 3.5.0。 Typescript 脚本的编译效果就相当于使用了以下编译选项的 tsc 进行编译： { \"compilerOptions\": { \"target\": \"es2015\", \"module\": \"es2015\", \"experimentalDecorators\": true, \"strict\": false, \"noImplicitAny\": false, } } Typescript 脚本的编译完全由 Cocos Creator 3D 完成， 这意味着项目中 tsconfig.json 的绝大多数编译选项并不影响编译， 但以下选项将被 Cocos Creator 3D 读取并影响编译： compilerOptions.baseUrl 和 tsc 的语义相同，见 ； compilerOptions.paths 和 tsc 的语义相同，见 。 你仍然可以在项目中使用 tsconfig.json 以配合 IDE 实现类型检查等功能。 为了使得 IDE 的 Typescript 检查功能 和 Cocos Creator 3D 行为兼容， 你需要额外注意一些事项，见 tsconfig。 "},"scripting/tsconfig.html":{"url":"scripting/tsconfig.html","title":"tsconfig","keywords":"","body":"tsconfig 项目中 tsconfig.json 的绝大多数编译选项并不影响 Cocos Creator 3D 对 Typescript 的编译。 因此，你需要小心配置其中的某些选项，以使得 IDE 的检查功能和 Cocos Creator 3D 的编译行为一致。 以下选项不应当显式修改： compilerOptions.target compilerOptions.module 例如，若将 tsconfig.json 设置为： { \"compilerOptions\": { \"target\": \"es5\", \"module\": \"cjs\" } } 那么脚本代码： const myModule = require(\"path-to-module\"); 在（使用 tsc 作为检查器的）IDE 中不会引起错误，因为compilerOptions.module 设置为了 cjs。 然而 Cocos Creator 3D 隐含的 compilerOptions.module 是 es2015， 因此在运行时它可能提示 \"require 未定义\" 等错误。 脚本代码： const mySet = new Set(); 对于 Cocos Creator 3D 来说是合法的，但 IDE 可能会报告错误： 因为compilerOptions.target 设置为了 es5：ECMAScript 2015 才引入 Set。 对于其他选项，你可以自由修改。 例如，当你希望禁止你项目中所有 Typscript 脚本对隐式 any 的使用， 你就可以在 tsconfig.json 中将 compilerOptions.noImplicitAny 设为 true， 如此当你用 Visual Studio Code 等 IDE 检查该文件时就会收到相应的错误提示。 对于大多数项目而言，tsconfig 的某些选项是固定的， 例如，compilerOptions.target、compilerOptions.module 以及 Cocos Creator 3D 的类型声明文件位置等。 由于 tsc 的良好设计，extends 选项使得 tsconfig.json 可以是级联的。 Cocos Creator 3D 意识到了这一点，因此， 固定的 tsconfig 选项被放置在 {项目路径}/tmp/tsconfig.cocos.json 下， 并由 Cocos Creator 3D 管理。 于是，项目根路径下的 tsconfig 可以如下配置以共享这些固定选项： { extends: './tmp/tsconfig.cocos.json', compilerOptions: { /* 自定义的 tsconfig 选项 */ } } 所幸，当你创建新项目时，编辑器将自动为你生成这样的 tsconfig。 "},"ui-system/components/editor/graphics/arc.html":{"url":"ui-system/components/editor/graphics/arc.html","title":"arc","keywords":"","body":"arc arc() 方法创建弧/曲线（用于创建圆或部分圆）。 提示：如需通过 arc() 来创建圆，请把起始角设置为 0，结束角设置为 2*Math.PI。 参数 描述 x 圆的中心的 x 坐标。 y 圆的中心的 y 坐标。 r 圆的半径。 sAngle 起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。 eAngle 结束角，以弧度计。 counterclockwise 可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.arc(100,75,50,0,1.5*Math.PI); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/bezierCurveTo.html":{"url":"ui-system/components/editor/graphics/bezierCurveTo.html","title":"bezierCurveTo","keywords":"","body":"bezierCurveTo bezierCurveTo() 方法通过使用表示三次贝塞尔曲线的指定控制点，向当前路径添加一个点。 提示：三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。 参数 描述 cp1x 第一个贝塞尔控制点的 x 坐标 cp1y 第一个贝塞尔控制点的 y 坐标 cp2x 第二个贝塞尔控制点的 x 坐标 cp2y 第二个贝塞尔控制点的 y 坐标 x 结束点的 x 坐标 y 结束点的 y 坐标 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.moveTo(20,20); ctx.bezierCurveTo(20,100,200,100,200,20); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/circle.html":{"url":"ui-system/components/editor/graphics/circle.html","title":"circle","keywords":"","body":"circle circle() 方法创建椭圆。 参数 描述 cx 圆的中心的 x 坐标。 cy 圆的中心的 y 坐标。 r 圆的半径。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.circle(200,200, 200); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/clear.html":{"url":"ui-system/components/editor/graphics/clear.html","title":"clear","keywords":"","body":"clear clear() 清空所有路径。 实例 update: function (dt) { var ctx = node.getComponent(cc.GraphicsComponent); ctx.clear(); ctx.circle(200,200, 200); ctx.stroke(); } 返回 绘图组件 "},"ui-system/components/editor/graphics/close.html":{"url":"ui-system/components/editor/graphics/close.html","title":"close","keywords":"","body":"close close() 方法创建从当前点到开始点的路径。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.moveTo(20,20); ctx.lineTo(20,100); ctx.lineTo(70,100); ctx.close(); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/ellipse.html":{"url":"ui-system/components/editor/graphics/ellipse.html","title":"ellipse","keywords":"","body":"ellipse ellipse() 方法创建椭圆。 参数 描述 cx 圆的中心的 x 坐标。 cy 圆的中心的 y 坐标。 rx 圆的 x 半径。 ry 圆的 y 半径。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.ellipse(200,100, 200,100); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/fill.html":{"url":"ui-system/components/editor/graphics/fill.html","title":"fill","keywords":"","body":"fill fill() 方法填充当前的图像（路径）。默认颜色是白色 注释：如果路径未关闭，那么 fill() 方法会从路径结束点到开始点之间添加一条线，以关闭该路径，然后填充该路径。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.rect(20,20,150,100); ctx.fillColor = cc.Color.GREEN; ctx.fill(); 返回 绘图组件 "},"ui-system/components/editor/graphics/fillColor.html":{"url":"ui-system/components/editor/graphics/fillColor.html","title":"fillColor","keywords":"","body":"fillColor fillColor 属性设置或返回用于填充的颜色。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.fillColor = new cc.Color().fromHEX('#0000ff'); ctx.rect(20,20,250,200); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/":{"url":"ui-system/components/editor/graphics/","title":"绘图系统","keywords":"","body":"绘图系统 本章将详细介绍 Cocos Creator 的绘画组件接口的使用。 新建一个空节点，然后点击 属性检查器 下方的 添加组件 按钮，从 添加渲染组件 中选择 Graphics，即可添加 Graphics 组件到节点上。 绘图接口 路径 方法 功能说明 moveTo (x, y) 把路径移动到画布中的指定点，不创建线条 lineTo (x, y) 添加一个新点，然后在画布中创建从该点到最后指定点的线条 bezierCurveTo (c1x, c1y, c2x, c2y, x, y) 创建三次方贝塞尔曲线 quadraticCurveTo (cx, cy, x, y) 创建二次贝塞尔曲线 arc (cx, cy, r, a0, a1, counterclockwise) 创建弧/曲线（用于创建圆形或部分圆） ellipse (cx, cy, rx, ry) 创建椭圆 circle (cx, cy, r) 创建圆形 rect (x, y, w, h) 创建矩形 close () 创建从当前点回到起始点的路径 stroke () 绘制已定义的路径 fill () 填充当前绘图（路径） clear () 清除所有路径 颜色，样式 属性 功能说明 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 strokeColor 设置或返回笔触的颜色 fillColor 设置或返回填充绘画的颜色 第三方库 绘图组件的 API 是参考的 Canvas 的绘图接口，而市面上已经有很多基于 Canvas 实现的绘图库，比如 paper.js、raphael.js。因此如果将这些绘图库的底层对接到绘图组件的 API，我们就可以直接使用这些高级的库的能力。不过要注意的是，绘图组件并没有完整实现 Canvas，而且修改绘图库的底层 backend 需要对绘图库有相当的了解。 - 线条虚线 - 简化路径 - 读取 svg -->"},"ui-system/components/editor/graphics/lineCap.html":{"url":"ui-system/components/editor/graphics/lineCap.html","title":"lineCap","keywords":"","body":"lineCap lineCap 属性设置或返回线条末端线帽的样式。 参数 描述 cc.GraphicsComponent.LineCap.BUTT 默认。向线条的每个末端添加平直的边缘。 cc.GraphicsComponent.LineCap.ROUND 向线条的每个末端添加圆形线帽。 cc.GraphicsComponent.LineCap.SQUARE 向线条的每个末端添加正方形线帽。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.lineCap = cc.GraphicsComponent.LineCap.ROUND; ctx.lineWidth = 10; ctx.moveTo(100, 100); ctx.lineTo(300, 100); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/lineJoin.html":{"url":"ui-system/components/editor/graphics/lineJoin.html","title":"lineJoin","keywords":"","body":"lineJoin lineJoin 属性设置或返回线条末端线帽的样式。 参数 描述 cc.GraphicsComponent.LineJoin.BEVEL 创建斜角。 cc.GraphicsComponent.LineJoin.ROUND 创建圆角。 cc.GraphicsComponent.LineJoin.MITER 默认。创建尖角。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.lineJoin = cc.GraphicsComponent.LineJoin.ROUND; ctx.moveTo(20,20); ctx.lineTo(100,50); ctx.lineTo(20,100); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/lineTo.html":{"url":"ui-system/components/editor/graphics/lineTo.html","title":"lineTo","keywords":"","body":"lineTo lineTo() 方法添加一个新点，然后创建从该点到画布中最后指定点的线条。 参数 描述 x 路径的目标位置的 x 坐标 y 路径的目标位置的 y 坐标 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.moveTo(20,100); ctx.lineTo(20,20); ctx.lineTo(70,20); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/lineWidth.html":{"url":"ui-system/components/editor/graphics/lineWidth.html","title":"lineWidth","keywords":"","body":"lineWidth lineWidth() 方法添加一个新点，然后创建从该点到画布中最后指定点的线条。 参数 描述 number 当前线条的宽度，以像素计。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.lineWidth = 20; ctx.rect(20,20,80,100); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/miterLimit.html":{"url":"ui-system/components/editor/graphics/miterLimit.html","title":"miterLimit","keywords":"","body":"miterLimit miterLimit 属性设置或返回最大斜接长度。 斜接长度指的是在两条线交汇处内角和外角之间的距离。 提示：只有当 lineJoin 属性为 \"miter\" 时，miterLimit 才有效。 边角的角度越小，斜接长度就会越大。 为了避免斜接长度过长，我们可以使用 miterLimit 属性。 如果斜接长度超过 miterLimit 的值，边角会以 lineJoin 的 \"bevel\" 类型来显示 参数 描述 number 正数。规定最大斜接长度。如果斜接长度超过 miterLimit 的值，边角会以 lineJoin 的 \"bevel\" 类型来显示。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.miterLimit = 10; ctx.moveTo(20,20); ctx.lineTo(100,50); ctx.lineTo(20,100); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/moveTo.html":{"url":"ui-system/components/editor/graphics/moveTo.html","title":"moveTo","keywords":"","body":"moveTo moveTo 表示一条路径的起点。 参数 描述 x 路径的目标位置的 x 坐标 y 路径的目标位置的 y 坐标 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.moveTo(0,0); ctx.lineTo(300,150); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/quadraticCurveTo.html":{"url":"ui-system/components/editor/graphics/quadraticCurveTo.html","title":"quadraticCurveTo","keywords":"","body":"quadraticCurveTo quadraticCurveTo() 方法通过使用表示二次贝塞尔曲线的指定控制点，向当前路径添加一个点。 提示：二次贝塞尔曲线需要两个点。第一个点是用于二次贝塞尔计算中的控制点，第二个点是曲线的结束点。曲线的开始点是当前路径中最后一个点 参数 描述 cpx 贝塞尔控制点的 x 坐标 cpy 贝塞尔控制点的 y 坐标 x 结束点的 x 坐标 y 结束点的 y 坐标 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.moveTo(20,20); ctx.quadraticCurveTo(20,100,200,20); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/rect.html":{"url":"ui-system/components/editor/graphics/rect.html","title":"rect","keywords":"","body":"rect rect() 方法创建矩形。 参数 描述 x 矩形左下点的 x 坐标。 y 矩形左下点的中心的 y 坐标。 width 矩形的宽度。 height 矩形的高度。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.rect(20,20,150,100); ctx.stroke(); var ctx = node.getComponent(cc.GraphicsComponent); // 红色矩形 ctx.lineWidth = 6; ctx.strokeColor = cc.Color.RED; ctx.rect(5,5,290,140); ctx.stroke(); // 绿色矩形 ctx.lineWidth=4; ctx.strokeColor = cc.Color.GREEN; ctx.rect(30,30,50,50); ctx.stroke(); // 蓝色矩形 ctx.lineWidth = 10; ctx.strokeColor = cc.Color.BLUE; ctx.rect(50,50,150,80); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/stroke.html":{"url":"ui-system/components/editor/graphics/stroke.html","title":"stroke","keywords":"","body":"stroke stroke() 方法会实际地绘制出通过 moveTo() 和 lineTo() 等路径方法定义的路径。默认颜色是黑色。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.moveTo(20,100); ctx.stroke(20,20); ctx.stroke(70,20); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/graphics/strokeColor.html":{"url":"ui-system/components/editor/graphics/strokeColor.html","title":"strokeColor","keywords":"","body":"strokeColor strokeColor 属性设置或返回用于笔触的颜色。 实例 var ctx = node.getComponent(cc.GraphicsComponent); ctx.lineWidth = 2; ctx.strokeColor = cc.hexToColor('#0000ff'); ctx.rect(20,20,250,200); ctx.stroke(); 返回 绘图组件 "},"ui-system/components/editor/ui-model.html":{"url":"ui-system/components/editor/ui-model.html","title":"UIModel 组件参考","keywords":"","body":"UIModel 组件参考 UIModel 是一个将 3D 模型从 3D 渲染管线转换到 2D 渲染管线的一个带有转换功能的渲染组件。该组件支持 3D 模型和粒子在 UI 上的显示，没有这个组件，即使模型和粒子节点在 UI 里也不会被渲染。 该组件的使用条件是将它添加到带有或继承自 ModelComponent 组件的节点上，粒子则是添加到粒子节点上，通常它的结构如下： UIModel 属性 属性 功能说明 priority 跟其余渲染组件，如：LabelComponent，SpriteComponent 等做渲染排序使用。 其他渲染模块参考 基础模块参考 "}}